// 5hell v 3.8.5 by Plu70
// released v 3.8.4
// imports .5pk files from /root/src
ver = "3.8.5_amalgamated_horrors"
DEBUG = false
if params and params.indexOf("--debug") >= 0 then DEBUG = true
size_of_5hell = "144.069"
///////////////////////////////////////
//
// changes:
//
// to do:
// convince author of Medusa to port it to 5hell // can just wrap medusa into a command. it just works.
// get command.do to persist through glasspool // first i have to figure out why it doesn't in the first place
// mail: add command line brutus login
// mail: add command line login
// mail: add easy button (config based) login
// database overhaul :(
// tdump: wait for response feature
// tdump: dump to local path
// add shell and computer object param to command.file
// add chmod/perms to command.felix
// kore -r needs to give /lib precedence when searching for components
// add custom theme config
// connect_service increases trace time: add something for that
// add a way to tell grep to ignore specific folders
// expand tree -f to take both path and object as params (jk have to start over)
// update 5phinx F1 help info: remove or correct outdated info
//
// scp falsely reports failure sometimes: track this down
//
// cat: added cats to cat
// string: added: string -r [old text] [new text] [text to parse]
// -- returns prased text with all instances of old text replaced with new text
// string: added: string [number] to return a number as a string
// md5: updated usage info
// file: now accepts an object as an additional parameter
// -- updated usage info
// -- runs file with the scope of the object
// -- eg: clipb @B [#] | file -c /etc/passwd
// ---- where [#] is the buffer index of a shell:
// ---- clips the shell and pipes it into: file [-c] [/path] [search_this_object]
// ---- and returns the character count (if not binary)
// do: added 'bat' shortcut for: do 1 -f to 5hell.src
// -- e.g: |> bat foo.bar  is the same as |> do 1 -f foo.bar
// added a sick a$$ new prompt to 5hell.src 
// fullprompt is now on by default
// -- red line: root, green line: user, white line: guest
// added the ability to put text inside of floating quotes into a single param:
// -- a floating quote is a single quote " passed as a parameter
// -- a single floating quote without a closing floating quote is parsed as is
// -- quotes touching text ( "example" ) are parsed as is
// ---- only " example text block " is parsed as a text block
// -- example: echo " bob's burgers is a great show "
// -- results in bob's burgers is a great show being printed to the screen
// -- echo bob's burgers is a great show, without quotes, would print:
// -- bob's burgers is a
// -- you may use multiple, but not nested, quote blocks
// -- e.g: echo /home/guest/rkit/5hell | clipa |   | echo do 1 -f dig.bat | run @a
// -- is the same as: run /home/guest/rkit/5hell " do 1 -f dig.bat "
// -- e.g: poke haha " this is a bunch of "text" " | echo this is some " more text. isn't it great? "
// -- works with easy clipc: clipa bob |  | echo burger | clipb |  | echo " @a @b "
// cp: updated usage info
// grep: updated and clarified usage
// grep: added -p option to return file path
// glasspool: updated splash info
// poke: removed pesky overwrite prompt
// perms: perms lock all and lock now look for Xorg in processes instead of user_email
// -- this will prevent bricking a home pc when lock is run before the user has created an email account
// liber: now checks against database and colorizes output
// db: database now trims itself from the top when it's too big
// -- still working on a (simple) multi file db solution
//
// added new command: diff [arg] [arg]
// enum: returns string instead of int, converts int input to string
// chop: added 4th param: outfile name
// pause: added a line break to pause -m
// rclean: changed cleaner file to xorg.conf (a txt file instead of binary)
// -- this will speed up scrubs
// do: fixed a crash when -f target is binary
//
// 5hell.src!!!! added get/set alias for cob get/cob set
// kore overhaul:
// -- -r == rkit , -s == secure protocol, -h == hdd size reporting
// -- defunct code commented out
// get_binaries: will now actually pull binaries from user home folders as well as system.log
// rm: gives more feedback
// cat: looks a little nicer
// whois: added neurobox network highlight
// fully reverted 5phinx facelift 
// perms: updated usage info
// added -n (nuke) option for rclean and updated usage info to include -d and -n
	// -d and -n work the same as silentclean -d and -n (more or less...)
// silentclean: updated usage info 
// kill: added option to kill by process name
// make: build path will default to currentPath if none supplied
// make: importable boolean should work now
//
// fixed typo in grep causing irritating crash
// -- grep and grep -f work normally again
// fixed typo in get_lib that caused a crash when getting a lib
// updated pause command and usage info
// updated cc usage info
// 
// broke dig --edit (again)
// fixed dig --edit (again)
// updated usage info for dig
// reverted 5phinx facelift
// added some clarification to linking a lib or netsession
// fixed typo in meta help that prevented displaying the entire string
// added libname and version to decompiler: metaLib
// added enum -e usage info (return the enum list)
// updated code usage info
// updated makfit usage info
// reminded self it's makfit not mkfit
// 
// document the below:
// greatly updated the usage information for the meta command
// updated herme5 mail client documentation for spool, delete all
// added exporting enum entries to malp en masse
// updated 5phinx documentation
// 5phinx/malp: added globals.get_binaries to pull all useful binaries from a shell
// -- added get binaries button to RSI and the shell handler in BUFFER
// -- uses newtree and enum
// -- CLI option soon(tm)
// mail: delete all added
// cleaned up the usege info for command.file 
// updated 5phinx UI
// updated grep usage info
// added documentation for grep -n
// updated enum documentation for new -b option
// hotfix:
// fixed an issue in tree -f : it was trying to enumerate empty lists
// fixed crash in kore -r
// fixed typo in mail that caused crash after brute forcing an email
// fixed syntax error causing loading local libs to crash
// fixed typo causing a crash with purge -o
//
//
// code: fixed char code return: code [char|string](returns: char code)
// db: added -m to customize scan with metaLib and metaxploitLib of choice // needs docs
// string: new command added: string -- for stringifying lists
// enum: added append function
// enum: added insert function
// enum: added purge function
// enum: map support soon(tm)
// ls: show all flag (formerly -a) is now implicit (i.e. always on)
// ls: ls -a and ls -A are now equivalent and will sort files alphabetically
// bios: added purging custom object
// bios: added several additional return types
// bios: added a line at the bottom to remind user that bios has more functionality
// cob: added purging custom object
// dig: fixed -s option. sussing works again.
// mail: -brutus option will save found password to custom_object
// mail: added spool function to herme5 > read mail (dump mail to file)
// meta: added lib param to link -l to skip menu: meta link -l [lib_name]
// -- omit path, just use that lib name i.e. net.so, libssh.so, etc
// meta: you can now import metaLib objects with meta link [object] // needs docs
// meta: improved importing metaxploitLib objects
// meta: added backing up and restoring original metaxploitLib object
// meta: updated documentation to reflect changes
// liber: -l option works again (dang typos)
// kore: fixed typo that caused an incorrect completion time to be printed
// pause: change minimum time from .1 to .001 seconds
// cc: using cc [index] will no longer spam the screen with the entire cc buffer
// removed legacy dictionary code
// removed duplicate cob code
//
// tagged 4 spc will now work properly again
// [9] download txt will work properly instead of going to the decompiler
// updated usage info for jtr to reflect proper order of params (that is: set size first, then word length)
//
// in globals.decompiler: changed locals.re to fe to avoid namespace conflict with regex engine (globals.re)
// added smtp command
// fixed error in p_validate when validating numbers
// 
// updated lanpro to be MUCH faster and more accurate
// -- lanpro now has two modes: remote and local
// -- modes are activated automatically
// -- a public ip will activate remote mode
// -- a lan ip or no ip will activate local mode
// if the public ip given matches the public ip of the local gateway:
// ---- local mode will be activated
// fixed missing end ifs in r_hecks >> 5hpinx.5pk
// -- no idea how it was working without those :|
// glasspool should now start you off in the home directory of the chosen object
// further updated the for loop in command.dig
// updated dig to correctly parse ip/port when both come in as arg1
// -- e.g when piping command.target to command.dig
//
// fixed the --edit param for dig
// fixed crash in p_validate when validating numbers
// fixed crash in 5phinx on port scan
// fixed error in dig not setting permissions correctly
//
// IMPORTANT! 5hell.src has changed!
// added @tbuf alias to 5hell.src
// tree should no longer duplicate entries to the tbuf
// fixed bug in command.poke that caused writing to / on bad input
// updated malp to properly use p_exe for functions
// updated p_exe to handle raw functions as well as functions within maps/objects
// updated decompiler to use p_exe for functions
// updated dump_memory to dump the clipboards as well as t_buf
//
// added new_exit to 5phinx
// -- will add the exit return value to the custom_object.return_value
// -- added Jessa to credits
// fixed rclean to delete the correct rkit on -d
// fixed rclean to correctly scrub log when using -d on piped object
// updated silentclean help info
// adjusted output of linkdb/meta link
// updated meta link to correctly warn about leaving a log
// fixed typo in rsi: will print correct rshell index when using -r
// updated dig help extra to a better script
// -- use @home in r.bat to avoid leaving an ip
// added @home alias to 5hell.src 
// this means update 5hell.src as well as 5hell.5pk!!
// -- @home as cli parameter will be replaced by HOME_SERVER[0] -- the home server ip address
// fixed crash on bad input in liber
//
// added null file check to p_validate
// -- should prevent null file crashes
// tree: added -f option to enumerate files as objects
// enum: will properly add lists to the enum buffer
// -- soon(tm) tree will be rewritten to use this new format for all tree functions
// glasspool: -r option will now select correct rshell index
//
// fixed rsi -p (and purge -r): will work correctly now
// -- warning purging rsi kills ALL programs on the target
// -- this is because rshells may have any name and I'm not writing 1000
// -- lines of code to determine what you named your rshells
// meta link: removed erronious warning about leaving a log
// -- linking a net session no longer results in a connection log!
// fixed kraken crash on bad input
// fixed crash in run on bad input
//
// fixed whatever is causing db -r * to crash 
// fixed db -r [ip] * to scan the router as well
// -- also fixed a weird crash in db
// added drugwars.5pk to games!
// updated help files for below changes
// file -n|-p -- return file name or path
// added import option to aptm (pipe an aptclientLib to switch scope!!)
// fixed display error in ifconfig
// added bios -m -- returns the metaLib object
// added import option to the meta command
// -- pipe a metaxploitLib to meta -i
// -- meta -i MetaxploitLib will change scope to a remote metax
// -- use cob set to export it from a target and cob get to import it once you return
// rsi: added option to kill all rshells (same as purge -r)
// fixed integer casting in p_exe (decompiler function handler)
// fixed hashim path parameter
// fixed glasspool to rshell connect
// added command line options for rsi (return objct, auto select)
//
// added purge -r for purging the RSI buffer
// run: new usage: run [path|file object] [params | shell object] [shell object | params]
// scpm: added more command line options. eg destination param
// scpm [opt:-d] [opt:path_from] [opt:path_to] [opt: shell_object]
// grep -f [pattern] [path] - return the first matching file as an object
// added try source to 5phinx. not yet implemented, though.
// expanded rm capabilities. now takes file, computer, shell objects
// 5phinx: changed whois to probe
// fixed rkit construction in kore. now searches for parts correctly.
// malp: fixed crash when file object in BUFFER is deleted from filesystem
//
// fixed typo in psduo
// fixed database.csv being written only to /root/rkit *
// -- now searches for rkit and places file in first rkit found
// 
// added command: glasspool [opt] -- command line use of BUFFER glasspool function 
// added command: tdump [opt] -- dump tbuf to a pass file (e.g. use in conjunction with hashim)
// -- added dump tbuf to computer handler. does the above.
// log spoof in file handler correctly searchs for a suitable file to use for spoofing
// completely rewrote transmit. now requires @home setup in 5hell.src
// -- transmits tbuf directly to pass file on @home server (where hashim -d should be running)
// removed filemon, dbmon. will return as monitor in the future
// silentclean -d will delete rkit if it is the parent path of 5hell (deletes 5hell otherwise)
// rclean -d [opt] will delete rkit if it is the parent path of 5hell (deletes 5hell otherwise) 
// shell handler in BUFFER won't auto exit anymore
// computer handler in BUFFER accepts 'q' for quit
//
// added delete all to mail
// added check grp, check usr
// fixed crash in usr/grp when arguments invalid
// added wildcard option to db/dbaser
// updated netdump output
// updated malp menu: added netsession info
// fixed battleship
// sped up grep a tiny bit
// dig [ip] [port] and dig [port] [ip] are now both valid, to help with piping
// sped up pwgen/cerebrum immensely
// updated cerebrum to load to custom object
// added option to dig to reverse inputs
// fixed crash in perms
// changed the permissions checks in check_user from read to write
// fixed another bug in decompiler and p_exe
// updated some help documentation
// completely rewrote gopher, commented out old version in 5phinx.5pk
// extended partial object support to all main object types
// added more partial object support
// scribus: disabled confirmation before opening file
// fixed crash in grep when grepping
// added partial support for partial objects
// fixed crash in db when target ip invalid
// fixed crash in make when path invalid
// minor update to the 5phinx gui
// rclean: fixed an input bug
// aptm: changed "go back" to "exit" to avoid confusion
// changed position of jtr and cob in the help menu
// cerebrum: fixed a bigbrain bug
// added several additional checks for active network to avoid crashes (more to come)
// target: rewritten to be more useful and intuitive
// fixed makfit pathing errors
// added rsi -i|install -- install the rshell server if librshell.so is in /lib
// updated cerebrum and brutus dictionary imports
// changed clipspace buffer selection back to @B (clipb @B -m|#)
// changed ez clip back to @a,@b,@c
// updated help search to include regex
// added 'search' as param for help
// added highlighting to help -s|show|search
// updated cob to have an install function (install functions from custom object)
// fixed outmon interval (maybe?)
// fixed easy clip and clipspace buffer selection (@b)
// fixed crash when checking wifi when wifi is disabled
// updated dictionary file imports. Default is no import. Create files per instructions (below) and uncomment import lines as needed.
// rclean: fixed bug caused by switch from @B to @b
// clipb: changed @B to @b
// changed easy clip to @A,@B,@C
// fixed missed global reference in rsi causing error in experimental mode
// clipa|b|c: fixed error when using clipb @B # in experimental mode
// fixed bios display for clipboards, fixed db -l crash
// liber: now works on directories
// improved db -l
// 5phinx: fixed [-] clear_db button
// file: info now indicates importable status
// malp: buffer items directly with malp [thing]
// brutus/ssh: fixed infinite loop in -brutus attack for ssh
// whois: added default to local
// scpm: added file or string_path input options
// poke: -n option; sets file content to null
// malp: update_path when returning from glasspool
// clipboard: updated help info and fixed clipb @B 0 issue
// 5phinx/memory alpha/kraken: logic updated
// malp: corrected typo when uploading rkit via BUFFER
// cerebrum | brutus: actually fixed 'Dictionary: 0 not found' error
// 5phinx: bank_heist will prompt to activate cerebrum when gopher is selected for decipher
// updated @home helpfile
// removed /virt filesystem dependancy for hashim, dbmon, kore -r
// updated compatibility with new miniscript version
// added line break in port mapper
// updated help info for transmit. clarified use.
// fixed kore -r -- rkit construction (missed crypto.so)
// --debug mode
// purge: updated confirmation, added tagged4scp option
// memAlpha: added tagged4scp option to files in buffer
// scpm: added tagged4scp option
// pwgen: moar seeds
// 5phinx: port info in hooked_comp
// brutus: import directory of csv or nsv files
// cerebrum: import dir of csv or newline separated value files
// updated cerebrum -i @home
// fixed bug in mv deleting folder if moved over itself
// sniff: help file updated
// 5hell.src: added "sc" shortcut
// updated air: manual and -c option
// added blockmon, cmin7, wt
// moved dig to its own .5pk and merged mal.5pk with 5hell.5pk
// improved cerebrum load time
// added /tables/tp option to herme5 brute force
// smtpul added
//
// fixed cc #
// fixed rclean #
//
// todo:
// blockain, wallet, smtp_u_l,
// portmapper; spider ping, herme5; address book,
// porter; add a lib finder filter
//
///////////////////////////////////////
if DEBUG then print("<size=75%>loading globals...</size>") else print("<align=center><mark=red><color=black>#</color></mark></align>")
apt_get = include_lib("/lib/aptclient.so")
if not apt_get then apt_get = include_lib(current_path+"/aptclient.so")
if not apt_get then print("WARNING: aptclient.so not found in /lib")
mlib = true
globals.metaxploit = include_lib("/lib/metaxploit.so")
if not globals.metaxploit then
	mlib = false
	globals.metaxploit = include_lib(current_path+"/metaxploit.so")
end if
if not globals.metaxploit then print("WARNING: metaxploit.so not found")
clib = true
crypto = include_lib("/lib/crypto.so")
if not crypto then
	clib = false
	crypto = include_lib(current_path+"/crypto.so")
end if
if not crypto then print("WARNING: crypto.so not found")

meta_path = "/lib/metaxploit.so"
if mlib == false then meta_path = current_path+"/metaxploit.so"
cryp_path = "/lib/crypto.so"
if clib == false then cryp_path = current_path+"/crypto.so"

metaLibVersion = "0.0.0"
cryptoLibVersion = "0.0.0"
if globals.metaxploit then metaLibVersion = globals.metaxploit.load(meta_path).version
if crypto and metaxploit then cryptoLibVersion = globals.metaxploit.load(cryp_path).version

globals.BIGBRAIN = false
globals.GLASSPOOL = 0
globals.command_buffer = []
globals.shell = get_shell
globals.metaLib = null
globals.net_session = null
globals.localmachine = shell.host_computer
globals.currentPath = current_path
globals.homePath = home_dir
globals.enumerated = []
globals.stack_pool = 14 // depricated
globals.tagged_for_scp = ""
globals.backup_meta = null
//globals.services = {}

targ = {"ip":"0.0.0.0", "pt":0} // edit this to match your server or pass ip and port when calling transmit or target ip and port
if params and params.len > 0 then targ.ip = params[0]
if params and params.len > 1 then targ.pt = params[1].to_int
localip = localmachine.local_ip
pubip = localmachine.public_ip
clip_board_alpha = ""
clip_board_beta = ""
clip_board_gamma = ""
clip_board_delta = "" // for do

instance = localmachine.File(program_path)

// import 5phinx -- this contains critical shared functions and the backbone of the hacking suite
import_code("/root/src/5phinx.5pk")

//
// while importing a starting dictionary is still possible it is no longer supported
// current runtim loading of cerebrum is 20 seconds and importing from filesystem is less than 1 second
// start dictionaries are therefore superfluous
if DEBUG then print("<size=75%>loading dictionary...</size>")
// this function puts the dictionary in the custom object for use between nested launches without breaking legacy dictionary calls
globals.dict_a = function(import=0)  
	cobble = get_custom_object
	if typeof(import) == "list" then cobble.dictionary = import // set a new dicitonary from input: list
	if not cobble.hasIndex("dictionary") then cobble.dictionary = ["a"] // set default dictionary if it doesn't exist
	return cobble.dictionary // return the dictionary in all cases as a list
end function
//// UPDATING THE DICTIONARY IS HANDLED BY COMMAND.CEREBRUM //////
//// COB import and COB export are now deprecated commented out
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
if DEBUG then ds = dict_a.len
if DEBUG then print("<size=75%>dictionary loaded...("+(ds/1000)+"kb)</size>")
globals.routerLib = null
globals.targetIP = null
globals.targetPort = "router"
globals.PORT_MAP = {}
globals.HERMES = false
globals.inbox = null
globals.BUFFER = [get_shell]
globals.XPLOITS = []
globals.MEMORY = null
globals.meta_scan = []
globals.T_BUF = [(localip+"@"+pubip)] // transmission buffer
globals.portInfo = null
globals.tarLan = null
globals.grepped_file = null
globals.airing = false
globals.mail_user = null
globals.last_mail = null
globals.this_mail = 0

colorRed = "<color=#FF0000FF><b>"
colorGreen = "<color=#00FF00FF><b>"
colorWhite = "<color=#FFFFFFFF><b>"
colorCyan = "<color=#00FFFFFF><b>"
colorGold = "<color=#CCCC00FF><b>"
colorBlack = "<color=#000000FF><b>"
colorOrange = "<color=#FF8400FF><b>"
colorMagenta = "<color=#FF00C8FF><b>"
colorLightBlue = "<color=#2382FFFF><b>"
CT = "</color></b>"

globals.get_file = function(input_string)
	if DEBUG then print("in_get_file: "+@input_string)
	if typeof(input_string) == "file" then return input_string.path
	if typeof(@input_string) != "string" then return 0
	if input_string == "" or input_string == " " or not input_string then return 0
	if input_string.split("/")[0] == "" then
		file = localmachine.File(input_string)
	else
		file = localmachine.File(currentPath+"/"+input_string)
  	if not file then file = localmachine.File(currentPath+input_string)
	end if
	if DEBUG then
		if file then print("File: ["+file.path+"]") else print("File: [not found]")
	end if
  if file then return file else return 0
end function
// end globals
if DEBUG then print("<size=75%>loaded get_file...</size>")                       ////////////////////////////////
if DEBUG then print("<size=75%>loading 5hell.5pk...("+size_of_5hell+"kb)</size>")                   /////LOADING 5HELL///////////////////////////////////
if DEBUG then print("<size=75%>loading clipcommander.5pk...(6.660kb)</size>")     ////////////////////////////////
command.clipa = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if typeof(@arg1) == "function" then
		globals.clip_board_alpha = @arg1
		print(colorCyan+"clipped: "+typeof(@globals.clip_board_alpha))
		return @globals.clip_board_alpha
	end if
	if arg1 == "help" or arg1 == "-h" then return "<u>clipboard alpha || clipa || clipspace</u>"+char(10)+"Usage:"+char(10)+" clipa: pipe outputs to clipa with: command | clipa"+char(10)+" clipa [optional:arg|string|list|map|@tbuf|@cc|@B {opt:-m|#}]"+char(10)+"-- add any of the above to clipa"+char(10)+"clipa -- <b>Returns</b> contents of clipa if no arguments."+char(10)+"scribus @clipa -- edit clipa directly with the text editor."
	if arg1 == "0" then
		globals.clip_board_alpha = "0"
		print(colorCyan+"clipped: "+typeof(@globals.clip_board_alpha))
		return globals.clip_board_alpha
	end if
	if arg1 == 0 then
		if typeof(@globals.clip_board_alpha) == "function" then return @globals.clip_board_alpha else	return globals.clip_board_alpha
	end if
	globals.clip_board_alpha = arg1
	if arg1 == "@tbuf" then
		globals.T_BUF.pull
		globals.clip_board_alpha = globals.T_BUF.join(char(10))
		globals.T_BUF = [(localip+"@"+pubip)]
	end if
	if arg1 == "@cc" then	globals.clip_board_alpha = globals.command_buffer.join(char(10))
	if arg1 == "@B" then
		if globals.BUFFER.len < 1 then return "BUFFER is empty."
		i = 0
		for b in globals.BUFFER
			if typeof(@b) == "function" then print("["+colorWhite+i+CT+"] - <b>"+checkUser(@b)+":"+typeof(@b)+"</b>") else print("["+colorWhite+i+CT+"] - <b>"+checkUser(b)+":"+typeof(b)+"</b>")
			i = i + 1
		end for
		get = arg2
    if get and get != "-m" then get = arg2.to_int
    if get == "-m" then get = user_input("clipa:> ").to_int
		if typeof(get) != "number" then return "BUFFER: invalid selection."
		if get >= 0 and get < BUFFER.len then globals.clip_board_alpha = BUFFER[get] else return "BUFFER: invalid selection."
	end if
	print(colorCyan+"clipa: clipped: "+typeof(@globals.clip_board_alpha))
	if typeof(@globals.clip_board_alpha) == "function" then return @globals.clip_board_alpha else	return globals.clip_board_alpha
end function
command.clipb = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if typeof(@arg1) == "function" then
		globals.clip_board_beta = @arg1
		print(colorCyan+"clipped: "+typeof(@globals.clip_board_beta))
		return @globals.clip_board_beta
	end if
	if arg1 == "help" or arg1 == "-h" then return "<u>clipboard beta || clipb || clipspace</u>"+char(10)+"Usage:"+char(10)+" clipb: pipe outputs to clipb with: command | clipb"+char(10)+" clipb [optional:arg|string|list|map|@tbuf|@cc|@B {opt:-m|#}|function]"+char(10)+"-- add any of the above to clipb"+char(10)+"clipb -- <b>Returns</b> contents of clipb if no arguments."+char(10)+"scribus @clipb -- edit clipb directly with the text editor."+char(10)+"N.B. please be awake that command.<b>append</b> works a bit differently with clipb than with clipa or clipc."+char(10)+"-- see append -h for more info."
	if arg1 == "0" then
		globals.clip_board_beta = "0"
		print(colorCyan+"clipped: "+typeof(@globals.clip_board_beta))
		return globals.clip_board_beta
	end if
	if arg1 == 0 then
		if typeof(@globals.clip_board_beta) == "function" then return @globals.clip_board_beta else	return globals.clip_board_beta
	end if
	globals.clip_board_beta = arg1
	if arg1 == "@tbuf" then
		globals.T_BUF.pull
		globals.clip_board_beta = globals.T_BUF.join(char(10))
		globals.T_BUF = [(localip+"@"+pubip)]
	end if
	if arg1 == "@cc" then	globals.clip_board_beta = globals.command_buffer.join(char(10))
	if arg1 == "@B" then
		if globals.BUFFER.len < 1 then return "BUFFER is empty."
		i = 0
		for b in globals.BUFFER
			if typeof(@b) == "function" then print("["+colorWhite+i+CT+"] - <b>"+checkUser(@b)+":"+typeof(@b)+"</b>") else print("["+colorWhite+i+CT+"] - <b>"+checkUser(b)+":"+typeof(b)+"</b>")
			i = i + 1
		end for
		get = arg2
		if get and get != "-m" then get = arg2.to_int
		if get == "-m" then get = user_input("clipb:> ").to_int
		if typeof(get) != "number" then return "BUFFER: invalid selection."
		if get >= 0 and get < BUFFER.len then globals.clip_board_beta = BUFFER[get] else return "BUFFER: invalid selection."
	end if
	print(colorCyan+"clipb: clipped: "+typeof(@globals.clip_board_beta))
	if typeof(@globals.clip_board_beta) == "function" then return @globals.clip_board_beta else	return globals.clip_board_beta
end function
command.clipc = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if typeof(@arg1) == "function" then
		globals.clip_board_gamma = @arg1
		print(colorCyan+"clipped: "+typeof(@globals.clip_board_gamma))
		return @globals.clip_board_gamma
	end if
	if arg1 == "help" or arg1 == "-h" then return "<u>clipboard gamma || clipc || clipspace</u>"+char(10)+"Usage:"+char(10)+" clipc: pipe outputs to clipc with: command | clipc"+char(10)+" clipc [optional:arg|string|list|map|@tbuf|@cc|@B {opt:-m|#}]"+char(10)+"-- add any of the above to clipc"+char(10)+"clipc -- <b>Returns</b> contents of clipc if no arguments."+char(10)+"scribus @clipc -- edit clipc directly with the text editor."
	if arg1 == "0" then
		globals.clip_board_gamma = "0"
		print(colorCyan+"clipped: "+typeof(@globals.clip_board_gamma))
		return globals.clip_board_gamma
	end if
	if arg1 == 0 then
		if typeof(@globals.clip_board_gamma) == "function" then return @globals.clip_board_gamma else	return globals.clip_board_gamma
	end if
	globals.clip_board_gamma = arg1
	if arg1 == "@tbuf" then
		globals.T_BUF.pull
		globals.clip_board_gamma = globals.T_BUF.join(char(10))
		globals.T_BUF = [(localip+"@"+pubip)]
	end if
	if arg1 == "@cc" then	globals.clip_board_gamma = globals.command_buffer.join(char(10))
	if arg1 == "@B" then
		if globals.BUFFER.len < 1 then return "BUFFER is empty."
		i = 0
		for b in globals.BUFFER
			if typeof(@b) == "function" then print("["+colorWhite+i+CT+"] - <b>"+checkUser(@b)+":"+typeof(@b)+"</b>") else print("["+colorWhite+i+CT+"] - <b>"+checkUser(b)+":"+typeof(b)+"</b>")
			i = i + 1
		end for
		get = arg2
		if get and get != "-m" then get = arg2.to_int
		if get == "-m" then get = user_input("clipc:> ").to_int
		if typeof(get) != "number" then return "BUFFER: invalid selection."
		if get >= 0 and get < BUFFER.len then globals.clip_board_gamma = BUFFER[get] else return "BUFFER: invalid selection."
	end if
	print(colorCyan+"clipc: clipped: "+typeof(@globals.clip_board_gamma))
	if typeof(@globals.clip_board_gamma) == "function" then return @globals.clip_board_gamma else	return globals.clip_board_gamma
end function
command.passwd = function(arg1, arg2, arg3=0, arg4=0)
  if arg1 == "help" or arg1 == "-h" then return "Usage: passwd [optional: user] [option: pass] -- change passwd. prompts if no arguments given."
	user = null
	pass = null
	if arg1 then user = arg1
	if arg2 then pass = arg2
	if not user then user = user_input("user: ")
  if not pass then pass = user_input("new password: ",1,0)
	if pass == "" or pass == " " then return "aborting..."
  try = localmachine.change_password( user, pass)
  if try == 1 then return pass
  return try
end function
command.echo = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "Usage: echo [string] -- (string is max 4 words. returns string to the terminal. Useful when using 'do.'"
	ec = arg1+" "
	if arg2 then ec = ec + arg2+" "
	if arg3 then ec = ec + arg3+" "
	if arg4 then ec = ec + arg4
	return ec.trim
end function
command.clear = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "clear (clears the terminal of all data)"
	clear_screen
	return 0
end function
command.ps = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 then return(command_info("ps_usage"))
	output = localmachine.show_procs
	return format_columns(output)
end function
command.kill = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0  or arg1 == "-h" or arg1 == "help" then return "KILL || END PROCESS || TERMINATE SCRIPT"+char(10)+
	"Usage: kill [PID] [opt: shell|computer] -- terminate PID"+char(10)+
	"-- PID should be process number or ALL"+char(10)+
	"-- see the <b>ps</b> command for process ID's"+char(10)+
	"--<b> kill ALL </b>will attempt to close all programs."+char(10)+
	"n.b. if<b> kill ALL </b>kills the terminal that launched the program,"+char(10)+
	"---- it might not complete its task."+char(10)+char(10)+
	"Usage: kill [process_name] [opt: shell|computer] --"+char(10)+
	"-- kill process by process name instead of PID"+char(10)+char(10)+
	"Note: piping a shell or computer object runs kill on the object instead of locally"+char(10)+
	"Note: running kill while glasspool is active runs kill on the active object"
	target_machine = globals.localmachine
	if typeof(arg2) == "shell" then 
		target_machine = arg2.host_computer
	end if
	if typeof(arg2) == "computer" then 
		target_machine = arg2
	end if
	if typeof(arg1) == "string" then 

		if typeof(arg1.to_int) == "number" then PID = arg1.to_int else PID = arg1
	else 
		return "kill: invalid input"+char(10)+"Usage: kill [pid|process_name] [opt:shell|computer]"
	end if
	if typeof(PID) == "string" then
		processes = target_machine.show_procs.split(char(10))
		for p in processes
			if p == "USER PID CPU MEM COMMAND" then continue
			process = p.split(" ")
			process_ID = process[1]
			process_CMD = process[4]
			stor = globals.localmachine
			globals.localmachine = target_machine
			if PID == "ALL" or PID == process_CMD then print(command.kill(process_ID))
			globals.localmachine = stor
		end for
		return 0
	end if
	output = target_machine.close_program(PID)
	if output == true then return("kill: terminating process: " + PID + "...");
	if output then return(output)
	return "kill: process <u>" + PID + "</u> not found"
end function
command.pwd = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "pwd: returns current path"
	return currentPath
end function
command.psudo = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "Usage: psudo -- shell session management; without args prompts user for input:"+char(10)+"-- 'y' to open current active shell, 'c' to enter credentials (ie escalate privileges)"+char(10)+"Usage: psudo -s [opt:password] -- get root a shell and send it to BUFFER (prompts for password if not supplied)"+char(10)+"Usage: [shell_returned_by_function] | psudo -- open piped shell"+char(10)+"Example: ssh root@pass 1.1.1.1 | psudo  -- to be prompted to open terminal immediately instead of sending shell to buffer."+char(10)+"N.B. psudo may be used to 'go live' from glasspool (ie open the shell) but running a binary via glasspool"+char(10)+"i.e. glasspool >> run 5hell"+char(10)+"(shell.launch(5hell))... running psudo will end the shell.launch session and return you to the glasspool session."+char(10)+"This is not something I can control."+char(10)+"Advanced: psudo -- answer 'y' at prompt. Pipes current session, useful for hiding the ip of your previous connection."
	psl = globals.shell
	if arg1 and arg1 == "-s" and not arg2 then
		psl = user_input("root pass:> ",1,0)
	end if
	if arg2 and arg1 == "-s" then
		psl = arg2
	else
		if arg1 and (typeof(arg1) == "shell" or typeof(arg1) == "ftpshell") then psl = arg1
	end if
	return globals.shell_prompt(psl)
end function
command.ls = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "List Files | List Folders | File Details"+char(10)+"Usage: ls [opt: -l|-a|-la] [opt: /path] -- list files in path"+char(10)+"OPT: -l -- list file details"+char(10)+"OPT: -a -- list all files (including hidden .files)"+char(10)+"-- <b>deprecated</b> shall all flag is now implicit (always on)"+char(10)+"-- -a and -A are now equivalent"+char(10)+"OPT: -A|-a -- list files alphabetically "+char(10)+"-- by default files and folders are listed from first created to last created "+char(10)+"Note: option flags may be combined. ie: -la"+char(10)
	folderPath = globals.currentPath
	if DEBUG then print("ls: "+folderPath)
	showHide = 1
	showDetails = 0
	a_order = 0
	s_order = 0
	if arg1 then 
		if arg1.indexOf("-") == 0 then // we have flags
			if arg2 then folderPath = arg2
			//if arg1.indexOf("a") != null then showHide = 1
			if arg1.indexOf("l") != null then showDetails = 1
			if arg1.indexOf("A") != null then a_order = 1
			if arg1.indexOf("s") != null then s_order = 1
		else 
			folderPath = arg1
		end if
	end if 
	folder = globals.get_file(folderPath)
	if not folder then return "ls: No such file or directory"
	if DEBUG then print("folder: "+folder.path+" is a: "+typeof(folder))
	//if not folder.has_permission("r") then return "ls: permission denied"
	if folder.is_folder then 
		subFiles = folder.get_folders + folder.get_files
		if a_order then 
			f_buf = []
			s_buf = []
			for sub in subFiles 
				f_buf.push(sub.name)
			end for
			f_buf.sort
			for f in f_buf 
				for sub in subFiles
					if sub.name == f then s_buf.push(sub)
				end for 
			end for 
			subFiles = s_buf
		end if
	else 
		subFiles = [folder]
	end if
	output = ""
	for subFile in subFiles
		nameFile = subFile.name
		permission = subFile.permissions
		owner = subFile.owner
		size = subFile.size
		group = subFile.group
		is_bin = subFile.is_binary
		if showHide or nameFile.indexOf(".") != 0 then
			if showDetails then
				output = output + char(10) + permission + " " + owner + " " + group + " "+ size + " bin["+is_bin+"] " + nameFile
			else
				output = output + char(10) + nameFile
			end if
		end if
	end for
	return format_columns(output)
end function
command.cd = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: cd [path] -- change current working directory to path."+char(10)+"Usage: cd .. -- go back to parent directory."+char(10)+"Usage: cd -- return to home directory."+char(10)+"Returns: 0 on success or string on failure."
	if arg1 == "" then arg1 = 0
	if not globals.get_file(globals.currentPath) then globals.currentPath = home_dir
	cd = localmachine.File(globals.currentPath)
	if not arg1 then
		globals.currentPath = globals.homePath
		return 0
	end if
	if not cd then
		globals.currentPath = "/"
		return "cd: path error. Setting path to<b> / </b>"+char(10)+"...please try again."
	end if
	if arg1 == ".." then
		if cd.name != "/" then
			globals.currentPath = cd.parent.path
		end if
		return 0
	end if
	new_path = globals.get_file(arg1)
	if new_path then
		if new_path.is_folder then globals.currentPath = new_path.path else return "cd: "+new_path.path+" is not a directory."
	else
		return "cd: "+arg1+" not found."
	end if
	return 0
end function
command.rm = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == "-h" or arg1 == "help" then return "<b><u>Remove File || RM || Delete</b></u> "+char(10)+"Usage: rm [opt:-r] [path|file_object] [opt:shell|computer]"+char(10)+"Usage: rm [path|file_object] - deletes a file"+char(10)+"Usage: rm -r [path|file_object] - deletes a folder (and all contents)"+char(10)+"Usage: rm [opt:-r] [/absolute/path] [shell_object|computer_object]"+char(10)+"-- uses supplied shell or computer to delete file or folder at path"+char(10)+char(10)+"N.B. The system.log delete entry will be from the originating IP"+char(10)+"-- NOT the ip of the remote shell or computer"+char(10)+"-- be sure to clean the log when remote deleting"
	path_to_delete = null
	recursive = false
	remote = false
	shell_to_use = globals.shell 
	file = null
	usage = "rm: usage:<b> rm [opt:-r] [path|file_object] [opt:shell|computer]</b>"
	print "<u>"+colorRed+"- - - - - "
	if arg1 == "-r" then 
		recursive = true 
		arg1 = arg2 
		arg2 = arg3 
	end if	
	if not arg1 then return usage
	if typeof(arg1) == "string" then 
		path_to_delete = arg1 
		file = globals.get_file(path_to_delete)
	end if
	if typeof(arg1) == "file" then 
		file = arg1
		path_to_delete = file.path 
	end if
	if typeof(arg1) == "shell" or typeof(arg1) == "computer" then return usage
	if not path_to_delete then return usage 
	if arg2 and typeof(arg2) == "shell" then 
		shell_to_use = arg2 
		remote = true 
		file = shell_to_use.host_computer.File(path_to_delete)
		if not file then return "rm: file not found on remote shell." else print "rm: found file on remote shell..."
	end if
	if arg2 and typeof(arg2) == "computer" then file = arg2.File(path_to_delete) 
	if file then
		if not file.has_permission("w") then return "rm: permission denied"
		print "rm: "+colorWhite+"deleting: </b><u>"+file.path
		if file.is_folder then
			if recursive == true then return file.delete else return "rm: use<b> rm -r [path|file_object] </b>to remove a folder."
		end if
		return file.delete
	end if
	return "rm: file not found."
end function
command.mv = function(arg1, arg2=0, arg3=0, arg4=0)
  if arg1 == 0 or arg2 == 0 or arg1 == "-h" or arg1 == "help" then return "Usage: mv [/source_path] [/destination_path] -- move file or folder to new path."+char(10)+"-- if destination is folder uses original filename, else renames."+char(10)+"Advanced: mv [/source/path] [@] -- move source to current path and use original file name."+char(10)+"n.b. this command is also used to rename a file."+char(10)+"e.g.<b> mv bob /burger -- moves bob to / dir and renames to burger."
  file = globals.get_file(arg1)
  if not file then return("mv: can't find " + arg1)
	destination = null
	final_name = null
	dest = globals.get_file(arg2)
	if not dest then
		split = arg2.split("/")
		final_name = split.pop
		if DEBUG then print("split: "+split)
		if split.len and split[0] == "" then dest = globals.get_file(split.join("/")) else dest = globals.get_file(split.join("/"))
		if DEBUG then print("dest: ["+dest+"]")
		if not dest then
			if arg2[0] == "/" then destination = "/" else destination = currentPath
		else
			destination = dest.path
		end if
	else
		if dest.is_folder then
			destination = dest.path
			final_name = file.name
			if dest.path == file.path then destination = dest.parent.path
		else
			destination = dest.parent.path
			final_name = dest.name
		end if
	end if
	if final_name == "@" then final_name = file.name
	if destination == "/" then print "mv: "+file.path+" -> "+destination+final_name+"..." else print "mv: "+file.path+" -> "+destination+"/"+final_name+"..."
  return file.move( destination, final_name )
end function
command.cp = function(arg1, arg2=0, arg3=0, arg4=0)
  if arg1 == 0 or arg2 == 0 or arg1 == "-h" or arg1 == "help" then return "COPY || copy files || CP"+char(10)+
  "Usage: cp [/old_path] [/new_path] -- copy file or folder to new_path "+char(10)+
  "Usage: cp [/old_path] [@] -- copy old path to current path and use original file name"+char(10)+
  "Usage: cp [/old/path] [/newpath/newname] -- make a copy of a file with a new name/path"+char(10)+
  "Usage Example:"+char(10)+
  "-- cp /root/file.txt @ "+char(10)+
  "---- copies file.txt to the current directory with name: file.txt"+char(10)+
  "Usage Example:"+char(10)+
  "-- poke /root/haha |  | poke /root/heehee |  | cp /root/haha /root/heehee"+char(10)+
  "---- creates files haha and heehee then copies haha over heehee, overwriting heehee"+char(10)+
  "Usage Example:"+char(10)+
  "-- poke haha |  | grep -p syst / | cp haha"+char(10)+
  "---- create file haha, grep for (system.log) and return file_path, overwrite /var/system.log with haha"
  file = globals.get_file(arg1)
  if not file then return("cp: can't find " + arg1)
  destination = null
  final_name = null
  dest = globals.get_file(arg2)
  if not dest then
    split = arg2.split("/")
    final_name = split.pop
		if DEBUG then print("split: "+split)
    if split.len and split[0] == "" then dest = globals.get_file(split.join("/")) else dest = globals.get_file(split.join("/"))
		if DEBUG then print("dest: ["+dest+"]")
		if not dest then
      if arg2[0] == "/" then destination = "/" else destination = currentPath
    else
      destination = dest.path
    end if
  else
    if dest.is_folder then
      destination = dest.path
      final_name = file.name
    else
      destination = dest.parent.path
      final_name = dest.name
    end if
  end if
	if final_name == "@" then final_name = file.name
	if destination == "/" then print "cp: "+file.path+" => "+destination+final_name+"..." else print "cp: "+file.path+" => "+destination+"/"+final_name+"..."
	print colorGold+"- - - - - - - - - - - - - - - - - - - - - - -"
  return file.copy( destination, final_name )
end function
command.usr = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "-h" or arg1 == "help" then return "USR || ADD USER || CHOWN"+char(10)+"Usage: usr [optional: -r -- recursive] [new_owner] [path] "+char(10)+"Usage: usr [add|del] [opt:user] -- add | remove users from system."+char(10)+"Usage: usr [path] -- return owner of file at path"+char(10)+"-- Do not a name user add or del, for #reasons."+char(10)+"-- It is good practice to run:"+char(10)+"|><b> usr -r root / | grp -r root / | rm /etc/passwd | lock </b>"+char(10)+"for optimal security."
	is_recursive = false 
	if arg1 == "add" then
		if not arg2 then arg2 = user_input("new_user:> ")
		if arg2 == "" then return "usr: aborting..."
		print "usr: attempting to create user. Please secure the new folder if successful."
		return localmachine.create_user(arg2, user_input(arg2+" password:> "))
	end if
	if arg1 == "del" then
		if not arg2 then arg2 = user_input("del_user:> ")
		del_home = user_input("Delete /home/"+arg2+"? [Y/n] "+char(10)+"||: ",0,1)
		if del_home.lower == "n" then del_home = 0 else del_home = 1
		if arg2 == "" then return "usr: aborting..."
		return localmachine.delete_user(arg2, del_home)
	end if
	if arg1 == "-r" or arg1 == "-R" then 
		arg1 = 1
	end if
	if typeof(arg1) == "string" then // check owner of string: /file/path
		if not arg2 then
			check_u = globals.get_file(arg1)
			if typeof(check_u) == "file" then return check_u.owner 
		end if
	end if
	
	if arg1 == 1 then // recursive
		if not arg3 then return "usr: invalid arguments. please supply a path."
		t_f = globals.get_file(arg3)
		if t_f then return t_f.set_owner(arg2, 1) else return "usr: "+arg3+" not found."
	else // not recursive
		if not arg2 then return "usr: "+arg1+" not found <b>or</b> path not supplied."
		t_f = localmachine.File(arg2)
		if t_f then return t_f.set_owner(arg1, 0) else return "usr: "+arg2+" not found."
	end if
	return 0
end function
command.grp = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "-h" or arg1 == "help" then return "<u>GROUP || ADD GROUP || CHGRP</u>"+char(10)+"Usage: grp [optional: -r -- recursive] [new_group] [path] "+char(10)+"Usage: grp [add|del] [group] [user] -- add or remove group to|from user."+char(10)+"Usage: grp -u [user] -- returns groups associated with user"+char(10)+"Usage: grp -f [path] -- returns group associated with file at path"+char(10)+"-- Do not name group add or del for #reasons."+char(10)+"-- It is good practice to run:"+char(10)+"|><b> usr -r root / | grp -r root / | rm /etc/passwd | lock </b>"+char(10)+"for optimal security."
	is_recursive = false
	if arg1 == "-f" then 
		if not arg2 or arg2 == "" then return "Usage: grp -f [path]"
		f_t = globals.get_file(arg2)
		if not f_t then return "grp: "+arg2+" not found."
		return f_t.group
	end if 
	if arg1 == "-u" then 
		if not arg2 or arg2 == "" then return "Usage: grp -u [user]"
		return globals.localmachine.groups(arg2)
	end if 
	if arg1 == "add" then
		if not arg2 or not arg3 then return "Usage: grp add [group] [user]"
		return localmachine.create_group(arg3, arg2)
	end if
	if arg1 == "del" then
		if not arg2 or not arg3 then return "Usage: grp del [group] [user]"
		return localmachine.delete_group(arg3, arg2)
	end if
	if arg1 == "-r" or arg1 == "-R" then is_recursive = true
	if is_recursive then
		if not arg3 then return "grp: invalid arguments. Usage: grp -r [group] [path]."
		t_f = localmachine.File(arg3)
		if t_f then return t_f.set_group(arg2, 1) else return "grp: "+arg3+" not found."
	else
		if not arg2 then return "grp: invalid arguments. Usage: grp [group] [path]"
		t_f = localmachine.File(arg2)
		if t_f then return t_f.set_group(arg1, 0) else return "grp: "+arg2+" not found."
	end if
	return 0
end function
command.perms = function(arg1, arg2, arg3=0, arg4=0)
	if DEBUG then print("__debug: in perms")
	if (arg1 == "-h" or arg1 == "help") and arg2 == "extra" then return "Q: Perms lock all (aka the <b>lock</b> command): what does it do?"+char(10)+"A: the following:"+char(10)+"perms -R o-rwx /"+char(10)+"perms -R g-rwx /"+char(10)+"perms -R u-rwx /"+char(10)+"if on home computer, does the following to avoid lockout:"+char(10)+"perms g+x /bin/sudo"+char(10)+"perms g+x /bin/psudo"+char(10)+"perms g+x /bin/ssh"+char(10)+"perms g+x /usr/bin/Terminal.exe"+char(10)+"perms g+x /usr/bin/Chat.exe"+char(10)+"perms g+x /usr/bin/Mail.exe"+char(10)+"To bypass this and lock down anyway use:<b> perms lock down </b> (use with caution)"+char(10)+"n.b mail and chat are on this list because bugs happen when they are fully locked."
	perms_usage = "<u>CHMOD || PERMISSIONS || PERMS || SECURITY</u>"+char(10)+
		colorWhite+"Usage: perms [opt:-r] [userstring{+|-}permission] [path]"+char(10)+
		"-- opt: -r -- run recursively on all files and folders under [path]"+char(10)+
		"-- userstring -- o = other, g = group, u = user/owner"+char(10)+
		"-- toggle -- [+] = add permission, [-] = remove permission"+char(10)+
		"-- permission -- r = read, w = write, x = execute"+char(10)+
		"E.G:<b> perms -r o-rwx / </b> -- remove rwx permissions from 'others' for all files"+char(10)+
		"E.G:<b> perms -r g+x /bin</b> -- add group execute permissions to all files in /bin"+char(10)+char(10)+
		"<color=white>Aliases:"+char(10)+
		"Usage: perms lock all -- remove all permissions from all files (alias:<b> lock</b>)"+char(10)+
		"-- includes anti-brick technology: checks for home pc and relaxes certain permissions:"+char(10)+
		"---- checks for user_email_address: if found, determines we are at home"+char(10)+
		"---- if at home add g+x to: sudo, ssh, Terminal.exe, Chat.exe, Mail.exe"+char(10)+
		"Usage: perms lock down -- force locking down, bypassing anti-brick technology"+char(10)+		
		"Usage: perms unlock all -- add o+rwx to all files"+char(10)+
		"<b>Shortcut:</b> lock -- alias for <b>perms lock all</b>"+char(10)+
		"-- it is good practice to run:"+char(10)+
		"|><b> usr -r root / | grp -r root / | rm /etc/passwd | lock </b>"+char(10)+
		"--for optimal security."+char(10)+
		"-- you may type:<b> kore -s</b> to have this action performed for you"
		"Extra: perms [-h|help] extra -- view extra help information about this command."
	if arg1 == "-h" or arg1 == "help" or arg1 == 0 or arg2 == 0 then return perms_usage
	if arg1 == "unlock" then return command.perms("-R", "o+rwx", "/")
	if arg1 == "lock" then
		if not localmachine.File("/").has_permission("w") then return "perms: lockdown failed: permission denied"
		command.perms("-R", "o-rwx", "/")
		command.perms("-R", "g-rwx", "/")
		command.perms("-R", "u-rwx", "/")
		//home = user_mail_address//user_input("r u home? [y/N] "+char(10)+"||: ",0,1)
		home = null 
		
		processes = localmachine.show_procs.split(char(10))
		for p in processes
			if p == "USER PID CPU MEM COMMAND" then continue
			process = p.split(" ")
			process_ID = process[1]
			process_CMD = process[4]
			if process_CMD == "Xorg" then  home = true
		end for

		if home != null and arg2 != "down" then//home == "y" or home == "Y" then
			print(colorBlack+"<mark=red>Auto-detected: u r home</mark>"+CT+char(10)+"Rerun with:<b> perms lock down </b>to force lock all.")
			command.perms("g+x","/bin/sudo")
			command.perms("g+x","/bin/psudo")
			command.perms("g+x","/bin/ssh")
			command.perms("g+x","/usr/bin/Terminal.exe")
			command.perms("g+x","/usr/bin/Chat.exe")
			command.perms("g+x","/usr/bin/Mail.exe")
			print("<b>User permissions relaxed</b>...")
		end if
		if arg2 == "partial" then command.perms("-R","g+x", "/")
		return "perms: lockdown complete"+char(10)+"-- unless otherwise noted above"
	end if
	perms = arg1
	pathFile = arg2
	isRecursive = 0
	if arg1 == "-R" or arg1 == "-r" then
		perms = arg2
		if arg3 and typeof(arg3) == "string" or typeof(arg3) == "file" then pathFile = arg3 else return "perms: invalid path"
		isRecursive = 1
	end if
	if typeof(pathFile) == "string" then file = globals.get_file(pathFile)
	if typeof(pathFile) == "file" then file = pathFile 
	if not file then return("perms: can't find " + pathFile)
	output = file.chmod(perms, isRecursive)
	if output then print(output)
	return 0
end function
command.mkdir = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "/" or arg1 == 0 or arg1 == "-h" or arg1 == "help" then	return "Usage: mkdir [/path/new_folder] -- create a new folder in path. path must exist."
	if globals.get_file(arg1) then return "mkdir: "+arg1+" already exists."
	newpath = arg1.split("/")
	new_dir = ""
	if newpath[0] == "" then
		newpath.pull
		new_dir = "/"
	else
		new_dir = currentPath
		if new_dir != "/" then new_dir = new_dir + "/"
	end if
	new_name = newpath.pop
	new_dir = new_dir+newpath.join("/")
	if new_dir == "" then new_dir = "/"
	new_dir = globals.get_file(new_dir)
	if not new_dir then return "mkdir: unable to create "+arg1+": parent folder not found."
	print colorGold+"<b>mkdir: creating <b>"+new_name+" in:</b> "+new_dir.path
	return localmachine.create_folder( new_dir.path , new_name )
	return 0
end function
command.cat = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "Usage: cat [path_to_text_file|file_object] -- returns contents of text file or null if read denied."+char(10)+"Usage: cat [file_object] -- returns contents of piped file object"+char(10)+"e.g. clipc @B 3 | cat -- where BUFFER[3] contained a text file"
	file = null
	kittehns = ["=^._.^= S","^·-·^","^• •^","~(^._.)","(^._.^)s","(^..^)S","(^-.-^)","Z(=^.^=)"]
	kittehns.shuffle
	kitteh = kittehns.pop
	print "<u>"+colorGold+"- - - - - - - - - c a t - - - - - - - -"+char(10)+
			    colorGold+"                 "+kitteh+"              "
	if typeof(arg1) == "file" then
		file = arg1
	else
		if typeof(arg1) == "string" then
			if arg1 == "" or arg1 == " " then return "cat: file not found."
			file = globals.get_file(arg1)
			if not file then return ("cat: "+arg1+" not found")
		else
			return "cat: expected path or file_object, got "+arg1
		end if
	end if
	if file.is_binary then return ("Cannot open binary file: "+arg1)
	return file.get_content
end function
import_code("/root/src/dtools.5pk")
if DEBUG then 
	if command.hasIndex("grep") then print "debug: dtools loaded"
end if 
command.run = function(arg1, arg2, arg3=0, arg4=0, arg5=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "run [file|path_to_file] [opt:parameters|shell] [opt:shell|parameters -- launch a script binary at path (gui's not supported)"+char(10)+"-- piped file objects are launched from the objects path"+char(10)+"-- max 14 nested launches before stack call error."+char(10)+"-- providing a shell object will launch a binary using that shell object"+char(10)+"-- you must pipe launch params if more than one word"+char(10)+"-- use echo and easy clip for best results (@a,@b,@c)"+char(10)+"---- eg: echo do 1 -f pwn.bat | clipa | clipb @B 1 | run /home/guest/rkit/5hell @b @a"+char(10)+"---- eg: echo rshell 1.1.1.1 | clipa | brutus | run /root/rkit/5hell @a"+char(10)+"Note: run supports pshells with the launch function however p_objects are not currently in game"
	if typeof(arg1) != "string" then return "run: arg1 should be file object or path to file" 
	if arg2 and typeof(arg2) == "shell" then
		if arg3 and typeof(arg3) == "string" then parameters = arg3 else parameters = ""
		if typeof(arg1) == "string" then return arg2.launch(arg1, parameters)
		if typeof(arg1) == "file" then return arg2.launch(arg1.path, parameters)
		return "run: arg1 should be file or path to file"
	end if
	if arg3 and typeof(arg3) == "shell" then 
		run_path = null
		if typeof(arg1) == "string" then run_path = arg1
		if typeof(arg1) == "file" then run_path = arg1.path
		if typeof(run_path) != "string" then return "run: arg1 should be file object or path to file"
		if typeof(arg2) == "string" then parameters = arg2
		if typeof(arg2) == "file" then return "run: arg2 should be string (params) or shell object"
		return arg3.launch(run_path, parameters)
	end if
	file = globals.get_file(arg1)
	if not file then return "run: "+arg1+" not found."
	//globals.stack_pool = globals.stack_pool - 1
	parameters = ""
	if arg2 and typeof(arg2) == "string" then parameters = arg2
	if arg3 and typeof(arg3) == "string" then parameters = parameters + " " + arg3 
	if arg4 and typeof(arg4) == "string" then parameters = parameters + " " + arg4 
	if arg5 and typeof(arg5) == "string" then parameters = parameters + " " + arg5 
	if DEBUG then print("run: "+file.path+", "+parameters)
	return shell.launch(file.path, parameters)
end function
command.scribus = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Scribus Terminal Text Editor by Plu70"+char(10)+"scribus [path_to_file] -- open terminal text editor on file at path"+char(10)+"Advanced: scribus @clipa|@clipb|@clipc -- This edits the clipboard directly."+char(10)+"Advanced: scribus @cc -- edit the command buffer."+char(10)+"Advanced: scribus [file_object] -- text only, open contents of piped object."+char(10)+"Advanced: scribus @do -- edit the do buffer (to write / edit <b>do</b> scripts without launching them)"+char(10)+"-- see <b>do -h</b> for more info"+char(10)+"Note: you may press <b>@h</b> on a new line to get additional command info within the editor."
	p = arg1
	if not p then
		print(":> "+colorCyan+"/relative/path/to/file"+CT+" - open a text file in the editor")
		print(":><b> @clipa | @clipb | @clipc </b>- edit clipboards in the editor"+char(10)+":><b> @do </b>- edit do command buffer (without running do)"+char(10)+":> @cc edit command buffer"+char(10)+"press <return> to abort.")
	end if
	if p == 0 then p = user_input("Scribus:> ")
	if p == "" then return "aborting..."
	if p == "@cc" then
		print("Editing the command buffer...")
		globals.command_buffer = globals.scribus(globals.command_buffer).split(char(10))
		return 0
	end if
	if typeof(p) == "file" then return globals.scribus(p)
	if p == "@clipa" then return command.clipa(globals.scribus(globals.clip_board_alpha))
	if p == "@clipc" then return command.clipc(globals.scribus(globals.clip_board_gamma))
	if p == "@clipb" then return command.clipb(globals.scribus(globals.clip_board_beta))
	if p == "@do" then
		if not globals.clip_board_delta then globals.clip_board_delta = []
		globals.clip_board_delta = globals.scribus(globals.clip_board_delta)
		print("do: clipped: "+char(10)+colorBlack+"*"+CT+char(10)+globals.clip_board_delta)
		return globals.clip_board_delta
	end if
	if typeof(p) == "string" then
		f = localmachine.File(p)
		if not f then f = localmachine.File(currentPath+"/"+p)
		if not f then f = localmachine.File(currentPath+p)
		if not f then return "scribus: "+p+" not found. "
		//w = user_input(f.path+" found. Open it? [Y/n] ||:",0,1)
		//if w.lower == "n" then return "aborting..."
		return globals.scribus(f)
		//return 1
	end if
	return 0
end function
if DEBUG then print("<size=75%>loading battleship.5pk...(24.905kb)</size>")
if DEBUG then print("<size=75%>loading blackjack.5pk...(14.256kb)</size>)")
command.games = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "games: battleship and blackjack !"
	print("[0] Battleship")
	print("[1] Battleship - AI vs AI")
	print("[2] Blackjack  - jokers wild")
	print("[3] Drugawars")
	print("[4] Back")
	bat = function(s)
		import_code("/root/src/battleship.5pk")
		return 0
	end function
	g2 = function()
		import_code("/root/src/blackjack.5pk")
	end function
	g3 = function()
		import_code("/root/src/drugwars.5pk")
	end function
	pick = user_input("||: ",0,1)
	//if pick > 2 then return
	if pick == "0" then return bat("")
	if pick == "1" then return bat("-s")
	if pick == "2" then return g2
	if pick == "3" then return g3
	return 0
end function
command.mail = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return colorGreen+"<u></color>"+colorGold+"Mail || metaMail || herme5 || hermes || mail client"+char(10)+
	"herme5 mail client: its the mail (wip) -- its good enough but you may want to write your own;"+char(10)+
	"-- name your function<b> command.mail </b> to overwrite this one."+char(10)+
	"-- see 5hell.src, template.5pk.src for instructions."+char(10)+
	"Note: You may overwrite any command this way."+char(10)+char(10)+
	colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - - -"+char(10)+
	"Usage: mail -- opens the herme5 mail menu"+char(10)+
	"Extra: when prompted for a password you may enter:</b> -brutus"+char(10)+
	"-- this will invoke <b>brutus</b> and attempt to crack the email password."+char(10)+
	"-- the password will be saved to the custom object as:"+char(10)+
	"-- key == password and value == public_ip:local_ip"+char(10)+
	"---- this will change once i work out a better storage system bc this is not ideal"+char(10)+
	"Extra: when viewing your inbox you may type <b>spool</b> to dump all mail to a file (up to 160kb)"
        herme5 = function()
            mail = {}
            mail.meta = null  // metaMail object
            if globals.inbox then mail.meta = globals.inbox
            mail.data = null
            if globals.inbox then mail.data = mail.meta.fetch
            mail.user = null
            if globals.inbox then mail.user = globals.mail_user
            mail.pass = null
            if globals.inbox then mail.pass = true
          
            mail.pwn = function(arg)
              dsize = globals.dict_a.len
              mode = user_input("[<b>0</b>] Onboard Dictionary -- [1] /root/tables/tp ")
              if mode == "0" or mode == "" then
                reverse_it = user_input("[0] start at dict_a[0]  --  [1] start at dict_a[-1] "+char(10)+"(type anything else to abort) ||:",0,1 )
                if reverse_it == "1" or reverse_it == "0" then
                  reverse_it = reverse_it.to_int
                else
                  return 0
                end if
                show_count = user_input("Show the count? ["+dsize+"] [y/N] ||: ",0,1)
                show_pass = user_input("Show passwords? [y/N] ||: ",0,1)
                if show_pass.lower == "y" then show_pass = true else show_pass = false
                if show_count.lower == "y" then show_count = true else show_count = false
                print(colorGold+"Accessing onboard dictionary..."+CT+char(10)+"<align=center><<>></align>")
                ds = dsize - 1
                for p in range( 0, ds )
                  dsize = dsize - 1
                  if reverse_it then pa = globals.dict_a[0 - p] else pa = globals.dict_a[p]
                  if show_count then print(colorGold+colorWhite+"["+CT+dsize+colorWhite+"]"+CT+CT)
                  if show_pass then print(colorGold+colorWhite+"["+CT+pa+colorWhite+"]"+CT+CT)
                  try = mail_login(arg, pa)
                  if typeof(try) == "MetaMail" then
                    print("brutus: <b>password found</b>: "+colorWhite+pa+CT)
					print command.cob("set",pa,arg)
                    return try
                  end if
                end for
              else
                if mode == "1" then
                  tp = localmachine.File("/root/tables/tp")
                  if not tp then return 0
                  print(colorGold+"Accessing /root/tables/tp..."+CT+char(10)+"<align=center><<>></align>")
                  tp_f = tp.get_files
                  i=0
                  for f in tp_f
                    i = i + 1
                    print(i+"/"+(tp_f.len))
                    chunc = f.get_content.split(char(10))
                    for p in chunc
                      try = mail_login( arg, p )
                      if typeof(try) == "MetaMail" then
                        print("brutus: <b>password found</b>: "+colorWhite+p+CT)
						print("brutus: accessing cob: saving password as key, email as value")
						print command.cob( "set", p, arg)
                        return try
                      end if
                    end for
                  end for
                end if
              end if
              return 0
            end function
          
            mail.Login = function()
              if globals.inbox then
                mail.meta = globals.inbox
                return mail.user+" is already logged in."
              end if
              mail.user = user_input("email:> ")
              if mail.user == "" or mail.user == " " then mail.user = user_mail_address
              if not mail.user then return "Invalid mail address."
              print("Enter <b>-brutus</b> to crack password with brutus.")
              mail.pass = user_input(mail.user+" pass:> ", 1)
              if mail.pass == "" or mail.pass == " " then return "Invalid login credentials."
              if mail.pass == "-brutus" then
                mail.meta = mail.pwn(mail.user)
              else
                mail.meta = mail_login(mail.user, mail.pass)
              end if
          
              if typeof(mail.meta) == "MetaMail" then
                globals.inbox = mail.meta
                globals.mail_user = mail.user
                return "Login complete."
              end if
              return "Invalid login credentials."
            end function
            mail.get_id = function(arg)
              ds = mail.data[arg].split(char(10))
              //print(ds)
              i = ds[2].split(" ")
              i = i[1]
              return i
            end function
            mail.Fetch = function()
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              mail.data = mail.meta.fetch
              return "Fetching mail for: "+mail.user+"..."+char(10)
            end function
            mail.Read = function()
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              print(mail.Fetch)
              print(mail.data_stream(mail.data))
              r = user_input("Enter an index to read or type <b>spool</b> to dump to a file :> ").to_int
              print(colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - "+CT)
			  if mail.data.len < 1 then return "herme5: mailbox is empty"
			  spool_buf = []
			  spooling = false
			  if r == "spool" then 
				spooling = true
			  	r = mail.data.len - 1
			  end if
			  while r >= 0
				if r >= 0 and r < mail.data.len then
					read_this = mail.meta.read(mail.get_id(r))
					if spooling then print "<size=80%>herme5: spooling: ["+colorWhite+r+CT+"]" else print(read_this)
					//if spooling then spool_buf.push(mail.data[(r)]+char(10)+read_this+char(10))
					if spooling then spool_buf.push(read_this+char(10))
					if read_this.split(char(10))[2] == "Subject: *" then
						print(colorLightBlue+"<u><mark=#DF8600>= = = = = = = = = = = = = = = = = = = = = = = = = = = = =</mark></u>"+CT)
						print(command.code("-b", read_this[read_this.indexOf("Subject: *")+11:]))
					end if
				end if
				if spooling then r = r - 1 else r = -1
			  end while
			  if spooling then 
			  	st = time
			  	spool_file_path = user_input( colorGold+"herme5: please enter a path for the spool file: "+char(10)+"[/path, <<b>enter</b>=home_dir/spool.txt, </b>q</b>=quit]:> " )
				if spool_file_path.lower == "q" or spool_file_path.lower == "quit" then return "aborting..."
				if spool_file_path == "" or spool_file_path == " " then spool_file_path = homePath+"/spool.txt"
				spool_file = globals.get_file(spool_file_path)
				if typeof(spool_file) != "file" then print "herme5: could not locate spool file."+char(10)+"herme5: creating: "+spool_file_path else print "herme5: spool file found; overwriting"
				if typeof(spool_file) == "file" and spool_file.is_binary then return "herme5: cannot spool to binary file"
				print colorWhite+"<size=80%>Saving data to spool file: <b>"+spool_file_path
				if DEBUG then print "debug: spool_buf is: "+spool_buf+" and is a "+typeof(spool_buf)
				spool_file = command.poke("-f",spool_file_path, current_date+char(10)+char(10)+spool_buf.join(char(10))+char(10)+current_date)
				if typeof(spool_file) != "file" then return "herme5: error: check write permissions"
				globals.BUFFER.push(spool_file)
				wait(.1) 
				ttt = time - st
				print colorGold+"herme5: "+CT+"spool_file object sent to "+colorOrange+"BUFFER"+CT+char(10)+colorGold+"</b>herme5: task completed in <b>"+ttt+"</b> seconds."
			  end if
              return "returning..."
            end function
            mail.Write = function()
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              addr = user_input("address:> ")
              subj = user_input("subj:> ")
              mbuf = []
              send = ""
              body = globals.scribus(mbuf)
              munin = user_input(colorLightBlue+"Encode with <mark=black>M</mark>unin<mark=black>C</mark>ipher before sending? [Y/n] ||: "+CT,0,1)
              if munin.lower != "n" then
                send = command.code("-a",body)
                subj = "*"
              else
                send = body
                print(colorGreen+"<u>= = = = = = = = = = = = = = = = = = = = = = = = = = = = =</u>"+CT)
              end if
              return mail.meta.send( addr, subj, send )
            end function
            mail.Delete = function(r=0)
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              print(mail.Fetch)
              print(mail.data_stream(mail.data))
              if not r then r = user_input("delete [*=all,<enter>=quit]:> ").to_int
			  if r and r == "*" then
				for m in range(0,mail.data.len - 1)
					mail.meta.delete( mail.get_id(m) )
			  	end for 
				print colorOrange+"All emails deleted!"
				return mail.Fetch
			  end if
              if typeof(r) == "number" and mail.data.hasIndex(r) then
                id = mail.get_id(r)
                if id then print("Deleting (crt+c to cancel): "+id+"...")
                wait(.5)
                print("in 3...")
                wait(1)
                print("2...")
                wait(1)
                print(mail.meta.delete( id ))
                return mail.Fetch
              else
                return "aborting..."
              end if
              return 0
            end function
            mail.Widget = function()
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              if HERMES == true then
                globals.HERMES = false
                wState = "off"
              else
                globals.HERMES = true
                wState = "on"
                globals.this_mail = user_input("Configuring widget..."+char(10)+"pin_mail_# (default: 0 for newest):> ").to_int
                mail.data = mail.meta.fetch
                if typeof(globals.this_mail) == "number" and globals.this_mail >= 0 and globals.this_mail < mail.data.len then
                  print(colorGold+"Pinned: "+colorWhite+globals.this_mail+colorGold+"."+CT+char(10)+colorGold+"Herme5 mail widget configured."+CT)
                else
                  print(colorGold+"Defaulting to: "+colorWhite+"0"+colorGold+"."+CT+char(10)+colorGold+"Herme5 mail widget configured."+CT)
                  globals.this_mail = 0
                end if
              end if
              return "Herme5 mail widget toggled "+wState+"."
            end function
            mail.Exit = function()
              return "herme5: exiting..."
            end function
            mail.data_stream = function(alist)
              d = ""
              i = 0
              for el in alist
                d = d + "[" +colorWhite+ i +CT+ "] " + el + char(10)
                i = i + 1
              end for
              return d
            end function
            mail.menu = function()
              mailing = true
              menu_options = ["Exit", "Login", "Fetch", "Read", "Write", "Widget", "Delete"]
              while mailing
                print(colorGold+"- - - - - - - Herme5 v 0.4.4 by Plu70 - - - - - - - - "+CT)
                print(mail.data_stream(menu_options))
                opt = user_input("(q=quit)||: ",0,1).to_int
                print(colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - "+CT)
                if opt == "q" then return 0
                if opt < 0 or opt > menu_options.len-1 or typeof(opt) != "number" then continue
                mm = @mail[menu_options[opt]]
                print(mm)
                mailing = opt
              end while
              return mailing
            end function
            return mail.menu
          end function
          // end Herme5
          //herme5          
	return herme5
end function
command.malp = function(arg1, arg2, arg3=0, arg4=0)
	if @arg1 == "-h" or @arg1 == "help" then return "malp: Memory Alpha - buffer, object and database management menu. "+char(10)+"Usage: malp -- Access all<b> BUFFER </b>objects from here."+char(10)+"Advanced: malp [piped_object] -- adds ANY piped object to the BUFFER."+char(10)+"-- May be of any type: string, list, map, shell, file, computer, et al."
	if DEBUG then print("@arg1: "+typeof(@arg1))
	if @arg1 then
		if typeof(@arg1) == "function" then
			if DEBUG then print("function detected...")
			globals.BUFFER.push(@arg1)
		else
			globals.BUFFER.push(arg1)
		end if
	else
		if arg1 then globals.BUFFER.push(arg1)
	end if
	if DEBUG then print("starting malp...")
	globals.memory_alpha
	return 0
end function
command.fwr = function(arg1, arg2, arg3=0, arg4=0) // requires metaxploit.so
	if GLASSPOOL then print(colorOrange+"fwr: ignores glasspool."+CT)
	if arg1 == "help" or arg1 == "-h" then return "Usage: fwr [ip] -- returns firewall rules for ip. returns local rules if no ip given."
	if not localmachine.is_network_active then return "fwr: no network connection"
	router = get_router
	if typeof(router) != "router" then return "fwr: router not found"
	if arg1 and is_valid_ip(arg1) then
		router = get_router(arg1) 
		if DEBUG then print "debug: router is a: "+typeof(router)
		if typeof(router) != "router" then return "fwr: router not found"
	end if
	if DEBUG then print "debug: router is a: "+typeof(router)
	return router.firewall_rules
end function
import_code("/root/src/kore.5pk")
if DEBUG then 
	if command.hasIndex("kore") then print "debug: kore loaded"
end if 
command.memdump = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "memdump: dump MEMORY, XPLOITS, PORT_MAP, clipboards,  to current_path+/memdump.mx"+char(10)+"n.b. ignores glasspool. main purpose is generating reports for clients."
	return globals.dump_memory
end function
command.enum = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "<b><u>enumeration || ENUM || enum buffer"+char(10)+
	"Use this to put things in a list."+char(10)+
	"Usage: enum [opt|/path|file_object|array|#]"+char(10)+
	"Usage: enum [list|string] -- enumerates a list or a newline separated string"+char(10)+
	"-- if the string is a single word it will be interpreted as a path"+char(10)+
	"-- multiple words on a single line (piped) will be interpreted as a single entry"+char(10)+
	"Usage: enum [path|file_object]"+char(10)+
	"-- enumerate file contents as a list of strings"+char(10)+
	"-- useful for 5hell scripting (see the '<b>do</b>' command)."+char(10)+
	"-- e.g: enum file.txt | enum 1"+char(10)+
	"---- enumerate file.txt then return index [1] from the list"+char(10)+
	"Usage: enum -l  -- return the length of enum buffer."+char(10)+
	"Usage: enum -s  -- show the enum buffer and return the length"+char(10)+
	"Usage: enum -d  -- enumerate the onboard dictionary (depricated)"+char(10)+
	"Usage: enum [#] -- return the element at index # in the enum buffer"+char(10)+
	"Usage: enum -i [index] [element] -- insert element at index "+char(10)+
	"Usage: enum -e -- return the enum buffer as a list"+char(10)+
	"-- shifts everything below it down"+char(10)+
	"Usage: enum -a [element] -- append element to end of enum buffer"+char(10)+
	"-- unlike enum [string] you may use enum -a [string] to append a single word to the enum buffer"
	"Usage: enum -b  -- concatonate the BUFFER and globals.enumerated (the enum buffer)"
	"Usage: enum -p -- purge the enum buffer"+char(10)+
	"Advanced: poke files.txt | lock |  | ls | append files.txt | cat files.txt | clipb | enum"+char(10)+
	"-- Or: ls | enum -- pipe ls output to the enum buffer"+char(10)+
	"Advanced: lanpro | enum -- scan network and enumerate all LAN addresses found. "+char(10)+
	"Advanced: enum -e -- return the enumerated buffer as a list object."+char(10)+
	"Note: map support is coming soon(tm)"
	if arg1 == null then return 0
	if arg1 == "-b" then 
		if globals.enumerated.len < 1 then return "enum: enumerated buffer is empty"
		print "enum: <b>appending enumerated buffer to main BUFFER</b>"
		globals.BUFFER = globals.BUFFER + globals.enumerated
		return 0
	end if 
	if arg1 == "-p" then 
		globals.enumerated = []
		return "enum: "+colorOrange+" enum buffer purged"
	end if
	if not arg1 or arg1 == "0" then
		if globals.enumerated.len then return globals.enumerated[0] else return 0
	end if
	if arg1 == "-i" then 
		if not arg3 then return "enum: -i [index] [element]"
		buf_bak = globals.enumerated
		if typeof(arg2) != "string" then return "enum: -i expects string index"
		if typeof(arg3) != "string" and typeof(arg3) != "list" then return "enum: -i [index] [string|list]"
		dx = arg2.to_int
		sbb = null 
		if typeof(arg3) == "list" then sbb = arg3 
		if typeof(arg3) == "string" then sbb = arg3.split(char(10))
		if typeof(dx) != "number" or dx >= buf_bak.len or dx < 0 then return "enum: invalid index"
		sli_1 = buf_bak[0:dx]
		sli2 = buf_bak[dx:]
		new_buf = sli_1 + sbb + sli_2
		return "enum: element inserted at index "+dx
	end if
	if arg1 == "-a" then 
		if not arg2 then return "enum: append failed: missing input"
		sb = ""
		if typeof(arg2) == "list" then sb = arg2
		if typeof(arg2) == "string" then sb = arg2.split(char(10))
		if sb == "" then return "enum: append failed: invalid type: expects string or list"
		globals.enumerated = globals.enumerated + sb
		return "enum: list appended"
	end if
	if arg1 == "-d" then
		globals.enumerated = globals.dict_a[0:]
		print("enum: <b>onboard dictionary enumerated</b>. Num entries:")
		return globals.enumerated.len
	end if
	if arg1 == "-l" then return str(globals.enumerated.len)
	if arg1 == "-s" then
		if not globals.enumerated.len then return 0
		ie = 0
		for ge in globals.enumerated
			print("["+ie+"] " + ge)
			ie = ie + 1
		end for
		return globals.enumerated.len
	end if
	if arg1 == "-e" then
		return globals.enumerated
	end if
	if typeof(arg1) == "list" then 
		globals.enumerated = arg1
		return "enum: list enumerated"
	end if
	if typeof(arg1) == "map" then
	globals.enumerated = []
		for a in arg1
			globals.enumerated.push(a)
		end for
		return "enum: map <b>enumerated.</b>"
	end if
	if typeof(arg1) == "number" then arg1 = str(arg1)
	if typeof(arg1) == "string" and typeof(arg1.to_int) == "number" then
	 	if globals.enumerated.hasIndex(arg1.to_int) then return globals.enumerated[arg1.to_int] else return "enum: error: invalid index"
	end if
	if typeof(arg1) == "string" then
		if arg1.split(char(10)).len > 1 or arg1.split(" ") > 1 then // more than one line or more than one word, otherwise it's a path
			globals.enumerated = arg1.split(char(10))
			for el in globals.enumerated
				if el == "" then
					globals.enumerated.remove(globals.enumerated.indexOf(el))
					continue
				end if
				globals.enumerated[globals.enumerated.indexOf(el)] = el.replace(char(32),"").trim
			end for
			return "enum: entry <b>enumerated.</b>"
		end if
		file = null
		file = globals.get_file(arg1)
		if not file then return "enum: error: "+arg1+" not found."
		arg1 = file
	end if
	if typeof(arg1) == "file" then
		print("enum: purging...")
		globals.enumerated = []
		if arg1.is_binary then return "enum: can't open binary file" else stuff_buf = arg1.get_content
		if stuff_buf then globals.enumerated = stuff_buf.split(char(10)) else return "enum: error: file empty or read protected."
		return "enum: "+arg1+" <b>enumerated.</b>"
	end if
	return "enum: error: unknown type"
end function
command.rclean = function(arg1, arg2=0, arg3=0, arg4=0)
	if DEBUG then print("in rclean: got: "+typeof(@arg1))
	if arg1 == "help" or arg1 == "-h" then return "Remote Clean || log scrubber || system.log cleaner"+char(10)+
	"Copy a file over the system.log to corrupt it"+char(10)+
	"Usage: rclean [opt: int ] -- select an object from buffer to atttempt a remote log wipe."+char(10)+
	"Usage: rclean [file|shell|computer] -- remote wipe piped object"+char(10)+
	"-- e.g. clipb @B 1 | rclean -- where BUFFER[1] was a file|shell|computer"+char(10)+
	"-- rclean with no params will display a menu "+char(10)+
	"-- rclean is intended for remote scrubbing using BUFFER objects."+char(10)+
	"-- However you may use silentclean or rclean for local log scrubbing"+char(10)+
	"-- if rclean detects a file named <b>silentclean</b> it will use that file to scrub the log"+char(10)+
	"-- for this reason it is a good idea to include an empty file named silentclean in the rkit"+char(10)+
	"Usage: rclean -d [#|shell|file|computer] -- run rclean as above and delete rkit and/or 5hell, if present"+char(10)+
	"Usage: rclean -n [#|shell|file|computer] -- run rclean as above and delete the contents of /boot, if present"
	if arg1 and arg1 == "-d" then 
		arg1 = arg2
		arg2 = "-d"
	end if 
	if arg1 and arg1 == "-n" then 
		arg1 = arg2 
		arg2 = "-n"
	end if

	if arg1 and (typeof(arg1) == "shell" or typeof(arg1) == "ftpshell" or typeof(arg1) == "computer" or typeof(arg1) == "file") then return globals.rclean(arg1,arg2)
	if arg1 and typeof(arg1.to_int) == "number" then return globals.rclean(command.clipb("@B",arg1),arg2)
	return globals.rclean(command.clipb("@B","-m"),arg2)
end function
command.ipfit = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: ipfit -- menu to specify a way to generate ips. (wip)"+char(10)+"Recommendation: pipe the output to a file or to the clipboard."+char(10)+"e.g<b> ipfit | clipb </b>, or<b> ipfit | poke iplist </b>"
	print("Configuring: ")
	print("<b>How do you want to specify ip's? </b>"+char(10)+"[0] - enter manually"+char(10)+"[1] - read from file "+char(10)+"[2] - random")
	print("[3] - specify range"+char(10)+"[4] - from clipb")
	choice = user_input("||: ",0,1).to_int
	ips = []
	if choice == 0 then
		ips = globals.scribus(ips)
		return ips
	end if
	if choice == 1 then
		ips = command.cat(user_input("path_to_file:> "))
		return ips
	end if
	if choice == 2 then
		ips = command.rnip(user_input("# ips to create: "))
		return ips
	end if
	if choice == 3 then
		print("Soon (tm)")
		return "Soon (tm)"
	end if
	if choice == 4 then
		return command.clipb
	end if
	return 0
end function
command.rnip = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == "help" or arg1 == "-h" then return "Usage: rnip [iter] [optional: delimiter] -- produce [iter] random ip addressses and"+char(10)+"return as a string with optional [delimiter] (default newline)"+char(10)+"e.g. rnip 100 ,  -- returns a string of 100 ips seperated by a comma"
	loop = 1
	delimiter = char(10)
	if arg1 then loop = arg1.to_int
	if arg2 then delimiter = arg2
	rng = range(1,223)
	rnd = range(0,223)
	rand_ip = []
	if loop < 1 then return "rnip: iteration must be a positive integer."
	for i in range(1,loop)
		rng.shuffle
		rnd.shuffle
		sub = rnd[0]
		rnd.shuffle
		ito = rnd[0]
		rnd.shuffle
		rand_ip.push([rng[0], rnd[0], ito, sub].join("."))
	end for
	return rand_ip.join(delimiter)
end function
command.porter = function(arg1, arg2, arg3=0, arg4=0)
	if not arg2 or arg1 == "help" or arg1 == "-h" then return "Usage: porter [port] [comma,or,newline,separated,ip,list] --  print lib version of service on port, if any, for given ip address(es)"
	if not localmachine.is_network_active then return "nsl: no network connection."
	r_buf = []
	ip = arg2
	if ip.split(char(10)).len > 1 then
		ip = ip.split(char(10))
		ip = ip.join(",")
	end if
	array = false
	if ip.indexOf(",") >= 0 then
		ip = ip.split(",")
		array = true
	else
		i = ip
		ip = [i]
	end if
	a_size = 1
	if array then a_size = ip.len
	port = 0
	if arg1 then port = arg1.to_int else port = 0
	time_s = time
	print(colorLightBlue+"- - - - - - - - - - - - - - - - - - - - -"+CT)
	print(colorLightBlue+"<align=center><b>(>|<)</b></align>"+CT)
	for r in range(1, a_size)
		i = ip[r-1]
		if not localmachine.is_network_active then return "porter: no network connection found."
		rtr = get_router(i)
		if typeof(rtr) != "router" then continue
		if port then
			pinfo = null
			png = rtr.ping_port(port)
			if png then pinfo = rtr.port_info(png)
			if pinfo then r_buf.push(i+" "+port+": "+pinfo)
		else
			pinfo = rtr.kernel_version
			if pinfo then r_buf.push(i+" router: "+pinfo)
		end if
	end for
	if r_buf == [] then r_buf.push("Porter: No_results_found.")
	print(colorLightBlue+"Porter: task complete in "+colorOrange+(time - time_s)+colorLightBlue+" seconds."+CT)
	save = "y"//user_input("Send results to clipb? [y/N] "+char(10)+"||: ",0,1)
	if save.lower == "y" then command.clipb(r_buf.join(char(10)))
	return colorLightBlue+"Porter: clipped"+CT+char(10)+format_columns(r_buf.join(char(10)))+char(10)+colorLightBlue+" - - - - - - - - - - - - - - - - - - - - "+CT
end function
command.code = function(arg1, arg2, arg3=0, arg4=0)
	if DEBUG then print("input type: "+typeof(@arg1))
	if typeof(@arg1) == "function" then
		print("Function() detected...")
		return globals.decompiler(@arg1)
	end if
	if @arg1 == null or @arg1 == "-h" or @arg1 == "help" then return "<u>character code || cipher || encryption || || decryption || decompiler"+char(10)+
	"<b>CODE</b> encode and decode utility"+char(10)+
	"Supports standard Caesar cipher and 5hell's MuninCipher for encryption."+char(10)+
	"May also return ascii character codes, decompile objects, and execute functions."+char(10)+
	"Usage: code [char] -- returns ascii code for char"+char(10)+
	"Usage: code -c [int] -- returns ascii char(int)"+char(10)+
	"Usage: code [any_function|any_object] -- sends object to decompiler to view object map."+char(10)+
	"-- will evaluate piped functions."+char(10)+
	"Advanced: code [-d|-e] [word] -- decode|encode a word using standard caesar cypher"+char(10)+
	"Advanced: code [-a|-b] [opt:input] -- encode|decode using <b>MuninCipher(tm)</b>"+char(10)+
	"-- prompts for input if not supplied"+char(10)+
	"-- enter text to encrypt|decrypt on a single line up to 40,000 chars"+char(10)+
	"-- if input is more than one word use without params for prompt"+char(10)+
	"-- or use piping or an input file (see -f options)"+char(10)+
	"Advanced: code [-f|-fa|-fb] [/file/path|file_object] -- encode|decode contents of file"+char(10)+
	"-- option [-f] [path] -- prompts for enc/dec"+char(10)+
	"-- option [-fa|-af] [path] -- encode contents of path with MuninCipher"+char(10)+
	"-- option [-fb|-bf] [path] -- decode contents of path with MuninCipher"+char(10)+
	"<b>N.B.</b> MuninCipher is tamper resistant! Attempting to copy/paste the cipher text can/will corrupt it!"
	Encode = function(instruction, password)
    caesar = function(type, pass)
				if pass == "" then return char(32)
        nr = pass.len%9
				if nr == 0 then nr = 25
        crypt = function(char, nr, type)
            if type == "enc" then return char+nr
            if type == "dec" then return char-nr
        end function
        out = []
        for i in range(0, pass.len-1)
            c = pass[i].code
            if c >= 48 and c <= 57 then
                c = crypt(c, nr, type)
                if c < 48 then c = c+10
                if c > 57 then c = c-10
            else if c >= 65 and c <= 90 then
                c = crypt(c, nr, type)
                if c < 65 then c = c+26
                if c > 90 then c = c-26
            else if c >= 97 and c <= 122 then
                c = crypt(c, nr, type)
                if c < 97 then c = c+26
                if c > 122 then c = c-26
            end if
            out.push(char(c))
        end for
        return out.join("")
    end function
    output = caesar(instruction, password)  // instruction should be either "enc" for encode or "dec" for decode
    return output
	end function
	if @arg1 == 0 then return str(char(32).code)
	if @arg1 == "0" then return str("0".code)
	if @arg1 == "-a" or @arg1 == "-b" then
		enc_line = arg2
		if arg2 and typeof(arg2) != "string" then return "code: -a|-b expects string input, got"+typeof(arg2)
		if not arg2 then enc_line = user_input("MuninCipher:> ")
		if enc_line.len > 40000 and @arg1 == "-a" then return "MC: max 40k characters for encode"
		cipher_input = []
		cipher_output = []
		enc_dec = "enc"
		if @arg1 == "-b" then enc_dec = "dec"
		cipher_this = ""
		if enc_dec == "enc" then
			cipher_input = enc_line.split(char(32))
		else
			cipher_input.push(arg2)
		end if
		print(colorLightBlue+"<mark=black>M</mark>unin<mark=black>C</mark>iphering: "+cipher_input.join(" "))
		/////////////////////////////////////
		if enc_dec == "dec" then
			//input_split = Encode("enc", cipher_input[0])
			input_split = cipher_input[0].split(char(40001))
			//if input_split.len <= 1 then return "code: invalid format for MC decode"
			ci_sli_dex = cipher_input[0].split(char(40001))[1]
			ci_sli_txt = cipher_input[0].split(char(40001))[0]
			cipher_size = ci_sli_dex.values
			cipher_size = cipher_size.pop
			cipher_size = cipher_size.code
			ci_sli_txt = ci_sli_txt.values
			spaces = []
			last_space = 0
			for dex in ci_sli_dex
				spaces.push(dex.code+last_space+1)
				last_space = spaces[-1]
			end for
			buf = []
			//print("debug:<b>indexed</b>"+char(10)+"debug:spacing")
			spaces.pop
			for ci in range(0, cipher_size)
				//print("debug: ci = "+ci)
				if spaces.len and spaces[0] == ci+1 then
					buf.push(char(32))
					spaces.pull
				else
					if ci_sli_txt.len then buf.push(ci_sli_txt.pull)
				end if
			end for
			buf = buf.join("")
			//print(buf)
			cipher_input = buf.split(char(32))
		end if

		//////////////////////////////////////
		for password in cipher_input
		  cipher_this = password
		  for l in range(0,cipher_this.len)
		    //print(cipher_this)
		    cipher_this = Encode( enc_dec, cipher_this )
		  end for
		  cipher_output.push(cipher_this)
		end for
		//print("debug: output: "+cipher_output)
		//////////////////////////////////////
		if enc_dec == "enc" then
			spacedex = ""
			for co in cipher_output
				spacedex = spacedex + char(co.len)
			end for
			leng = cipher_output.join(" ").len
			cipher_output.push(char(40001))
			cipher_output.push(spacedex)
			cipher_output.push(char(leng))
			cipher_output.push(char(40001))
			cipher_output = cipher_output.join("")

			//cipher_output = Encode("dec", cipher_output)
		end if
		/////////////////////////////////////
		print(colorLightBlue+"<u><mark=black>= = = = = = = = = = = = = = = = = = = = = = = = = = = = =</mark></u>"+CT)
		if enc_dec == "dec" then return cipher_output.join(" ")
		return cipher_output
	end if
	if @arg1 == "-c" and arg2 then return char(arg2.to_int)
	if @arg1 == "-d" then
		if not arg2 then return "nothing to decode"
		return Encode("dec", arg2)
	end if
	if @arg1 == "-e" then
		if not arg2 then return "nothing to encode"
		return Encode("enc", arg2)
	end if
	if @arg1 == "-f" or @arg1 == "-fa" or @arg1 == "-af" or @arg1 == "-bf" or @arg1 == "-fb" then
		act = 0
		if @arg1 == "-f" then act = (-1)
		if @arg1 == "-fa" or @arg1 == "-af" then act = 1
		cipher_file = null
		cipher_text = ""
		if not arg2 then return "code: -f expects a file_path or file_object"
		if typeof(arg2) == "file" then
			if not arg2.is_binary then cipher_file = arg2 else return "code: cannot open binary file"
			if cipher_file.has_permission("r") then cipher_text = cipher_file.get_content.trim else return "code: read error. check permissions"
		end if
		if typeof(arg2) == "string" then
			cipher_text = command.cat(arg2)
		end if
		if act < 0 then act = user_input("[0] decode [<b>1</b>] encode ||: ",0,1).to_int
		if act == 0 then act = "-b" else act = "-a"
		return command.code(act, cipher_text)
	end if
	if DEBUG then print("Checking types...")
	buf = []
	if typeof(@arg1) == "string" then
		print("<mark=yellow><size=75%>Processing string...</mark></size>")
		if arg1 == "\n" then return str(char(10).code)
		if arg1 == 0 or arg1 == " " then return str(" ".code)
		arg1 = arg1.values
		for letter in arg1
			buf.push(letter.code)
		end for
		if DEBUG then print "debug: code: string buf: "+buf
		return buf.join(", ")
	end if
	//if typeof(@@arg1) == "function" then return globals.decompiler(@@arg1)
	if typeof(@arg1) == "shell" or typeof(@arg1) == "ftpshell" or typeof(@arg1) == "file" or typeof(@arg1) == "computer" or typeof(@arg1) == "map" or typeof(@arg1) == "custom_object" or typeof(@arg1) == "list" then return globals.decompiler(@arg1)
	if typeof(@arg1) == "pshell" or typeof(@arg1) == "pcomputer" or typeof(@arg1) == "pfile" or typeof(@arg1) == "prouter" then return globals.decompiler(@arg1)
	if @arg1.hasIndex("__isa") then return globals.decompiler(@arg1)
	//if typeof(@arg1) == "list" or "map" then return globals.decompiler(@arg1)	
	check = new @arg1 
	if typeof(@check) == "map" then return globals.decompiler(@arg1)
	return "code: unkown type"
end function
command.md5 = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "MD5SUM || md5 sum || password hash decipher || encode"+char(10)+"Usage: md5 [string] -- returns the md5sum of a string"+char(10)+"Usage: md5 -d [32_char_hash] -- checks hash against onboard dictionary then attempts decipher"+char(10)+"-- defaults to crypto.so if cerebrum is not loaded"+char(10)+"-- one of three main ways to decipher password hash combo's"+char(10)+"-- see also: <b>gopher</b>, <b>hashim</b>, <b>brutus</b>"
	if arg1 == "-d" then
		if not arg2 or typeof(arg2) != "string" or arg2.len != 32 then
			return "[-d] expects 32 character hash string"
		else
			for d in dict_a
				if md5(d) == arg2 then
					print("md5: found: "+colorWhite+d+CT+":"+arg2)
					return d
				end if
			end for
			if crypto then
				rslt = crypto.decipher(arg2)
				if rslt then return rslt
			end if
			return "md5: hash not found"
		end if
	end if
	if typeof(arg1) == "string" then return md5(arg1) else return "md5: string required"
end function
command.pipe = function(arg1, arg2, arg3=0, arg4=0)
	return "pipe usage: place | between sets of commands to pipe output of command on left of | to command on right."+char(10)+"Max string size is 1 million characters."+char(10)+"Examples: "+char(10)+"lanpro | enum"+char(10)+"ls -la /root | clipb | enum | poke file.txt | lock |  | clipb | append file.txt"+char(10)+"chain commands and use two empty spaces between the | to <b>drop</b> piped output while continuing the chain."+char(10)+"-- eg: command1 |  | command2 -- output from command1 is NOT passed to command 2"+char(10)+"-- remember: it is two spaces between the bars."
end function
command.do = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then
		if arg2 == "extra" then
			return "<u><mark=red>=============</u></mark>"+char(10)+
			"Setup (copy after the |> and paste into 5hell): "+char(10)+
			"|> clipa 0 | rnip 11 | enum | enum -s | do"+char(10)+
			"Paste this Script : "+char(10)+
			"clipa | enum | probe"+char(10)+
			"calc @a + 1 | clipa"+char(10)+
			"Result:"+char(10)+
			"set clipa to 0, produce 11 random ips, enumerate those ips, do 11 loops of: probe enum[clipa], clipa++"+char(10)+
			"-- this runs probe on 11 random ips stored in the enum(eration) buffer using calc and the clipboard to iterate through the list."+char(10)+
			"<u><mark=red>=============</u></mark>"+char(10)+
			"Setup (copy after the |> and paste into 5hell)"+char(10)+
			"|> clipa 1 | ls -a /lib | enum | enum -s | do"+char(10)+
			"Paste this Script : "+char(10)+
			"clipa | enum | db -l"+char(10)+
			"calc @a + 1 | clipa"+char(10)+
			"Result:"+char(10)+
			"set clipa to 1, enumerate files in /lib, do [num_files+1] loops, start at 1 and run db (databaser) on each file, the error at the end is because ls returns with an extra blank line which gets enumerated at position [0] resulting in the loop being 1 over."+char(10)+
			"<u><mark=red>=============</u></mark>"+char(10)+
			"(all commands are valid but note interactive commands will still require interaction)"
		else
			return colorGold+"<u>DO || SCRIPTING || AUTOMATION || NOT BASH || BATCH COMMANDS"+char(10)+
			colorWhite+"</b>The scheduling or automation service for 5hell. You write a set of"+char(10)+
			colorWhite+"</b>commands for 5hell to <b>do</b>. Commands may be entered in-line on the"+char(10)+
			colorWhite+"</b>command line, entered into a text editor buffer, or read from a text file."+char(10)+
			colorWhite+"</b>see also: do help extra -- for some example do scripts"+char(10)+
			colorGold+"</b>-- see also: <b>help prompt</b>, <b>dig -h</b>, <b>scribus -h</b>"+char(10)+
			colorWhite+"</b>Do may be launched in a number of ways, depending on your goals:"+char(10)+char(10)+
			colorCyan+"Usage: do [int] [command] [arg1] [arg2]-- perform [command] [int] times"+char(10)+
			colorLightBlue+"</b>-- passes arg1 and arg2 to the command"+char(10)+
			colorLightBlue+"</b>-- use text blocks to pass complex arguments and/or complex commands"+char(10)+
			colorGold+"</b>-- eg: |><b> do 3 "" rnip 1 | probe | db -r | zap "" "+char(10)+
			colorGold+"</b>-- eg: |><b> do 1 poke test.txt "" this is a bunch of text "" "+char(10)+
			colorLightBlue+"</b>---- note: in practice the above line can be done without the <b>do 1</b>"+char(10)+
			colorLightBlue+"</b>---- it's just an example of how you would supply complex parameters to <b>do</b>"+char(10)+
			colorLightBlue+"- - - - - - - - - - - "+char(10)+
			colorCyan+"Usage: do -- without arguments will prompt for iterations then open the editor"+char(10)+
			colorCyan+"Usage: do [#] -- supplying iteration without a command opens the editor immediately"+char(10)+
			colorLightBlue+"</b>-- enter commands into the editor and enter @ on a newline to begin execution"+char(10)+
			colorLightBlue+"</b>-- the commands in the editor remain until changed and therefore may be rerun/reused"+char(10)+
			colorLightBlue+"</b>-- you may use <b>scribus @do</b> to edit the <b>do</b> buffer without firing the script"+char(10)+char(10)+
			colorCyan+"Usage: do [int] -f [/path] -- perform commands in [/path] [int] times"+char(10)+
			colorLightBlue+"</b>-- the preferred method of firing a 'batch' of commands"+char(10)+
			colorLightBlue+"</b>-- many examples may use a .bat extension but the .bat extension is not enforced at all"+char(10)+
			colorLightBlue+"</b>-- it is just a convention, you may name them whatever you wish except:"+char(10)+
			colorLightBlue+"</b>---- dig.bat must be named dig.bat in order for <b>dig</b> to use it (see dig -h)"+char(10)+
			colorGold+"</b>-- nested calls to the do command within these files are valid and encouraged"+char(10)+
			colorGold+"</b>---- dig.bat: cerebrum | brutus | run /home/guest/rkit/5hell "" do 1 -f file2.bat | exit done "" "+char(10)+
			colorGold+"</b>---- file2.bat: rshell @home | sc -d | exit rshell_placed"+char(10)+
			colorLightBlue+"</b>-- by placing these two files in your rkit folder and running <b>dig [ip]</b> you are able to:"+char(10)+
			colorLightBlue+"</b>---- automate: infiltrating and placing a root rshell on the target"+char(10)+
			colorLightBlue+"</b>----- removing your rkit"+char(10)+
			colorLightBlue+"</b>----- and cleaning the log"+char(10)+
			colorCyan+"Alias: "+colorWhite+"do 1 -f [path]"+CT+" has been aliased to"+colorWhite+" bat [path]"+CT+" in 5hell.src"+char(10)+char(10)+
			colorCyan+"You may launch 5hell from the game's command line with a 'do' instruction:"+char(10)+
			colorLightBlue+"</b>-- instead of launching 5hell simply by typing '5hell' you may launch with:"+char(10)+
			colorGold+"</b>----# 5hell do [#] [opt:-f] [command|path]"+char(10)+
			colorLightBlue+"</b>-- and 5hell will launch and immediately begin running the given commands"+char(10)+
			colorLightBlue+"</b>-- 5hell will then drop to the exit prompt;"+char(10)+
			colorLightBlue+"</b>---- press 'y' if you wish to exit, press enter or any other key to continue running"+char(10)+
			colorGold+"This allows 5hell to launch 5hell with instructions to launch 5hell with instructions to..."+char(10)+
			colorLightBlue+"</b>-- keep in mind there is a game limit of 15 <u>nested</u> uses of shell.launch"+char(10)+
			colorLightBlue+"</b>-- but no limit to the number of uses of shell.launch; meaning <b>do 1000 dig -s</b> is completely valid"
		end if
	end if
	iter = 0
	cmd = []
	if arg1 then
		if typeof(arg1) == "number" then iter = arg1 else iter = arg1.to_int
	else
		iter = user_input("Number of iterations to run command:"+char(10)+":> ").to_int
	end if
	if not iter or typeof(iter) != "number" then return "do: invalid iteration."
	if arg2 and arg2 != "" then
		if arg2 == "-f" then
			cmd.push(arg2)
		else
			if arg3 then arg2 = arg2 + " " + arg3
			if arg4 then arg2 = arg2 + " " + arg4
			cmd.push(arg2)
		end if
	else
		print("Configure command list: ")
		print("* piped commands go on a single line separated by | ")
		print("* non-piped commands go on a new line ")
		print("* @ on newline to save and execute")
		print("* @@ on newline to abort and quit")
		cmd_hold = command.scribus("@do")
		if cmd_hold then cmd = cmd_hold.split(char(10)) else return "aborting..."
		//print(cmd.join(char(10)))
	end if
	if cmd[0] == "-f" then
		if arg3 then
			cf = globals.get_file(arg3)
			if not cf then return "do: file: "+arg3+" not found"
			if cf.is_binary then return "do: cannot open binary file"
			if not cf.has_permission("r") then return "do: can't read "+arg3+": permission denied"
			cmd = cf.get_content.split(char(10))
		else
			return "do: input error: -f expects a file path."
		end if
	end if
	time_s = time
	if DEBUG then print(cmd)
	if cmd.len then
		for i in range(1,iter)
			print(colorBlack+"*"+CT)
			for c in cmd
				c = c + " | return"
				command.shell(c)
			end for
		end for
	else
		return "<b>aborting...</b>"
	end if
	return colorCyan+"--batch complete in ["+colorOrange+(time-time_s)+colorCyan+"] seconds--"+CT
end function
command.cc = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return ": carbon copy: command buffer."+char(10)+"Usage: cc -- select command from history."+char(10)+"Usage: cc [#] -- where # corresponds to the command you wish to run from the command buffer."+char(10)+"-- will <b>return</b> the output of the commands as if they were run normally."+char(10)+"-- you may use cc inside of pipe chains."+char(10)+"---- e.g: cc 22 | echo | cc 10 | poke file.txt"
	i = 0
	schtick = "| return"
	if not arg1 then 
		for ccom in globals.command_buffer
			print("["+colorWhite+i+CT+"] "+char(187)+" "+ccom)
			i = i + 1
		end for
	end if
	do = null
	if arg1 then do = arg1.to_int
	if not do then do = user_input("cc:> ",0,0).to_int
	if typeof(do) == "number" and do >= 0 and do < globals.command_buffer.len then
		carbon = globals.command_buffer[do]
		carbon = carbon +" "+ schtick
		//carbon = carbon.split(" ")
		return command.shell( carbon )
	else
		return "cc: invalid index"	
	end if
	return 0
end function
command.time = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: time -- returns current game time."+char(10)+"Usage: time [-d|date] -- returns current game time and date."+char(10)+"Usage: time [-t] -- returns time in seconds since script launch."
	if arg1 == "-t" then return time
	if arg1 == "-d" or arg1 == "date" then return current_date
	return current_date.split(" ")[2]
end function
command.pause = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "0" or arg1 == "help" or arg1 == "-h" then return "Pause || Wait || Hang || Sleep"+char(10)+
	// note, this function expects time as a string, the user should form the string as a float. eg: pause .01 -- where .01 is a string
	"Usage: pause [seconds(float)] -- pauses script execution"+char(10)+
	"-- Minumum time: .01 seconds"+char(10)+
	"-- Maximum time: 300 seconds"+char(10)+
	"-- useful for putting a delay in 'do' scripts."+char(10)+
	"-- useful for putting a delay in a chain of commands"+char(10)+
	"-- this command uses the general function: wait(time)"
	time_to_wait = "1" // default wait 1 second 
	manual_unpause = false // if false the chain of commands continues after the pause, if true then press a key to continue
	if arg1 == "-m" then 
		manual_unpause = true 
		arg1 = ".01"
	end if
	if DEBUG then print "debug: in pause: arg 1 is: "+arg1+" and manual pause is: "+manual_unpause
	if typeof(arg1.val) == "number" then time_to_wait = arg1.val else return "pause: invalid interval: expects positive float [.01 : 300]"+char(10)+"n.b. - negative values will not reverse time"
	if manual_unpause then return user_input(colorWhite+"pause</b>: script execution paused"+char(10)+"-- press <"+colorGreen+"enter"+CT+"> to continue --")
	if time_to_wait <= 300 and time_to_wait >= .01 then
		if DEBUG then print "debug: ttw is"+time_to_wait
	else
		time_to_wait = 1
		print "pause: invalid wait time: changing time_to_wait to 1 second"
	end if
	print colorWhite+"<u>pause</b>: script execution paused for <b>"+time_to_wait+"</b> seconds..."
	wait(time_to_wait)
	return colorWhite+"pause:"+CT+" resuming script execution"
	//return 0
end function
command.bios = function(arg1=0, arg2=0, arg3=0, arg4=0)
if arg1 == "help" or arg1 == "-h" then return "OBJECT | MEMORY | BIOS | CERBIOS"+char(10)+
"Usage: bios -- system info"+char(10)+
"Advanced:copy the following to 5hell's command line:"+char(10)+
"<b>mkdir /virt | poke /virt/hdd.io dev_sda:SIZE </b>"+char(10)+
"-- replace SIZE with the maximum size of your hdd in bytes. "+char(10)+
"-- this lets bios report the remaining hdd space"+char(10)+
"Usage: bios -a -- return the currently loaded <color=#FFD000>aptclientlib object"+char(10)+
"Usage: bios -m -- return the currently linked <color=#13E6CA>metaLib object"+char(10)+
"Usage: bios -x -- return the currently loaded <color=#FF0800>metaxploitLib object"+char(10)+
"Usage: bios -c -- return the currently loaded <color=#8C00FF>crypto object"+char(10)+
"Usage: bios -n -- return the currently linked <color=#0011FF>netsession object"+char(10)+
"Usage: bios -p -- return the currently loaded <color=#69E488>port_map object as a string"+char(10)+
"Usage: bios -H -- return the currently linked <color=#E4EE58>herme5 meta.mail object"+char(10)+
"-- returns null if not logged in to a mail account"+char(10)+
"Usage: bios -s -- return the currently loaded <color=#8B8568>meta_scan information</color> as a string"+char(10)+
"Usage: bios -P -- return the currently loaded <color=#00FF40>port_map object as a map"+char(10)+
"Usage: bios -X -- return the currently loaded <color=#065F0D>XPLOITS as a list"+char(10)+
"Usage: bios -M -- return the current <color=#FF00C8>MEMORY object or null"+char(10)+
"Usage: bios -B -- return the global <color=#E68A13>BUFFER as a list"+char(10)+
"Usage: bios -r [opt: ip] -- return the <b>local<b> <color=#71858D>router object</color> [opt:ip]"+char(10)+
"Usage: bios -i [path] -- runs <b>include_lib</b> on path and returns result"+char(10)+
"-- init.so, net.so, kernel_module.so cannot be imported as they lack an API"+char(10)+
"-- prompts for path if path not supplied"+char(10)+
"---- e.g.|> bios -i /lib/blockchain.so | malp "+char(10)+
"---- returns the blockchainLib object and pipes it to malp (to the BUFFER)"+char(10)+
"---- note: cannot include_lib net.so, init.so, kernel_module.so"+char(10)+
"------ only libs with API's may use include_lib"+char(10)+
"------ use meta link to load those with the metaxploitLib"
if arg1 == "-a" then return globals.apt_get 
if arg1 == "-x" then return globals.metaxploit 
if arg1 == "-c" then return globals.crypto 
if arg1 == "-n" then return globals.net_session
if arg1 == "-p" then return globals.display_portmap(1)
if arg1 == "-P" then return globals.PORT_MAP
if arg1 == "-H" then return globals.inbox
if arg1 == "-m" then return globals.metaLib
if arg1 == "-s" then return globals.meta_scan
if arg1 == "-X" then return globals.XPLOITS 
if arg1 == "-M" then return globals.MEMORY
if arg1 == "-B" then return globals.BUFFER
if arg1 == "-r" then 
	if arg2 then
		if is_valid_ip(arg2) then return get_router(arg2)
		return "bios: get_router: invalid ip"
	else 
		return get_router
	end if
end if
if arg1 == "-i" then 
	if not arg2 then 
		arg2 = user_input("Enter path to file.so :> ")
	end if
	return include_lib(arg2)
end if

bios_info = []
bios_info.push("<mark=red><u>=======================================================================</u></mark>")
bios_info.push("<u><mark=red>=</mark><color=red>__(WIP)________________cer_bios_v_0.5_by_Plu70________________(WIP)__</color><mark=red>=</mark></u>")
bios_info.push("* "+current_date+" "+globals.localmachine.local_ip+" @ "+globals.localmachine.public_ip+" up: "+time)
procs = globals.localmachine.show_procs.split(char(10))
//print(procs)
root_procs = 0
user_procs = 0
guest_procs = 0
mem_used = 0
cpu_used = 0
for p in procs
	spl = p.split(" ")
	pro_usr = spl[0]
	pro_idn = spl[1]
	pro_cpu = spl[2].remove("%")
	pro_mem = spl[3].remove("%")
	pro_nam = spl[4]
	if pro_cpu != "CPU" then cpu_used = cpu_used + pro_cpu.val
	if pro_mem != "MEM" then mem_used = mem_used + pro_mem.val
	if pro_usr == "root" then
		root_procs = root_procs + 1
	else
		if pro_usr == "guest" then
			guest_procs = guest_procs + 1
		else
			if pro_usr != "USER" then user_procs = user_procs + 1
		end if
	end if
end for
root = localmachine.File("/")
hdd_io = localmachine.File("/virt/hdd.io")
h_size = "<color=red>dev_sda error</color>"
if hdd_io then
	h_c = hdd_io.get_content.split(char(10))
	h_s = h_c[0].split(":")
	h_n = 0
	if h_s.len > 1 then h_n = h_s[1].to_int
	if h_n then h_size = h_n - root.size.to_int else h_size = "<color=red>dev_sda error</color>"
end if
if globals.stack_pool <= 0 then stack_print = "depleted; restart required" else stack_print = globals.stack_pool
bios_info.push("<mark=red><size=85%>|</size></mark>")
bios_info.push("<size=85%>Macula Registry: [stack_pool:"+colorRed+stack_print+CT+"] </size>")
bios_info.push("<size=85%>root_procs [<b>"+root_procs+"</b>] user_procs [<b>"+user_procs+"</b>]  guest_procs [<b>"+guest_procs+"</b>] t:<b> "+(procs.len-1)+"</b></size>")
bios_info.push("<size=85%>cpu_usage: ["+cpu_used+"%] mem_usage: ["+mem_used+"%] temp: <color=red>therm_io not found</color></size>")
bios_info.push("<size=85%>[cpu:<mark=green>|"+"|"*(cpu_used/4)+"</mark>"+"_"*((100-cpu_used)/4)+"]   [ram:<mark=green>"+"|"*(mem_used/4+1)+"</mark>"+"_"*((100-mem_used)/4)+"]</size>")
bios_info.push("<size=85%>[hdd_used: <b>"+root.size+" </b>bytes]  [hdd_free: "+h_size+" bytes]</size>")
bios_info.push("<size=85%>num_folders [ ] num_binaries [ ] num_ascii [ ] t: ##</size>")

if localmachine.active_net_card == "WIFI" then
	sig = floor(rnd*99)+1
	sig = sig - 0
	sig_not = 100 - sig
	bios_info.push("<size=85%>[wifi_signal:<mark=green>|"+"|"*(sig/2)+"</mark>"+"_"*(sig_not/2)+"]</size>")
end if
dl = localmachine.network_devices.split(char(10))
bios_info.push("<size=85%>["+dl.join("] [")+localmachine.active_net_card+"]")
ports = localmachine.get_ports
pl = []
for p in ports
	pl.push(p.port_number)
end for
bios_info.push("<size=85%>ports: ["+pl.join("] [")+"] </size>")
bios_info.push("<mark=red><size=50%>|</size></mark>")
database = command.tree("/","database.csv",1,"N")
data_lines = "--"
data_size = "-not_found-"
if database then
	data_size = command.file("-c",database)
	if database.has_permission("r") then data_lines = command.file("-l",database) else data_lines = "-check_perms-"
	if data_size.to_int > "75000".to_int then data_size = colorOrange+"Warning: "+data_size+CT
end if
bios_info.push("<size=85%>[database_size:"+data_size+"]  [database_lines:"+data_lines+"]</size>")
bios_info.push("<size=85%>[BUFFER: "+globals.BUFFER.len+" objects]</size>" )
bios_info.push("<size=85%>[tagged4scp: "+globals.tagged_for_scp+"]</size>")
bios_info.push("[tbuf:<size=60%>"+globals.T_BUF.join(" ")+"</size>]</size>")
//bios_info.push("[clipa:<size=60%>"+@globals.clip_board_alpha+"</size>]"+char(10)+"[clipb:<size=60%>"+@globals.clip_board_beta+"</size>]"+char(10)+"[clipc:<size=60%>"+@globals.clip_board_gamma+"</size>]"+char(10)+"[enum:<size=60%>"+globals.enumerated.len+"</size>]")
if typeof(@globals.clip_board_alpha) == "string" then
	bios_info.push("[clipa:<size=60%>"+@globals.clip_board_alpha.replace(char(10),", ")+"</size>]")
else
	bios_info.push("[clipa:<size=60%>"+@globals.clip_board_alpha+"</size>]")
end if
if typeof(@globals.clip_board_beta) == "string" then
	bios_info.push("[clipb:<size=60%>"+@globals.clip_board_beta.replace(char(10),", ")+"</size>]")
else
	bios_info.push("[clipb:<size=60%>"+@globals.clip_board_beta+"</size>]")
end if
if typeof(@globals.clip_board_gamma) == "string" then
	bios_info.push("[clipc:<size=60%>"+@globals.clip_board_gamma.replace(char(10),", ")+"</size>]")
else
	bios_info.push("[clipc:<size=60%>"+@globals.clip_board_gamma+"</size>]")
end if
bios_info.push("<size=85%>[portmap:"+globals.PORT_MAP.len+"] [xploits: "+globals.NUM_SPLOITS+"] [metascan: ]</size>")
bios_info.push("<size=85%>[dict_a:"+colorGold+globals.dict_a.len+CT+"]  [dict_size: "+dict_a.join(", ").len+"]</size>")
bios_info.push("<mark=red><size=50%>|</size></mark>")
pwf = command.tree("/etc","passwd",1,"N")
if pwf then pwf = pwf.permissions else pwf = "--null--"
bff = command.tree("/","Bank.txt",1,"N")
if bff then bff = bff.parent.path else bff = "--null--"
mtf = command.tree("/","Mail.txt",1,"N")
if mtf then mtf = mtf.parent.path else mtf = "--null--"
mcf = command.tree("/","Map.conf",1,"N")
if mcf then mcf = mcf.parent.path else mcf = "--null--"
bcf = command.tree("/","Browser.txt",1,"N")
if bcf then bcf = bcf.parent.path else bcf = "--null--"
clf = command.tree("/","ConfigLan.conf",1,"N")
if clf then clf = clf.parent.path else clf = "--null--"
bios_info.push("<size=85%>Security Audit Score: ##</size>")
bios_info.push("<size=60%>[unsecured_files:  ]  [unsecured_directories:  ]</size>")
bios_info.push("<size=60%>[/etc/passwd:"+pwf+"] [Mail.txt:"+mtf+"] [Bank.txt:"+bff+"]</size>")
bios_info.push("<size=60%>[Map.conf:"+mcf+"] [Browser.txt:"+bcf+"] [ConfigLan.conf:"+clf+"]</size>")
bios_info.push("<size=60%>[services:                   ]</size>")
bios_info.push("<mark=red><size=50%>|</size></mark>")
log = localmachine.File("/var/system.log")
log_size = 0
log_is_binary = 0
log_permissions = "-log-missing-"
if log then
	log_size = log.size
	log_is_binary = log.is_binary
	log_permissions = log.permissions
end if
bios_info.push("<size=85%>[/var/system.log: "+log_size+" bytes || is_binary: "+log_is_binary+" || perms: "+log_permissions+" ]")
bios_info.push("<mark=red><size=50%>|</size></mark>")
bios_info.push("*<size=50%> (obvious stub needs obvious improvement)</size>")
bios_info.push("*<size=50%> see <b>bios -h</b> for additional usage info.")
bios_info.push("<mark=red><u>=======================================================================</u></mark>")

return bios_info.join(char(10))
end function
command.credits = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "credits"
	logo = []
	logo.push("  |-----\ "+CT+colorGreen+"   |      |   /--------   |          |         ")
	logo.push("  |     | "+CT+colorGreen+"   |      |   |           |          |         ")
	logo.push("  |       "+CT+colorGreen+"   |      |   |           |          |         ")
	logo.push("  |____   "+CT+colorGreen+"   | _____|   |--------   |          |         ")
	logo.push("       |  "+CT+colorGreen+"   |      |   |           |          |         ")
	logo.push("       |  "+CT+colorGreen+"   |      |   |           |          |         ")
	logo.push(" |     |  "+CT+colorGreen+"   |      |   |           |          |         ")
	logo.push(" \ ____|  "+CT+colorGreen+"   |      |   \--------    \_______   \_______ "+char(8482))
	for l in logo
		print(colorRed+l+CT)
	end for
	print("by Plu70 aka jhook, aka ra'al")
	print("special thanks to: KuRouZu")
	print("MuninCipher by:"+colorWhite+" Plu70, CypherRaven"+CT)
	print("CheckUser function by: "+colorWhite+"Corvus"+CT)
	print("Blackjack card art by: "+colorWhite+"3nigma"+CT)
	print("Pwgen by : "+colorWhite+" UsesPython, additions by Plu70 "+CT)
	print("beta testing by: "+colorWhite+"CypherRaven, Deckard, KotyKD, Silent, Wulf, Amanda, Sabranan ")
	print("Inspiration from: "+char(10)+colorWhite+"AweTux, Kirin, Rasputin, CypherRaven, 3nigma, Lady, KotyKD, Corvus, Amanda, Silent, Deckard, Minidevil96, MrMember, Clover, Trashed, Bit, OmegaKawaii, Omega, Redit0, Eclipse00, Jessa, Nyx "+char(10)+"and many others!")
	return 0
end function
command.quit = function(state=1, arg2=0, arg3=0, arg4=0) // NOT reboot command, rather ends script
	if state == "help" or state == "-h" then return "<u>QUIT || EXIT || RETURN</u>"+char(10)+"Usage: quit [opt:state] -- exits the program."+char(10)+"-- if no optional state then prompts before exit"+char(10)+"-- if state supplied then skips confirmation and exits with state"+char(10)+"Usage:<b> exit [opt:state]</b> -- also exits the program with optional state"+char(10)+"Usage: return -- used to return from glasspool. Will exit 5hell if glasspool is inactive."
	if not state then 
		if user_input("Exit "+colorRed+"5hell"+char(8482)+CT+"? [y/N]"+char(10)+":> ").lower != "y" then return "aborting shutdown..."
	end if
	exit(state)
end function
command.help = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "helping..."
	if arg1 == "shell" then return (colorRed+instance.name+CT+" v "+ver+" by Plu70"+char(10)+"(type<b> shell </b> for more info.)")
	if arg1 == "guide" then
		print(colorGold+"<u>= = = = = = = = = = = = = =</u>"+CT)
		print("Quick start guide: (5hell command line: |> )")
		print(colorGold+"probe [ip]"+CT+" -- perform a whois and portscan on target ip. Sets target IP in 5phinx/sphinx.")
		print(colorGold+"sphinx"+CT+" -- bring up pentest tool with target already set."+char(10)+"-- Press [0] to view portmap, [4] to change target ip, [5] to set target port.")
		print("Use arrow keys to access other 5phinx menus.")
		print("in sphinx "+colorGold+"press [=]"+CT+" -- connect metalib and get net_session (or load local lib)")
		print("in sphinx "+colorGold+"press [3]"+CT+" -- if target lib is unknown (scan/add to dbase)")
		print("in sphinx "+colorGold+"press [a] or [2]"+CT+" -- single attack or attack with all. results are stored in the BUFFER.")
		print("access "+colorGold+"malp"+CT+" -- memory alpha, (left arrow from sphinx or malp from |> )")
		print("in malp "+colorGold+"press [5]"+CT+" for BUFFER objects.")
		print("the BUFFER in <b>malp</b> is where you will interact with most objects.")
		print("use "+colorGold+" scpm "+CT+"command from |> or select a shell in BUFFER and press [7] scp to upload rkit ")
		print("do this<u> before </u>activating glasspool for best results.")
		print("use "+colorGold+"felix"+CT+" -- file explorer to send files/folders to BUFFER")
		print("all other commands are utility. explore them!")
		print(colorGold+"glasspool is shell/computer mirroring. some commands may change when this is active. "+CT+char(10)+"N.B. when active you are on the other side of the mirror looking back.")
		print(colorGold+"*--*"+CT)
		print("<b>/root/rkit</b> is the default location of the rootkit which should consist of:"+char(10)+"<b>   5hell, crypto.so, metaxploit.so, database.csv </b>"+char(10)+"Additionally it may contain: "+char(10)+"   dig.bat, ScanLan.exe, and other tools/libs you find useful.")
		print("In most cases you may type<b> kore -r</b> to have the rkit built for you."+char(10)+"kore will look for 5hell in /bin, and meta and crypto in /lib."+char(10)+"Add these files manually if kore is unable to do so.")
		print("For scripting see:<b> do -h</b>"+char(10)+"For dictionary attacks see:<b> cerebrum -h, brutus -h, gopher -h, hashim -h</b>")
		print("For networking see:<b> air -h, iwlist -h, ifconfig -h, ssh -h, kraken -h</b>")
		print("For security see:<b> perms -h, usr -h, grp -h, sniff -h, silentclean -h, bios -h")
		print("For dev tools see:<b> scribus -h, makfit -h, clipb -h, make -h, chop -h, dfit -h </b>")
		print(colorGold+"*--*"+CT)
		return 0
	end if

	help_conventions = "<b>CONVENTIONS</b>"+char(10)+"While a great deal of 5hell is discordant, there are some conventions:"+char(10)+char(10)+
	"You may toggle the full prompt and minimal promt by typing: "+char(10)+
	"<b>prompt</b> at the command line"+char(10)+
	"- - - - - - - - - - "+char(10)+
	colorWhite+"Input: arguments and quote blocks and piping oh my!"+char(10)+
	"-- 5hell uses a 4 argument system. This means all commands take at most 4 arguments"+char(10)+
	"-- this might sound limiting but it isn't at all in practice. Each of the 4 arguments may be overloaded."+char(10)+
	"Some input methods are:"+char(10)+
	colorLightBlue+"----* simply typing input: |> ping 1.1.1.1"+char(10)+
	"------ up to four typed arguments"+char(10)+
	"------ remember that |> is the prompt, you don't type that part"+char(10)+
	colorLightBlue+"----* using single quotes to wrap text: |> echo "" this is a text block "" "+char(10)+
	"------ would return: this is a text block"+char(10)+
	"------ note that: |> echo ""this is a text block"" "+char(10)+
	"------ would return: """"this is a text "+char(10)+
	"------ this allows you to overload each argument with more than one ""word"""+char(10)+
	"------ easy clip and piping and objects(mostly) are preserved inside of text blocks"+char(10)+
	colorLightBlue+"----* use <color=yellow>do</b></color> to run a batch of commands from a file or from memory using an editor"+char(10)+
	"------ |> do -- without arguments do will prompt for number of iterations then open the editor"+char(10)+
	"------ |> do 1 -- would bring up an editor commands typed here will be executed in order"+char(10)+
	"------ |> do 1 ping 1.1.1.1 -- would result in pinging 1.1.1.1 once"+char(10)+
	"------ |> do 5 "" rnip 1 | dig "" -- would run dig on a random ip 5 times"+char(10)+
	"------ |> do 1 -f /foo.bar -- execute the batch of commands in the file foo.bar"+char(10)+
	"-------- you may launch 5hell from the game's command line with <b>do</b> parameters"+char(10)+
	"-------- the format is the same as if typing commands on the command line"+char(10)+
	"-------- newlines in the script are considered to be new command line entries"+char(10)+
	"-------- you may use piping, easy clip, and even calls for <b>do</b> to execute further scripts"+char(10)+
	"-------- you may use text blocks for complex commands in place of files or the editor if you wish"+char(10)+
	"---------- |> do 3 "" rnip 1 | dig |  | cob get metx | meta -i | db -m | zap "" | poke test.txt "" this is a bunch of text going into a file """+char(10)+
	colorGold+"****** it is possible to almost completely automate every aspect of 5hell via <u>do</u> and <u>dig</u>"+char(10)+
	"------ for ease of use <b><color=white>do 1 -f</b></color> has been aliased to <color=white><b>bat</b></color> in 5hell.src:"+char(10)+
	"-------- |> <b>bat /foo.bar</b> is equivalent to |> <b>do 1 -f foo.bar</b>"+char(10)+
	"------ please see <u><b><color=yellow>do -h</b> and <b>dig -h</b></u></color> for more information on automation"+char(10)+
	colorLightBlue+"----* piping input: |> grep -f ^syst | file -p | cp /etc/passwd"+char(10)+
	"------ would result in copying /etc/passwd over top of system.log (if permissions allowed it)"+char(10)+
	"------ piping allows you to transfer the output of one command to the [last open parameter] of another command"+char(10)+
	"------ in the above example the output of grep [args...] is the input of file -p [input]"+char(10)+
	"------ and the output of file -p [args] is the input of cp /etc/passwd [input]"+char(10)+
	"------ please see <b>pipe -h</b> for more"+char(10)+
	"------ if malp is the backbone of 5hell, pipes are the circulatory system of 5hell"+char(10)+char(10)+
	colorWhite+"Prompts: "+CT+"|> , :> , ||: "+char(10)+
	"<color=#FFFFFF>|>  --  this is the standard Command Line Interface prompt"+char(10)+
	"-- by default there will be information printed before this"+char(10)+
	"-- toggle to a minimalist prompt with: <b>prompt</b>"+char(10)+
	"-- fires CLI commands"+char(10)+
	colorLightBlue+"|> "+CT+"  --  by default, the GLASSPOOL prompt turns the |> blue"+char(10)+
	"-- this means commands execute on the remote object controlled by glasspool"+char(10)+
	"-- see glaspool -h for more"+char(10)+
	colorWhite+":>  "+CT+" --  this is a liminal prompt, it expects a string or empty return"+char(10)+
	"-- this is used to gather user input within a command"+char(10)+
	colorWhite+"||: "+CT+" --  this is an 'any key' prompt"+char(10)+
	"-- it takes a single keypress"+char(10)+
	"-- this is used in 'button' driven menus"+char(10)+char(10)+
	colorWhite+"Decision Pompts: "+CT+"[ N/Y/X ] [n/y/x]"+char(10)+
	"-- Multiple choice prompts have a default"+char(10)+
	"-- the default is always Capitolized and sometimes highlighted"+char(10)+
	"-- the default is chosen if <enter> is pressed without input"+char(10)+
	"-- unless otherwise noted, default is chosen if input doesn't match a choice"+char(10)+
	"E.G: |> psudo"+char(10)+
	"Open shell? [c/y/N]"+char(10)+
	"||:"+char(10)+
	"-- in this example, the choices are [c], [y], and [N]"+char(10)+
	"---- [c] -- enter credentials"+char(10)+
	"---- [y] -- open shell"+char(10)+
	"---- [n] or anything else -- no; return/abort"+char(10)+
	"------ this is because N is the default"+char(10)+char(10)+
	colorWhite+"Prompt: advanced:"+char(10)+
	"-- by default the prompt will display the public and local ip of the active shell"+char(10)+
	"---- or computer if using glasspool on a computer object"+char(10)+
	"-- by default the prompt will display computer name and working directory"+char(10)+
	"-- by default the prompt indicates user privileges (root,user,guest) with:"+char(10)+
	"---- under the ip information there will be a:"+char(10)+
	"------ a<color=red> red line for root</color>, <color=green>green line for user </color>, </color>and <color=white>white line for guest"+char(10)+
	"---- please note that user permissions are determined by access level and not by 'actual' user"+char(10)+
	"-- you may customize the prompt to your liking in 5hell.src"+char(10)

	help_tools = "<u><b>Main tools:"+char(10)+
	colorCyan+"probe "+colorWhite+"-- whois and portmap a target"+char(10)+
	colorCyan+"db "+colorWhite+"-- scan target and <b>database results</b>"+char(10)+
	colorCyan+"meta "+colorWhite+"-- metaLib and metaxploitLib fine control"+char(10)+
	colorCyan+"zap "+colorWhite+"-- select and fire exploits one at a time (does not database)"+char(10)+
	colorCyan+"roil "+colorWhite+"-- fire all exploits at once (does not database)"+char(10)+
	colorCyan+"malp "+colorWhite+"-- Memory Alpha: BUFFER management"+char(10)+
	"-- exploit results and other objects go here"+char(10)+
	"-- this is arguably the backbone of 5hell"+char(10)+
	colorCyan+"scpm "+colorWhite+"-- menu and/or cli driven scp"+char(10)+
	colorCyan+"kraken "+colorWhite+"-- proxy management"+char(10)+
	colorCyan+"scribus "+colorWhite+"-- simple text editor"+char(10)+
	colorCyan+"cerebrum "+colorWhite+"-- add 325k+ passwords to custom_object.dictionary"+char(10)+
	colorCyan+"brutus "+colorWhite+"-- use custom_object.dictionary to get root on any (unmodified) npc machine"+char(10)+
	colorCyan+"See: [command] [-h|help] for more help on these and other commands"+char(10)

	help_buffer = colorOrange+"The BUFFER"+char(10)+
	colorOrange+"</b>The BUFFER stores objects. Anything may be stored in the BUFFER."+char(10)+
	colorOrange+"You access the BUFFER with the <b>malp</b> command >> option [5]"+char(10)+
	colorOrange+"</b>When an exploit is run, the result is stored in the BUFFER. You"+char(10)+
	colorOrange+"</b>may interact with these objects in a number of ways by selecting them"+char(10)+
	colorOrange+"</b>from the list and using their context menu (if the object has one)."+char(10)+
	colorOrange+"</b>One way to fetch an object from the BUFFER for use elswhere is to use the clipboard:"+char(10)+
	colorOrange+"</b>|> "+colorGreen+"clipb @B [index]</color>"+colorOrange+"</b>-- where index == BUFFER[index]"+char(10)+
	colorOrange+"</b>-- then pipe the value to another function"+char(10)+
	colorOrange+"You may pipe anything into the buffer with |><b> [command_returning_input] | malp</b>"+char(10)+char(10)+
	colorGreen+"Easy Clip! You may reference the clipboards with the @ symbol:"+char(10)+
	colorGreen+"***  clipa, clipb, and clipc are all clipboard spaces  ***"+char(10)+
	colorGreen+"</b>You may use @a, @b, and @c to reference their values"+char(10)+
	colorGreen+"</b>e.g. echo hello world | clipa |  | poke hello.txt @a"+char(10)+
	colorGreen+"*** tbuf, home, do ***"+char(10)+
	colorGreen+"</b>e.g. <b>gopher @tbuf</b>, e.g. <b>rshell @home</b>, e.g <b>scribus @do"+char(10)+char(10)+
	colorCyan+"</b>The CUSTOM_OBJECT is a way for scripts to share information between"+char(10)+
	colorCyan+"</b>nested launches. This means you can launch 5hell with 5hell and pass objects back and forth."+char(10)+
	colorCyan+"You interact with the custom_object via the various <b>cob</b> commands"+char(10)+
	colorCyan+"Namely: cob get and cob set."+char(10)+
	colorCyan+"For ease of use: <color=white>cob get</color> and <color=white>cob set</color> have been aliased to:"+char(10)+
	colorCyan+"-- <color=white>get</color> and <color=white>set</color> in 5hell.src"+char(10)+
	colorCyan+"-- |> </b>cob set bob burger <b>is equivalent to |></b> set bob burger"+char(10)+
	colorCyan+"-- |> </b>cob get bob<b> is quivalent to |></b> get bob"+char(10)+
	colorCyan+"</b>An example would be "+colorGold+"cerebrum</color> which loads the dictionary to the custom object:"+char(10)+
	colorCyan+"</b>-- once loaded, you may <b>run</b> 5hell through nested launches and the dictionary will persist."+char(10)+
	colorCyan+"-- This also allows you to import/export metaLib's and metaxploitLib's between machines!"+char(10)
	colorCyan+"-- Please see cob -h for more informaiton"

	help_logs = colorWhite+"The dreaded "+colorRed+"System.log"+char(10)+
	"Actions that generate an entry in system.log: "+char(10)+
	"-- establishing a net_session on a server (not a router)"+char(10)+
	"-- connecting via Browser.exe to a server"+char(10)+
	colorWhite+"---- connection established on port ##"+char(10)+
	"-- obtaining a shell (server/router)"+char(10)+
	colorWhite+"---- shell obtained on port ##"+char(10)+
	"-- deleting a file"+char(10)+
	colorWhite+"---- file deleted [ip]"+char(10)+
	"-- routing a connection with:"+char(10)+
	"-- connect_service or file_explorer"+char(10)+
	colorWhite+"---- connection routed [ip]"+char(10)+
	"-- shell disconnect"+char(10)+
	"-- i.e. exiting from start_terminal"+char(10)+
	colorWhite+"---- connection closed [ip]"+char(10)+char(10)+
	colorRed+"Active Traces"+CT+" will start when <b>shell.start_terminal</b> is used"+char(10)+
	"on an npc machine with an active admin of sufficient knowledge and give-a-damn."+char(10)+
	"Generally, if there is a root: dsession active, using start_terminal will trigger"+char(10)+
	"an active trace. Active traces are stopped by disconnecting (exiting) that terminal instance."+char(10)+char(10)+
	"When using 5hell you should NOT ever open a terminal (on a target) unless you are doing an Academic or"+char(10)+
	"Police record mission. OR if you absolutely need to open the browser to edit firewall or port rules"+char(10)+
	"on a target. Otherwise, use <b>glasspool</b> and <b>run</b> to leverage shell object manipulation instead."+char(10)+char(10)+
	"However! You <u>should</u> start_terminal on your end point attack proxy. In fact, do it twice:"+char(10)+
	"-- use <b>prox</b> to tunnel to your end point proxy then launch 5hell and type <b>psudo</b> and then select [y]"+char(10)+
	"-- this will start_terminal on top of your start_terminal, effectively looping your connection on that machine"+char(10)+
	"-- this will ensure your end point proxy's ip is left in logs. Without this, you risk exposing ip's behind the proxy."+char(10)+
	"-- note: this means you'll have to 'exit' twice from that proxy to return home"+char(10)+
	colorRed+"Passive Traces"+CT+" can/will start when certain actions have been left unaddressed:"+char(10)+
	"- Deleting a file and not removing the log entry"+char(10)+
	"- Leaving a connection closed log without a corresponding connection established log"+char(10)+
	"- Leaving a shell connected log at all"+char(10)+
	"- I think connection routed logs trigger traces, too. Not sure though."+char(10)+char(10)+
	colorMagenta+"We all leave logs, sometimes. To clean them up, here are a few methods:"+char(10)+
	colorLightBlue+"Silentclean "+CT+"-- local log corruption using a text file"+char(10)+
	"-- creates a file used to corrupt logs"+char(10)+
	"-- has nuke option (see: silentclean -h)"+char(10)+
	colorCyan+"Rclean "+CT+"-- remote (or local) log corruption using objects"+char(10)+
	"-- uses a file already on system to corrupt logs"+char(10)+
	"-- accepts and works on piped objects (see: rclean -h)"+char(10)+
	colorGold+"MV "+char(10)+"-- yep, just the <b>mv</b> command"+char(10)+
	"-- poke haha | mv haha /var/system.log"+char(10)+
	colorOrange+"Wiping the log with one of these methods using a reverse shell is best"+char(10)+
	"but not necessary. You may run silentclean, exit 5hell, exit the terminal, and you will not leave a disconnect log."+char(10)+
	"-- be aware that taking any log-creating action after running sc, except exiting, may regenerate the log."+char(10)

	help_alias = "<u><b>Aliases || Shortcuts || Macros || or is it Macro's ? || User Defined Behavior"+char(10)+
	"5hell can be very simple to use, or very, very complicated, depending on your goals."+char(10)+
	"It isn't necessary to learn 100% of 5hell. Nor is it necessary to suffer through some of it's"+char(10)+
	"more complex chains of commands. You can define your own behavior in a number of ways:"+char(10)+char(10)+
	colorLightBlue+"Aliases: "+char(10)+
	colorWhite+" You may define aliases in the aliases section of 5hell.src"+char(10)+
	colorWhite+"the default ones supplied are all prompt replacements. There are also 'easy clip' defenitions"+char(10)+
	colorWhite+"that replace arguments in the user input with, for instance, the contents of a clipboard or"+char(10)+
	colorWhite+"your @home server ip. These hard coded aliases may be more complicated than a simple"+char(10)+
	colorWhite+"word or string replacement. You may, for instance, have a simple two word alias fire"+char(10)+
	colorWhite+"a whole series of commands. This might be considered a macro at that point, but also"+char(10)+
	colorWhite+"might not quite qualify."+char(10)+char(10)+
	"Here is a list of the currently defined default aliases in 5hell.src:"+char(10)+
	colorLightBlue+"Alias           | Definition"+char(10)+
	 colorCyan+"bat [path]      |</b> do 1 -f [path]"+char(10)+
	 colorCyan+"set [key] [val] |</b> cob set [key] [val]"+char(10)+
	 colorCyan+"get [key]       |</b> cob get [key]"+char(10)+
	 colorCyan+"lock            |</b> perms lock all"+char(10)+
	 colorCyan+"exit            |</b> quit"+char(10)+
	 colorCyan+"sc [opt]        |</b> silentclean [opt]"+char(10)+
	 colorCyan+"gp [#]          |</b> glasspool [#]"+char(10)+
	 colorCyan+"prompt          |</b> -this will toggle the full_prompt on/off-"+char(10)+char(10)+
	colorWhite+"Easy Clip       |</b> Replacement"+char(10)+
	 colorGold+"@a              |</b> clipa -- globals.clip_board_alpha"+char(10)+
	 colorGold+"@b              |</b> clipb -- globals.clip_board_beta"+char(10)+
	 colorGold+"@c              |</b> clipc -- globals.clip_board_gamma"+char(10)+
	 colorGold+"@tbuf           |</b> transmission buffer -- globals.T_BUF"+char(10)+
	 "-- this is                |</b> where hashes go when the tree command finds them"+char(10)+
	 colorGold+"@home           |</b> HOME_SERVER ip address defined in 5hell.src"+char(10)+char(10)+
	 "Please note: several commands have their own references for editing the clipboards"+char(10)+
	 "-- these commands will use @clipa, @clipb, @clipc instead of @a, @b, @c"+char(10)+
	 "Further, the clipa, clipb, and clipc will use @B to reference the BUFFER:"+char(10)+
	 "-- e.g: |> <b>clipa @B 1</b> -- copy the object at index 1 in the BUFFER to clipa"+char(10)+
	 "-- that object may then be used by other commands that accept piped objects as input"+char(10)+
	 "-- there are other ways to pipe objects around besides the clipboards, explore to learn more."

	if arg1 == "-s" or arg1 == "show" or arg1 == "search" then
		c_buf = []
		h_buf = []
		for cmd in command.indexes.sort
			if cmd == "shell" or cmd == "help" or cmd == "__isa" or cmd == "classID" then continue
			h = @command[cmd]
			c_buf.push(colorWhite+cmd+CT)
			c_buf.push(h("help"))
		end for
		c_buf.push(colorWhite+"shell"+char(10)+"Usage: shell -- outputs instance_name, num_commands and dictionary_size.")
		c_buf = c_buf+[help_buffer,help_conventions,help_logs,help_tools,help_alias]

		if arg2 then
			invoke_regex = false
			special_chars = ["*","^","$","#"]
			for special in special_chars
				if arg2.indexOf(special) >= 0 then invoke_regex = true
			end for
			for c in c_buf
				found = false
				if not invoke_regex then 
					if c.indexOf(arg2) >= 0 then 
						//h_buf.push(c.replace(arg2,colorRed+arg2+CT)+char(10)+colorGold+"<u>---</u>"+CT+char(10))
						found = true
						//if DEBUG then print("attempting regex: "+arg2+ " | " + c)
					end if
				else
					for w in c.split(" ")
						if globals.re.match(arg2.values, w.values) then 
							//h_buf.push( c.replace(arg2, colorRed+arg2+CT) +char(10)+ colorBlack+"<u>---</u>"+ CT +char(10) )
							//if DEBUG then print(h_buf[-1])
							c = c.replace(w,colorRed+w+CT)
							found = true
						end if
					end for
				end if
				if found then h_buf.push( c.replace(arg2, colorRed+arg2+CT) +char(10)+ colorGold+"<u>---</u>"+ CT +char(10) )
				if DEBUG then print(h_buf[-1])
			end for
			return colorGold+"<u>= = = = = = Help Search = = = = = =</u>"+char(10)+colorLightBlue+"Found: </b>"+h_buf.len+"<b> results."+CT+char(10)+h_buf.join(char(10))
		end if
		return c_buf.join(char(10))
	end if
	if arg1 == "home" then
		return "Convention: <b>@home</b> -- indicates a server you, the end user, have set up for 5hell services. Server should be of type <b>SSH</b> and it is recommended to run<b> pwgen | pwgen hash</b> on it. The @home server is used by:<b> cerebrum, brutus, linkdb, transmit</b>. The @home server may optionally run:<b> hashim, dbmon, outmon</b>. Please contact Plu70 if you have questions about setting up these resources."+char(10)+"Please edit the appropriate line in 5hell.src to setup @home."
	end if
	
	if arg1 == "alias" then return help_alias
	if arg1 == "-c" or arg1 == "conventions" or arg1 == "-p" or arg1 == "prompt" then return help_conventions
	if arg1 == "-t" or arg1 == "tools" then return help_tools
	if arg1 == "-b" or arg1 == "buffer" then return help_buffer
	if arg1 == "-l" or arg1 == "logs" then return help_logs

	index = command.indexes
	if index.indexOf("__isa") != null then index.remove( index.indexOf("__isa"))
	if index.indexOf("classID") != null then index.remove( index.indexOf("classID"))
	if arg1 != "-i" then
		index = index.sort
	end if

	num_commands = index.len
	for dex in index 
		index.indexOf(dex) = colorCyan+dex+CT
	end for
	columns = 7 // # commands per line
	if globals.DEBUG then print("commands: "+num_commands+" columns: "+columns)
	rows = ceil(num_commands / columns)
	if globals.DEBUG then print("rows: "+rows)
	buf = []
	count = 0
	for i in range(0,rows)
		buf.push(index[count:count+columns].join(" "))
		count = count + columns
	end for
	print(colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"+CT)
	print(format_columns(buf.join(char(10))).replace("sphinx", colorRed+"sphinx"+char(8482)+CT) )
	print
	print(":><b> help</b> -- print this page: lists commands alphabetically")
	print(":><b> help guide</b> -- for a quick getting started guide")
	//print(":> help [-c|conventions] -- information about 5hell prompt conventions")
	print(":> help [-p|prompt|-c|conventions] -- information about 5hell prompt conventions")
	print(":> help [-t|tools] -- a short list of the main tools")
	print(colorOrange+":> help [-b|buffer] -- buffer, clipboard, and custom_object info")
	print(":> help [-l|logs] -- information regarding system.log")
	print(":> help [-s|show|search] -- for a full descriptive list of commands")
	print(":> help [-s|show|search] [word|string|regex] -- search all help info for pattern"+char(10)+"-- see grep -h for regex tokens")
	print(":> help [-i] -- list commands by command map index")
	print(":> help [alias] -- a list of the current default aliases in 5hell.src")
	print(":> help [home] -- information about the @home system")
	print(":> lock -- shortcut for perms lock all")
	print(":> prompt -- toggle full_prompt on and off")
	print(colorCyan+":> [command] [-h|help] -- for more information on a specific command."+char(10))
	return 0
end function

///////////////////////////////////////////////////////////////////////////////
if DEBUG then print("<size=75%>loaded ["+command.len+"] commands...")
//if DEBUG then print("initializing portmap...")
//if localmachine.is_network_active then command.probe("-q",pubip,"0","1")
if DEBUG then print("<size=75%>loading customizations (if any)...</size>")
print(colorRed+"5hell"+char(8482)+CT+" v "+ver+" by Plu70")
/////////////////////BEGIN MAIN////////////////////////////////////////////////


