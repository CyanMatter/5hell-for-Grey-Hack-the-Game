if DEBUG then print("<size=75%>loading kore.5pk...(123.942kb)</size>")
command.kore = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "kore: hypothetical threading. Contact Plu70/Jhook777 for support"+char(10)+"Usage:<b> kore -- initialize virtual filesystem for<u> kore, hashim and dbmon </u>(/virt dir and subfiles, /root/rkit/database.csv)</b>"+char(10)+"<u><b> Usage: kore -r -- copy 5hell, metaxploit.so, crypto.so to /root/rkit </b></u>"+char(10)+"Usage: kore -b -- run in bridge mode"+char(10)+"kore -c run in virtu_core mode"+char(10)+"Please contact Plu70/jhook for a tutorial before running in bridge or core mode."+char(10)+"Currently just use kore without params to set up the virtual filesys for hashim and dbmon (which can be run as without kore active once the filesys is created)"+char(10)+"N.B. - kore.5pk library also contains all network functions as it's intent is to be a botnet backend. This is the only function that comes close to 'phoning home' but <b>you</b> the user define 'home' in thread.cfg for all virtu_cores. Bridge mode recieves virtu_core connections. Kore does not spy on you. Kore does log all activity in /var/kore.log and this log may contain sensitive information. Please secure this log as you would any other."
	globals.CYCLES = 0
	if arg1 == "-r" then make_rkit = true else make_rkit = false
	kore = function()
		kore_version = "0.7"
		print("KORE: Hypothetical Threading v "+ kore_version + ", by Plu70")
		print("////////////////////////////////////////////////////////////")
		// globals
		TICK = 1 // seconds to wait between updates
		config_path = "/virt/thread.cfg" // Setup ip for bridge here
		config = localmachine.File(config_path)
		bridge_address = ""
		if arg1 == "-r" then config = 1
		if not config then
			print(colorOrange+"[404] "+config_path+" not found."+CT)
			create = user_input("Create /virt/thread.cfg ? [Y/n]")
			if create == "n" or create == "N" then return("Aborting...")
			v_path = localmachine.File("/virt")
			if not v_path then localmachine.create_folder("/virt")
			localmachine.touch("/virt", "thread.cfg")
			config = localmachine.File(config_path)
			if not config then return(colorRed+"[401] check write permissions."+CT)
			if arg1 == "-b" then
				bridge_address = localmachine.public_ip
			else
				bridge_address = user_input("Bridge address (leave blank to skip): ")
			end if
			config.set_content("Bridge:"+char(10)+bridge_address)
		end if
		cfg = config.get_content.split(char(10))

		// vritu_files
		virt_path = "/virt"
		swap_path = "swap.spc"
		cache1_path = "cache1.spc"
		share_path = "share.spc"

		// addresses
		bridge_address = cfg[cfg.indexOf("Bridge:")+1]
		print("Locating bridge at "+bridge_address)

		BRIDGE = "" // buffer space
		// BRIDGE files
		localmachine.touch(virt_path, swap_path)
		SWAP = localmachine.File(virt_path+"/"+swap_path)
		localmachine.touch(virt_path, cache1_path)
		CACHE1 = localmachine.File(virt_path+"/"+cache1_path)
		CACHE2 = ""
		CACHE3 = ["--END--"]
		localmachine.touch(virt_path, share_path)
		SHARE = localmachine.File(virt_path+"/"+share_path)
		if not SWAP or not CACHE1 or not SHARE then return(colorRed+"[111] Write error."+CT)
		// out files
		localmachine.touch("/var","kore.log")
		LOG = localmachine.File("/var/kore.log")
		out_path = "/virt/out.spc"
		localmachine.touch("/virt", "out.spc")
		OUT = localmachine.File(out_path)
		if not LOG or not OUT then return(colorRed+"[215] Write error."+CT)
		rkp = localmachine.File("/root/rkit")
		if not rkp then localmachine.create_folder("/root/rkit")
		DBF = localmachine.File("/root/rkit/database.csv")
		if not DBF then localmachine.touch("/root/rkit", "database.csv")
		DBF = localmachine.File("/root/rkit/database.csv")
		if not DBF then return(colorRed+"[217] Write error."+CT)
		//print("Folders created. Securing system with <b>perms lock all</b>.")
		//command.perms("lock","all")
		// end globals
		print(colorLightBlue+"Memtest complete...."+CT+char(10)+colorWhite+"Kore is configured correctly."+CT)

		globals.IGNORE = 0
		globals.DECRYPT = 0
		globals.DBASE = 0
		globals.PURGE = 0

		binval = function( s="1,0,0,0" )
			print(s)
			b = s.split(",")
			if b.len != 4 then b = [1,0,0,0]
			globals.IGNORE = b[0]
			globals.DECRYPT = b[1]
			globals.DBASE = b[2]
			globals.PURGE = b[3]
		end function

		run_as_bridge = false
		run_as_core = false
		make_rkit = false
		if arg1 == "-b" then run_as_bridge = true
		if arg1 == "-c" then run_as_core = true
		if arg1 == "-r" then make_rkit = true

		SWAP.set_content("")
		CACHE1.set_content("")
		SHARE.set_content("")
		globals.CYCLES = 0
		connection_true=function()
			return true // make sure cores are up and running
		end function
		cycle = function(timeout=1)
			max_wait = 10
			//clear_screen
			while timeout < max_wait
				print("<voffset=0em>["+"_"*timeout+"_]</voffset>")
				for i in range(0,timeout) // progress bar by Rasputin
					print(colorRed+"<voffset="+(3+(2.85*i))+"em>"+"#"*(i+1)+"#</voffset>"+CT)
					wait(TICK)
				end for
				globals.CYCLES = globals.CYCLES + 1
				if globals.CYCLES >= 5 then
					globals.CYCLES = 0
					clear_screen
				end if
				if connection_true then return //"Connection reestablished."
				timeout = timeout + timeout
			end while
			return("Connection timed out. Exiting...")
		end function

		///////////////////

		MAX_CYCLES = 161
		BRIDGE = SHARE.get_content
		virtu_bridge = function()
			icon = "0"
			if arg2 then icon = arg2
			cycles = 0
			running = true
			while running
				if BRIDGE == SHARE.get_content then
					//update stuff
					act = false
					if SWAP.get_content != CACHE1.get_content then
						act = true
						OUT.set_content(SWAP.get_content)
						LOG.set_content(LOG.get_content+char(10)+CACHE1.get_content+char(10)+SWAP.get_content)
						SWAP.set_content("")
						CACHE1.set_content("")
						BRIDGE = ""
					else
						cycles = cycles + 1
						if cycles >= MAX_CYCLES then
							cycles = 0
							SWAP.set_content("")
							BRIDGE = ""
						end if
					end if
					if CACHE2 != "" and CACHE1.get_content == "" then
						act = true
						SHARE.set_content(CACHE2)
						CACHE2 = ""
						BRIDGE = ""
					end if
					if CACHE3.len > 1 and CACHE3[-1] != "--END--" and CACHE2 == "" then
						CACHE2 = CACHE3.pop
						BRIDGE = ""
						act = true
					end if
				else
					act = true
					cycles = 0
					BRIDGE = SHARE.get_content
					if SWAP.get_content == "" then
						SWAP.set_content(BRIDGE)
						CACHE1.set_content(BRIDGE)
						SHARE.set_content("")
						BRIDGE = ""
					else
						if CACHE2 == "" then
							CACHE2 = BRIDGE
							SHARE.set_content("")
							BRIDGE = ""
						else
							CACHE3.push(BRIDGE)
							SHARE.set_content("")
							BRIDGE = ""
						end if
					end if
				end if
				o_f = ""
				if SWAP.get_content == "" then o_f = colorGreen else o_f = colorOrange
				if CACHE3.len > 2 then o_f = colorRed
				w_w = colorLightBlue
				if act then w_w = colorWhite
				print(w_w+"<"+CT+o_f+icon+CT+w_w+">"+CT)
				cycle
			end while
			return time
		end function

		virtu_core = function()
			myip = localmachine.public_ip
			icon = "@"
			if arg2 then icon = arg2
			pt = 22 // default, change this for dedicated port
			user = "root"
			pass = user_input("Core Init requires root pass of bridge machine :> ", 1)
			remote = get_shell.connect_service(bridge_address, pt, user, pass)
			IO = remote.host_computer.File("/virt/swap.spc")
			BRIDGE_DB = remote.host_computer.File("/root/rkit/database.csv")
			localmachine.touch("/virt", "proc.st")
			proc_state = localmachine.File("/virt/proc.st")
			if not proc_state then return(colorRed+"[369]: Write error."+CT)
			running = true
			while running
				if BRIDGE == IO.get_content or IO.get_content == "x5gF43purge9R2mGuP41s" then
					act = false
					w = false
					PURGE = false
				else
					act = true
					BRIDGE = IO.get_content
					T_T = BRIDGE.split(char(10))
					for t in T_T
						if t.indexOf("Learn:") >= 0 then
							DECRYPT = false
							DBASE = true
						end if
						if t.indexOf("Decrypt:") >= 0 then
							DECRYPT = true
							DBASE = false
						end if

					end for
					if not DECRYPT and not DBASE then PURGE = true
				end if
				if DECRYPT then
					w = true
					DECRYPT = false
					temp = []
					for t in T_T
						if t.indexOf(":") > 0 then
							spl = t.split(":")
							ts = spl[1]
							if ts.len == 32 then temp.push(t)
						end if
					end for
					SWAP.set_content(temp.join(char(10))) // decrypt script listens on /virt/swap.spc
					CACHE1.set_content(temp.join(char(10))) // compare to detect change
					proc_state.set_content(localmachine.public_ip+": BUSY ")
				end if
				if DBASE then
					w=true
					DBASE = false
					temp = []
					for t in T_T
						if t.indexOf("Learn:") >= 0 then temp.push(t)
					end for
					CACHE2 = temp.join(char(10))
					SHARE.set_content(CACHE2)
					proc_state.set_content(localmachine.public_ip+": BUSY ")
				end if
				if SHARE.get_content != CACHE2 and SHARE.get_content != "" then
					w = true
					act = true
					BRIDGE = SHARE.get_content
					T_T = ""
					LOG.set_content(LOG.get_content+char(10)+T_T.join(char(10))+char(10)+BRIDGE)
					OUT.set_content(BRIDGE)
					SHARE.set_content("")
					CACHE2 = ""
					BRIDGE_DB.set_content(BRIDGE)
					IO.set_content(BRIDGE)
					BRIDGE = ""
					proc_state.set_content(localmachine.public_ip+": READY ")
				end if
				if SWAP.get_content != CACHE1.get_content and SWAP.get_content != "" then
					w = true
					act = true
					BRIDGE = T_T.join(char(10))+char(10)+SWAP.get_content
					T_T = ""
					LOG.set_content(LOG.get_content+char(10)+BRIDGE)
					OUT.set_content(BRIDGE)
					SWAP.set_content("")
					CACHE1.set_content("")
					proc_state.set_content(localmachine.public_ip+": READY ")
					IO.set_content(BRIDGE)
					BRIDGE = ""
				end if
				if PURGE then
					BRIDGE = "x5gF43purge9R2mGuP41s"
					SHARE.set_content("")
					CACHE1.set_content("")
					CACHE2 = ""
					SWAP.set_content("")
					if IO.get_content != "x5gF43purge9R2mGuP41s" then IO.set_content(BRIDGE)
					proc_state.set_content(localmachine.public_ip+": READY ")
					PURGE = false
					w = true
				end if
				o_f = colorGreen
				if act then o_f = colorOrange
				w_w = colorLightBlue
				if w then w_w = colorWhite
				print(w_w+"<"+CT+o_f+icon+CT+w_w+">"+CT)
				cycle
			end while
			return
		end function
		print(colorLightBlue+"Status: Ready. Press enter to continue.")
		user_input("<::>")
		if run_as_bridge then return(virtu_bridge)
		if run_as_core then return(virtu_core)
	end function
	if make_rkit then
		if globals.instance then pro_path = globals.instance.path else return "kore: 5hell instance deleted. unable to automate rkit construction."
		print("Validating /root/rkit...")
		print(command.mkdir("/root/rkit"))
		print("Copying: "+pro_path+" to /root/rkit...")
		print(command.cp(pro_path, "/root/rkit" ))
		if globals.metaxploit then
			mpath = null
			if globals.mlib == true then
				mpath = "/lib/metaxploit.so"
			else
				mpath = command.tree("/","metaxploit.so","1","N")
				if typeof(mpath) == "file" then mpath = mpath.path else return "kore: metaxploit.so not found"
			end if
		else
			return "kore: metaxploit.so not found"
		end if
		print("Copying: "+mpath+" to /root/rkit...")
		command.cp(mpath, "/root/rkit")
		if globals.crypto then
			cpath = null
			if globals.clib == true then
				cpath = "/lib/crypto.so"
			else
				cpath = command.tree("/","crypto.so","1","N")
				if typeof(cpath) == "file" then cpath = cpath.path else return "kore: crypto.so not found"
			end if
		else
			return "kore: crypto.so not found"
		end if
		print("Copying: "+cpath+" to /root/rkit")
		command.cp(cpath, "/root/rkit")
		return "kore: rkit construction complete."
	end if
	return kore
end function
command.target = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "Target || Target IP || Target Port"+char(10)+"Usage: target -- return current target ip and port"+char(10)+"Usage: target ip -- returns current target ip"+char(10)+"Usage: target pt -- return current target port"+char(10)+"Usage: target [ip] -- set target ip address (ip must be a valid ip)"+char(10)+"Usage: target -p [port] -- set target port (returns target port if not supplied)"+char(10)+"Usage: target [ip] [port] -- set targt ip and port in a single command"+char(10)+char(10)+"Note: target ip and port are used by 5phinx, transmit, meta, db, probe, and others."
	if not arg1 then return "<b>"+globals.targetIP+" "+globals.targetPort
	if arg1 == "ip" then return "<b>"+ globals.targetIP
	if arg1 == "pt" then return "<b>"+ globals.targetPort
	if arg1 == "-p" then 
		if arg2 and arg2.to_int >= 0 then globals.targetPort = arg2.to_int
		return "<b>"+globals.targetPort
	end if
	if is_valid_ip(arg1) then globals.targetIP = arg1 
	if arg2 and arg2.to_int >= 0 then globals.targetPort = arg2.to_int
	return "<b>"+globals.targetIP+" "+globals.targetPort
end function
command.transmit = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return ("Usage: transmit [ip] [port] -- transmit text to remote file. Default port 22."+char(10)+"-- you may set ip with <b>target [ip] [port]</b> instead"+char(10)+"-- you may set ip with launch params: 5hell [ip] [port]"+char(10)+"-- simply type transmit without params if ip is set this way."+char(10)+"---- Enter data 1 line at a time. "+char(10)+"---- Send with @send on new line")+char(10)+"---- the contents of <b>@tbuf</b> are automatically added"+char(10)+char(10)+"Transmit is intended to write information to a remote text file."+char(10)+"While desinged for use with hashim and dbmon, you"+char(10)+" may use it to transmit standard text files if you find that useful."
	if arg2 == 0 then arg2 = "22" // default ssh port for transmit
	remote_ip = globals.targetIP
	remote_port = globals.targetPort
	pass_path = user_input("transmit_to_this_path (q=quit):> ")
	if pass_path.lower == "q" or pass_path == "" then return ("aborting...")
	if arg1 then
		remote_ip = arg1
		if arg2 then remote_port = arg2.val
	end if
	print("Establishing connection to "+remote_ip+" ... ")
	skip_wait = true
	if not is_valid_ip(remote_ip) then return ("transmit: invalid ip: "+remote_ip)
	passwd = user_input("Remote password (not stored. leave blank to abort): ",1)
	if passwd == "" then return ("aborting...")
	remote = shell.connect_service(remote_ip, remote_port, "root", passwd)
	if not remote then return "Unable to establish connection."
	passfile = remote.host_computer.File(pass_path)
	if not passfile then return("404: shared file: "+passfile+" not found. ")
	t_buf = globals.T_BUF
	transmit = ""
	print("Connection established. "+char(10)+"<b>@tbuf</b> added to transmission."+char(10)+"Type <b>@send</b> on a newline to finish and transmit. "+char(10)+"Type <b>@clipb</b> on a newline to paste from clipboard 'b' "+char(10)+"Type @wait to await a response from hashim or dbmon. Will write response to clipb."+char(10)+"Type @q or @@ on newline to abort")
	while t_buf[-1] != "@send"
		transmit = user_input(":>") // line to send
		if transmit == "@q" then return "aborting..."
		if transmit == "@clipb" then
			t_buf.push(command.clipb(0,0))
		else
			if transmit == "@wait" then
				skip_wait = false
			else
				t_buf.push(transmit)
			end if
		end if
	end while
	t_buf = t_buf.join(char(10))
	passfile.set_content(t_buf)
	print(t_buf)
	waiting = true
	print("Transmission sent. Awaiting response...")
	while waiting
		//wait(2)
		out = remote.host_computer.File("/virt/out.spc")
		if not out then
			print("/virt/out.spc not found")
			skip_wait = true
		end if
		if passfile.get_content != t_buf or skip_wait then
			if skip_wait then
				//print(passfile.get_content)
				waiting = false
				print("...transmission complete.")
			else
				last_out = out.get_content
				if last_out != out.get_content then
					waiting = false
					last_out = out.get_content
					//print("Clipped: "+char(10)+last_out)
					print("Receiving response...")
					print(command.clipb(last_out))
				end if
			end if
		end if
	end while
	globals.T_BUF = [(localip+"@"+pubip)]
	return 0
end function
command.outmon = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "outmon: monitor an output file"+char(10)+"Usage: outmon [path] [opt:interval]"+char(10)+"path -- path to file. default /virt/out.spc"+char(10)+"interval -- refresh rate. default 2 seconds, range(.1, 300)"+char(10)+"-- prints changes to a text file every [interval] seconds"
	out_space = localmachine.File("/virt/out.spc")
	if arg1 then out_space = globals.get_file(arg1)
	if not out_space then return "outmon: "+ arg1 + ": file not found."
	last_read = "-EMPTY-" // out_space.get_content
	//print(colorWhite+"Listening on :"+out_space.path+" for connections..."+CT)
	interval = arg2 // refresh interval, may be float in range .1, 300
	if interval and typeof(interval) == "string" then interval = interval.val
	if typeof(interval) != "number" or interval < .1 or interval > 300 then interval = 2
	running = true
	while running
	  if last_read == out_space.get_content then
	    //skip
	  else
	    last_read = out_space.get_content
	    print(colorGreen+"///////////////////////////////////////"+CT)
	    print(last_read)
	    print(colorGreen+"///////////////////////////////////////"+CT)
	    print(colorWhite+"Listening on :"+out_space.path+" for connections..."+CT)
	  end if
	  wait(interval)
	end while
	return 0
end function
command.dbmon = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "dbmon: database daemon for use with KORE"+char(10)+"Usage: dbmon [/path -- default /root/pass] [interval -- default 2 seconds, range(.1, 300)]"+char(10)+"-- vulnerability database daemon. Write ip addresses to the given path and dbmon will database the ip."+char(10)+"Usage: use transmit, poke, scribus, etc to write to the pass file."+char(10)+"-- as ips are added to the pass file dbmon will run the databaser (command.db) on the ip (and port, if supplied.)"+char(10)+"-- add ips one per line to the pass file."+char(10)+"-- adjust interval to increase or decrease sample rate."+char(10)+"-- outputs to database.csv (wherever that file may be on the machine)"
	db_file = command.tree("/","database.csv",1,"N")
	if not db_file then return "dbmon: missing database.csv"
	shar = globals.get_file("/root/pass")
	if arg1 then shar = globals.get_file(arg1)
	if not shar then return "dbmon: "+arg1+": file not found"
	int = arg2 // interval (ntbcw integer), may be float in range .1, 300
	if int != 0 then int = int.val
	if typeof(int) != "number" or int < .1 or int > 300 then int = 2
	running = true
	last_check = ""
	clear_me = false
	print(colorWhite+"Listening on:"+shar.path+" for connections..."+CT)
	while running
		if last_check == shar.get_content or shar.get_content == "" then
			// skip
		else
			last_check = shar.get_content
			//print(last_check)
			buf = last_check.split(char(10))
			for b in buf
				bs = b.split(" ")
				if is_valid_ip(bs[0].trim)  then
					//print(bs[0]+"__"+bs[1]+"__"+bs.len)
					if bs.hasIndex(1) then
						command.db("-r", bs[0].trim, bs[1].to_int)
					else
	        	command.db("-r", bs[0].trim)
					end if
				end if
				if bs.indexOf("@clear") >= 0 then clear_me = true
			end for
	    if clear_me then
				db_file.set_content("-empty-")
				shar.set_content(db_file.get_content)
				clear_me = false
			else
				shar.set_content(db_file.get_content)
			end if
	    last_check = shar.get_content
			print(colorWhite+"Listening on:"+shar.path+" for connections..."+CT)
		end if
		wait(int)
	end while
	return 0
end function
command.hashim = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then
		if arg2 and arg2 == "extra" then
			return "Files required: /root/tables/t5/XX (XX is all files from<b> pwgen hash </b>, ascii), 5hell (bin)."+char(10)+"Files created: /root/dump.txt (ascii) -- the output file with cracked passwords"+char(10)+"Input format: "+char(10)+"   user:hash "+char(10)+"Once per line in /root/pass or specified path (see also <b>transmit</b>). "+char(10)+"May be of type bank, mail, passwd."
		else
			return "hashim: hash daemon"+char(10)+"Usage: hashim [-d|-f] [path] -- listen on [path] and decipher contents using tables/t5"+char(10)+"-- default path is /root/pass"+char(10)+"-- -f == run once on specified path"+char(10)+"-- -d == run as daemon on specified path"+char(10)+"N.B. Please run <b> pwgen hash </b> to setup resources for hashim."+char(10)+"n.b.b This command requires root access and it is recommended to use, along with pwgen, on a dedicated server due to the number of files involved. ie try not to spam hashim servers. a single one works wonders."+char(10)+"Extra: hashim [-h|help] [extra] -- extra help page with extra help info."
		end if
	end if
	if arg1 != "-d" and arg1 != "-f" then return "Usage: hashim [-f|-d] [path] -- -f == run once on specified path, -d == run in daemon mode on specified path. Default path: /root/pass."
	if not crypto then print(colorOrange+"WARNING: crypto.so not found"+CT)
	localmachine.touch("/root", "dump.txt")
	dump = localmachine.File("/root/dump.txt")
	if not dump then return "404: /root/dump.txt not found. check read/write permissions."
	swap_path = "/root/pass"//params[0]
	swap_file = localmachine.File(swap_path)
	if not swap_file then return("404: "+swap_path+" not found.")
	//out_path = "/virt/out.spc"
	//out_file = localmachine.File(out_path)
	//if not out_file then return("404: "+out_path+" not found"+char(10)+"type<b> kore </b>without params to create (you may skip adding an ip)")
	cache = []
	found = false
	daemon = true
	if arg1 == "false" or arg1 == "-f" then daemon = false
	hashim = function(daemon,swap_file)
		//if not daemon then swap_path = "/root/pass"
		//swap_file = globals.get_file(swap_path)
		if not swap_file then return "404: "+swap_path+" not found."
		last_read = "" //swap_file.get_content
		running = true
		print(colorWhite+"Listening on :"+swap_path+" for connections..."+CT)
		while running
			found = false
			hash = ""
			user = ""
			if last_read == swap_file.get_content or swap_file.get_content == "" then
				// skip
			else
				time_s = time
				last_read = swap_file.get_content.split(char(10))
				for hash in last_read
					found = false

					//print("{"+hash+"}")
					//if hash == last_read[0] then continue
					if hash.indexOf(":") >= 0 then
						user = hash.split(":")[0]
						hash = hash.split(":")[-1]
					else
						continue
					end if
					hash = hash.trim
					if hash.indexOf("@") >= 0 then continue
					if hash.len != 32 then continue
					print("["+hash+"]")
					t_folder = localmachine.File("/root/tables/t5")
					if not t_folder then return "/root/tables/t5 not found. run<b> pwgen hash </b>before continuing."
					files = t_folder.get_files
					for f in files
						if found then continue
						lines = f.get_content.split(char(10))
						for line in lines
							if found then continue
							if line == lines[0] then continue
							spl = line.split("=")
							h = spl[0]
							p = spl[1]
							if h == hash then
								print("Hashim: " + user + ":" + colorWhite + p + CT + " found in " + (time-time_s) + " seconds.")
								cache.push(user + ":" + p)
								found = true
								continue
							end if
						end for
					end for
					if found then continue
					if crypto then
						password = null
						password = crypto.decipher(hash)
						if password then
							print("Hashim: " + user + ":" + colorWhite + password + CT + " found in " + (time-time_s) + " seconds.")
							cache.push(user + ":" + password)
							found = true
							continue
						end if
					end if
					print(colorRed+"Hash not found: unknown: "+hash+CT)
				end for
				last_read = cache.join(char(10))
				if daemon then print("Sending: "+char(10)+last_read)
				if daemon then swap_file.set_content(last_read)
				print("Saving to dump.txt...")
				dump.set_content(dump.get_content+char(10)+last_read)
				cache = []
				print(colorLightBlue+"Hashim: completed task in "+(time-time_s)+" seconds."+CT)
				wait(1)
				if daemon then
					print(colorWhite+"Listening on :"+swap_path+" for connections..."+CT)
				else
					return 0
				end if
			end if
		end while
		return 0
	end function
	return hashim(daemon,swap_file)
end function
command.filemon = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "Usage: filemon [opt:interval] -- monitor /virt/share.spc for transmissions (see transmit/TxBUF) "+char(10)+"-- and decipher using Gopher (interval default: 1 second) "+char(10)+"Usage: filemon -nl [interval] -- same as above but disables logging to /var/filemon.log "+char(10)+"Usage: filemon [opt:interval] <b>-p [path_to_shared_file]<b> -- monitor given file (default: /virt/share.spc)]"+char(10)+"n.b. since this command uses gopher isntead of the pwgen tables it is an alternative to running a hashim server since you may run cerebrum before running filemon, getting the same effect as hashim, with only a 2-3 minute setup."+char(10)+"N.B. filemon writes to /var/filemon.log"+char(10)+"-- the log will contain the incoming ip when command.transmit is used"+char(10)+"-- the log will contain the hashed lines."+char(10)+"-- cracked passwords are written to dump.txt"+char(10)+"N.B. if not using transmit, simply paste or pipe lines to the indicated path and filemon will act automatically."
	logging = true
	SWAPSPACE = []
	interval = 1 // how long to wait between checks
	if arg1 and arg1 != "-nl" and arg1 != "-p" and arg1.val > 1 then interval = arg1.val
	if arg2 and arg2 != "-nl" and arg1 != "-p" and arg2.val > 1 then interval = arg2.val
	if arg1 == "-nl" or arg2 == "-nl" then logging = false
	v = localmachine.File("/virt")
	if not v then localmachine.create_folder("/virt")
	localmachine.touch("/virt/share.spc")
	pass_path = "/virt/share.spc" // path to shared file
	if arg1 == "-p" and typeof(arg2) == "string" then pass_path = arg2
	out_path = "/virt/out.spc" // path to output from custom decipher
	localmachine.touch("/virt", "out.spc")
	out = localmachine.File(out_path)
	if not out then return(colorRed+"outfile: check write permissions")
	swap_path = "/root/rkit/swap.spc"
	localmachine.touch("/root/rkit","swap.spc")
	swap_file = localmachine.File(swap_path)
	if not swap_file then return(colorRed+"Swap: check write permissions"+CT)
	pass_file = localmachine.File(pass_path)
	if not pass_file then return(colorRed+"404: shared file not found"+CT)
	log_path = "/var/filemon.log"
	localmachine.touch("/var", "filemon.log")
	log_file = localmachine.File(log_path)
	if not log_file then return(colorRed+"Log: check write permission")
	SWAPSPACE = pass_file.get_content.split(char(10))
	running = true
	print(colorWhite+"waiting for updates on "+pass_file.path+"..."+CT)
	while running
		new_content = pass_file.get_content.split(char(10))
		if SWAPSPACE[0] == new_content[0] and SWAPSPACE[-1] == new_content[-1] then
			//skip
		else
			SWAPSPACE = new_content
			last_ip = SWAPSPACE.pull
			//last_ip = SWAPSPACE[0]
			print(colorOrange+last_ip+" has connected..."+CT)
			print(colorLightBlue+"Communication detected... "+CT)
			swap_file.set_content(SWAPSPACE.join(char(10)))
			globals.Gopher(swap_file)
			dump = localmachine.File(currentPath+"/dump.txt")
			if not dump then return(colorRed+"404: dump.txt not found"+CT)
			pass_file.set_content(dump.get_content)
			SWAPSPACE = pass_file.get_content.split(char(10))
			//self.merge("/root/rkit/dump.txt", "/virt/out.spc")
			out.set_content(dump.get_content)
			print(colorLightBlue+"Response sent."+CT)
			print(colorOrange+last_ip+" has closed connection."+CT)
			if logging then log_file.set_content(log_file.get_content +char(10)+swap_file.get_content +":"+ last_ip + char(10)+time+char(10))
			print(colorWhite+"waiting for updates..."+CT)
		end if
		wait(interval)
		//clear_screen
	end while
	return 0
end function
command.rsi = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: <b>rsi</b> -- rshell_interface: listen for connections on port 1222"+char(10)+"-- Runs once then exits. For daemon mode use:"+char(10)+"rsi -d -- daemon mode, continues to listen for connections until an rshell connects."+char(10)+"<b>Advanced</b>: rsi [-i|install] -- installs the reverse shell server if librshell.so is in /lib"+char(10) +"Advanced: rsi [<b>start</b>|<b>stop</b>] -- start or stop the installed rshell server"
	if not metaxploit then return "Error: Can't find metaxploit library in the /lib path or the current folder"
	if not localmachine.is_network_active then return "nsl: no network connection."
	if arg1 == "stop" then 
		rserver = null
		rserver = include_lib("/lib/librshell.so")
		if rserver then rc = rserver.stop_service else return colorRed+"rsi: /lib/librshell.so not found"+CT
		if rc then return colorGreen + "rsi: service stopped" +CT else return colorOrange + "rsi: service is not running" + CT
	end if
	if arg1 == "start" then 
		rserver = null
		rserver = include_lib("/lib/librshell.so")
		if rserver then rc = rserver.start_service else return colorRed+"rsi: /lib/librshell.so not found"+CT
		if rc then return colorGreen + "rsi: service started" +CT else return colorOrange + "rsi: service is already running" + CT
	end if
	if arg1 == "-i" or arg1 == "install" then 
		rserver = null
		
        lbrs = command.tree("/","librshell.so",1,"N")
        if not lbrs then return colorRed+"rsi: librshell.so not found on machine."+CT
		rc = null
        lib = localmachine.File("/lib")
        if not lib then return "rsi: error, /lib missing"
        if lib.has_permission("w") and lbrs.has_permission("r") then lbrs.copy("/lib",lbrs.name)
        rserver = include_lib("/lib/librshell.so")
        if not rserver then print("rsi: librshell.so not installed in /lib.")
        rc = rserver.install_service
		if rc then return colorGreen+"rsi: service installed"+CT else return colorRed + "rsi: failed to install service" + CT
	end if
	print(colorLightBlue+"Listening for upcoming connections...")
	shells = []
	option = arg1
	st = arg2
	while shells.len == 0
		shells = metaxploit.rshell_server
		if typeof(shells) == "string" then return shells
		if shells.len == 0 and arg1 != "-d" then return colorOrange+"no rshells connected. use<b> rsi -d </b> to run in daemon mode."+CT
	end while
	if not arg1 then option = "0"
	while typeof(option) != "number" or option > shells.len or option < 0
		print(colorLightBlue + shells.len + "</b> shell(s) connected!\n<b>Select a shell to start a terminal:"+CT)
		for i in range(0, shells.len - 1)
			print(colorLightBlue+"-----------"+CT+char(10) +colorLightBlue+"Shell (" +colorWhite+ (i + 1) +CT+ ")" +CT+char(10)+ "Public IP: " + shells[i].host_computer.public_ip + char(10) + "Local IP: " + shells[i].host_computer.local_ip + char(10) + colorWhite + shells[i].host_computer.show_procs + CT )
		end for
		print(colorLightBlue+"-----------"+CT)
		option = user_input("Select shell ([0|q] to abort) :> ").to_int
		if option == 0 or option == "q" then return 0
	end while
	if option == 0 or option == "q" then return 0
	print("Accessing shell [" + option + "]")
	ts = shells[option - 1]
	print("[4] buff_it [5] rclean [6] run "+char(10)+"[1] glassp [2] start_terminal [3] scp ")
	st = user_input("[K] kill [0|q] abort ||: ",0,1)
	if st == "0" or st.lower == "q" then return 0
	if st.lower == "k" then print(ts.host_computer.close_program(user_input("kill pid:> ").to_int ) )
	if st == "1" then
		print(colorLightBlue+"Initializing sshfs glasspool protocol..."+CT)
		hold_shell = globals.shell
		globals.shell = ts
		globals.localmachine = ts.host_computer
		if currentPath and homePath then
		 	globals.GLASSPOOL = globals.GLASSPOOL + 1
			print(colorWhite+"...glasspool initialization successful. "+char(10)+colorOrange+"Type <u>return</b> to deactivate (exit or quit to terminate program)"+CT)
			if typeof(shell) == "ftpshell" then print(colorOrange+"Warning: many commands will not work with ftpshells!"+CT)
			command.shell
			globals.shell = hold_shell
			globals.localmachine = globals.shell.host_computer
			globals.GLASSPOOL = globals.GLASSPOOL - 1
			return colorLightBlue+"GLASSPOOL: "+colorOrange+"deactivating..."+CT
		end if
		return colorOrange+"...glasspool failed to initialize. Check permissions."+CT
	end if
	if st == "2" then ts.start_terminal
	if st == "3" then
		if GLASSPOOL then
			print(colorLightBlue+"GLASSPOOL: "+colorOrange+"active"+colorLightBlue+" on: "+CT)
			print(colorWhite+globals.shell.host_computer.local_ip+"@"+globals.shell.host_computer.public_ip+CT)
			print("Upload from / Download to the linked filesystem:")
		end if
		globals.secure_copy(ts)
	end if
	if st == "4" then
		BUFFER.push(ts)
		print("Shell sent to BUFFER.")
	end if
	if st == "5" then globals.rclean(ts)
	if st == "6" then
		print(ts.launch(user_input("command_path:> ",0,0), user_input("params:> ",0,0)))
		globals.stack_pool = globals.stack_pool - 1
	end if
	return "rsi: exiting..."
end function
command.scpm = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "scpm: scp menu"+char(10)+"Usage: scpm -- from menu select target shell (active shell is shown with an '*'). "+char(10)+"-- input source path and then destination path at prompts."+char(10)+"-- select upload or download. Note the printed trajectories."+char(10)+"-- (these can change when glasspool is involved)."+char(10)+"-- if uploading indicate if editing permissions"+char(10)+"-- if editing permissions press enter for defaults"+char(10)+"-- default is o+rwx before uploading and then o-rwx after uploading."+char(10)+"Always mind permissions! Type lock constantly to feel secure."+char(10)+"Advanced: scpm [string_path|piped_file] -- open scpm menu with path or file.path tagged for scp"+char(10)+"Advanced: scpm [piped_shell] -- skip menu and scp to/from piped shell"
	target_shell = null
	if typeof(arg1) == "string" then
		tag = globals.get_file(arg1)
		if tag then globals.tagged_for_scp = tag.path
	end if
	if typeof(arg1) == "file" then
		if globals.get_file(arg1.path) then globals.tagged_for_scp = arg1.path else return "scpm: "+arg1.name+" is not local to this shell. Check glasspool status."
	end if
	if typeof(arg1) == "computer" then
		return "scpm: computer object is an invalid input."+char(10)+"  valid inputs: string_path, shell, file"
	end if
	if typeof(arg1) == "shell" or typeof(arg1) == "pshell" or typeof(arg1) == "ftpshell" then

		if p_validate(arg1,"scp") then target_shell = arg1 else return "scpm: error, scp function not found in object."
	else
		temp_buf = []
		for b in BUFFER
			if typeof(b) == "shell" or typeof(b) == "ftpshell" or (typeof(b) == "pshell" and p_validate(b,"scp")) then temp_buf.push(b)
		end for
		r_index = temp_buf.len
		if metaxploit then
			r_buf = metaxploit.rshell_server
			if typeof(r_buf) != "string" then temp_buf = temp_buf + r_buf
		end if
		ti = 0
		print(colorLightBlue+"<size=85%><mark=blue>======================================================================</mark></size>"+CT)
		active_icon = "<b> - </b>"
		print("<u>BUFFER contains: "+temp_buf.len+" (r)shell(s) ["+colorWhite+"0"+CT+"] == localhost "+colorCyan+"*"+CT+" == "+colorCyan+"active shell"+CT+"</u>"+char(10)+"<size=75%><u>"+colorLightBlue+" rshells "+CT+"are listed after"+colorOrange+" BUFFER "+CT+"shells. rshells in BUFFER will be listed twice.</size></u>")
		color_shelle = colorOrange
		she_buf = []
		for tb in temp_buf
            if typeof(tb) == "pshell" then 
                she_buf.push("["+colorWhite+ti+CT+"]"+active_icon+""+color_shelle+"["+checkUser(tb)+":"+typeof(tb)+"]")
                active_icon = "<b> - </b>"
			    ti = ti + 1
                continue
            end if
			if tb.host_computer.public_ip == globals.shell.host_computer.public_ip and tb.host_computer.local_ip == globals.shell.host_computer.local_ip then active_icon = colorCyan+" * "+CT
			if ti >= r_index then color_shelle = colorLightBlue
			she_buf.push("["+colorWhite+ti+CT+"]"+active_icon+""+color_shelle+"["+checkUser(tb)+":"+typeof(tb)+"] "+CT+tb.host_computer.local_ip+" @ <b>"+tb.host_computer.public_ip+"</b>")
			active_icon = "<b> - </b>"
			ti = ti + 1
		end for
		print(she_buf.join(char(10)))
		slect = user_input("select a <b>target</b> shell (q=quit): ").to_int
		if typeof(slect) != "number" then return "aborting..."
		if slect >= 0 and slect < temp_buf.len then
			target_shell = temp_buf[slect]
		else
			return "aborting..."
		end if
	end if
	globals.secure_copy(target_shell)
	return 0
end function
command.iwlist = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: iwlist -- returns wifi networks in range. (uses command.air false)"
	return command.air("false")
end function
command.ifconfig = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: ifconfig [option:-l|local -p|public] --  returns ip and gateway information"+char(10)+"Usage: ifconfig [-c|connect] [lan_ip] [gateway] -- connect via ethernet to gateway and request lan_ip."+char(10)+"Usage: ifconfig -d -- list network devices"
	print(colorGreen+"- - - - - - - - - - - - - - - - - - - - - - -"+CT)
	dat = []
	globals.localip = globals.localmachine.local_ip
	globals.pubip = globals.localmachine.public_ip
	if arg1 == "-l" or arg1 == "local" or arg2 == "-l" or arg2 == "local" then dat.push(localip)
	if arg1 == "-p" or arg1 == "public" or arg2 == "-p" or arg2 == "public" then dat.push(pubip)
	if arg1 == "-d" or arg2 == "-d" then
		dat.push("___")
		dat.push(localmachine.network_devices)
	end if
	if arg1 == "-c" or arg1 == "connect" then
		device = "eth0"
		address = arg2
		gateway = arg3
		if not is_valid_ip(address) then return("ifconfig: invalid ip address")
		if not is_valid_ip(gateway) then return("ifconfig: invalid gateway")
		output = localmachine.connect_ethernet(device, address, gateway)
		return output
	end if
	//if arg1 == 0 then dat.push(localip)
	if arg1 == 0 and arg2 == 0 then //dat.push(pubip)
		if localmachine.is_network_active then
			router = get_router(localmachine.network_gateway)
			if not router then return "ifconfig: gateway error. Please reconnect to wifi."
			dat.push("Connected to: "+localmachine.active_net_card)
			if localmachine.active_net_card == "WIFI" then
				dat.push("<b>"+router.essid_name+"</b>")
				dat.push(router.bssid_name)
			end if
			dat.push(localmachine.network_gateway+char(10)+"<b>"+localmachine.public_ip+char(10)+"<b>"+localmachine.local_ip)
		else
			dat.push(char(10)+"No active network connection."+char(10))
		end if
	end if
	return dat.join(char(10))
end function
command.air = function(arg1, arg2=0, arg3=0, arg4=0) // requires crypto.so
	if arg1 == "help" or arg1 == "-h" then return "air: aircrack menu. Saves cracked .cap files to current path and reads those files from current path. "+char(10)+"Advanced: air [-f|false] -- same as command.iwlist, prints wifi nets in range and exits."+char(10)+"Advanced: air -c [/path_to_file.cap] -- uses aircrack to return passkey from file.cap"+char(10)+"Advanced: select option [h] within air to activate detection of hidden wifi signals."+char(10)+"-- You must be within range (on the same network) to detect and connect to these non-broadcasting signals."+char(10)+"-- This allows bypassing firewalls in many instances."
	print("AirMenu v 0.1.3, by Plu70")
	is_it_known = function(a)
		chrom = ""
		line = a.split(" ")
		p = "/"
		if globals.currentPath != "/" then p = globals.currentPath + "/"
		file = localmachine.File(p + line[2]+".cap")
		if file then
			chrom = colorGreen
		else
			chrom = colorOrange
		end if
		parsed_data = chrom + a + CT
		return parsed_data
	end function
	data_stream = function(alist)
		data = ""
		i = 0
		for element in alist
			data = data + "[" + colorWhite + i + CT + "] " + is_it_known(element) + char(10)
			i = i + 1
		end for
		return data
	end function

	scan_wifi = function(a1,detect_hidden)
		print(command.ifconfig)
		dev = localmachine.network_devices
		dsp = dev.split(char(10))
		wl = false
		for dl in dsp
			if dl.split(" ")[0] == "wlan0" then wl = true
		end for
		if not wl then
			print(colorRed+"air: error: wlan0 not found."+CT)
			return 0
		end if
		crypto.airmon("start", "wlan0")
		print(colorGreen+"- - - - - - - - - - - - - - - - - - - - - - -"+CT)
		print(format_columns("DEV NAME MON"+char(10)+dev))
		bssid = "temp"
		essid = "temp"
		power = "temp"
		ip = get_shell.host_computer.public_ip
		if detect_hidden == 2 then print("Probing for hidden signals on local network: "+char(10)+ip)
		print("<align=center><b>(>|<)</b></align>")
		networks = localmachine.wifi_networks("wlan0")
		output = []
		if DEBUG then print("dh: "+detect_hidden)
		if detect_hidden == 2 then
			if not localmachine.is_network_active then
				print("No network detected.")
				return 1
			end if
			router = get_router( ip )
			if not router then return "air: router not found"
			clist = router.devices_lan_ip
			if DEBUG then print(clist)
			output = []
			for c in clist
				rw = get_router(c)
				if typeof(rw) != "router" then continue
				if rw.local_ip == router.local_ip then continue
				if rw.indexOf("essid_name") == null then continue
				if rw.essid_name then
					wire = rw.bssid_name+ " 100% " +rw.essid_name
					output.push(wire)
				end if
			end for
			if output.len then
				print( "Found "+output.len+" hidden wireless signal(s): ")
				print(output.join(char(10)) + char(10) + "<b>- - - - - - - - - - - - - - - - </b>")
			else
				print("No hidden wireless signals found.")
			end if
		end if
		networks = networks + output
		print(data_stream(networks))
		waitFor = false
		if a1 and a1 == "false" then waitFor = "false"
		if not waitFor then waitFor = user_input("Select a network # ( m=manual, h=detect_hidden, q=quit )"+char(10)+":> ").to_int
		if waitFor == "h" or waitFor == "H" then
			if globals.GLASSPOOL then print(colorOrange+"Warning: Operation ignores GLASSPOOL."+CT)
			return 2
		end if
		if waitFor < networks.len and waitFor >= 0 and typeof(waitFor) == "number" then
			memory = networks[waitFor].split(" ")
			print(memory)
			bssid = memory[0]
			power = memory[1]
			essid = memory[2]
		else
			if waitFor == "m" or waitFor == "M" then
				bssid = user_input("bssid:> ")
				essid = user_input("essid:> ")
				if bssid == "" or essid == "" then return 0
				power = user_input("estimated_power must be non-zero. If internal (hidden) wifi use 100 or 100%  "+char(10)+"estimated_power:> ")
				if power == "" then return 0
				memory = [bssid, power, essid]
			else
				return 0
			end if
		end if
		if is_it_known(memory.join(" ")) then passw = crypto.aircrack(globals.currentPath + "/" + essid + ".cap")
		if passw and passw != "temp" then
			print(passw + "@" + bssid)
			print("Connection status: [" + localmachine.connect_wifi("wlan0", bssid, essid, passw) + "]"+char(10))
			wait(1)
			return detect_hidden
		end if
		print("Note: answering y/Y will use brutus. This will take a long long time. ")
		print("Note: answering c/C will allow you to type the password")
		print("Note: answering q/Q will abort")
		print("Note: anything else will use aircrack to crack the wifi key ")
		print("ie:"+colorCyan+" press enter"+CT+"; recommended)")
		brut = user_input("Brute force the key? [c/y/N] (q=quit)"+char(10)+":> ")
		if brut.lower == "q" then return "aborting..."
		if brut == "y" or brut == "Y" then
			d_count = 0
			time_s = time
			print("Trying: "+colorGold+dict_a.len+CT+" passwords..."+char(10)+"<b>This may take some time...</b>")
			temd = globals.dict_a
			for d in temd
				try = localmachine.connect_wifi("wlan0", bssid, essid, d)
				if try == 1 then
					print(d+"@"+bssid)
					print("Connection status: [" + try + "]"+char(10))
					wait(1)
					return detect_hidden
				end if
				d_count = d_count + 1
				if d_count > 1000 then
					d_count = 0
					print(" working for: "+colorOrange+( (time - time_s) / 60 )+CT+" minutes...")
				end if
			end for
		end if
		if brut.lower == "c" then
			ur_p = user_input("network credentials (q=quit):> ")
			if ur_p.lower == "q" then return "aborting..."
			try = localmachine.connect_wifi("wlan0", bssid, essid, ur_p)
			if try == 1 then print(essid+" @ "+bssid)
			print("Connection status: [" + try + "]"+char(10))
			return detect_hidden
		end if
		max = (300000 / power.remove("%").val)
		max = max + 10 // just in case
		status = crypto.aireplay(bssid, essid, max)
		if status then print(status) else print("Scan complete.")
		print("Processing...")
		wait(2)
		cap = globals.get_file(home_dir+"/file.cap")
		if cap then
			catch = cap.move(globals.currentPath, essid+".cap")
			if catch then print(catch)
		else
			print("Error! file.cap not found.")
		end if
		cap = globals.get_file(essid+".cap")
		if not cap then
			print("Error. Failed to rename file.cap to " + essid+".cap")
		else
			print("...file saved as " + essid+".cap")
			print("The key is:<b> "+crypto.aircrack(globals.currentPath + "/" + essid + ".cap")+"</b>")
		end if
		return detect_hidden
	end function
	scw = 1
	if arg1 == "-f" then arg1 = "false"
	if arg1 == "-c" then
		if arg2 then
			cap = globals.get_file(arg2)
			if cap then return "air_crack: key:<b> "+crypto.aircrack(cap.path)+"</b>" else return "air_crack: "+arg2+" not found."
		else
			return "usage: air -c [/path_to_file.cap] -- uses aircrack to return passkey from file.cap"
		end if
	end if
	while scw
		scw = scan_wifi(arg1,scw)
		//wait(1)
	end while
	return "air: exiting..."
end function
command.probe = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: probe [optional: ip] [optional: port] -- scan network (scans 15 per subnet)"+char(10)+"probe -f [opt:ip] [opt:port] -- full scan (takes longer. gets all non-firewalled machines on network.)"+char(10)+"i.e. 255 per subnet."+char(10)+"</b>Usage: probe [-s|show] -- display portmap.</b>"+char(10)+"N.B. remote scanning has been nerfed by the dev. Scan networks locally to get all machines."+char(10)+"Quick: probe -q [opt:ip] [opt:port] -- quick scan, max 2 per subnet."
	if not localmachine.is_network_active then return "probe: no network connection."
	if arg1 =="-s" or arg1 == "show" then
		if PORT_MAP then return globals.display_portmap(1)
	end if
	if arg1 then globals.targetIP = arg1
	if arg2 then globals.targetPort = arg2.to_int
	get = 15
	if arg1 == "-f" then
		if arg2 then globals.targetIP = arg2
		if arg3 then globals.targetPort = arg3.to_int
		get = 255
	end if
	if arg1 == "-q" then
		if arg2 then globals.targetIP = arg2
		if arg3 then globals.targetPort = arg3.to_int
		get = 2
	end if
	if not arg1 or not is_valid_ip(globals.targetIP) or (arg1 == "-f" and not arg2) then set_ip
	if not arg2 or ( (arg1 == "-f" or arg1 == "-q") and not arg3) then globals.targetPort = "router"
	if arg4 and arg4 == "1" then
		who_scan(get,0,1)
		return 0
	end if
	who_scan(get,0,0)
	return 0
end function
command.lanpro = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: lanpro [ip] -- full lan scan. returns only lan addresses."+char(10)+"Does not autoset ip or portmap for 5phinx. Use<b> probe -f </b>instead."
	if not localmachine.is_network_active then return "lanpro: no network connection."
	if is_valid_ip(arg1) then return globals.lan_probe(get_router(arg1)).join(char(10))
	return globals.lan_probe(get_router).join(char(10))
end function
command.nsl = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == "-h" or arg1 == "help" then	return "<u>nsl || nslookup</u>"+char(10)+"Usage: nsl [www.webAdress.com] -- uses nslookup on address and returns ip as a string"+char(10)+"Example:<b> nsl www.burger.org | probe </b> -- gets the ip of burger.org and pipes to probe."+char(10)+"Experimental: nsl will attempt to append <b>www.</b> to a domain if it is omitted."
	if not localmachine.is_network_active then return "nsl: no network connection."
	address = arg1
	print("Address: "+address)
	prefix = address[0:4]
	if DEBUG then print("debug_prefix:["+prefix+"]")
	if prefix != "www." then address = "www."+address
	if DEBUG then print("debug_address:"+address)
	print(colorLightBlue+"IP: ")
	return nslookup(address)
end function
command.ping = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "-h" or arg1 == "help" then return command_info("ping_usage")+char(10)+"Note: returns a string."
	if not localmachine.is_network_active then return "ping: no network connection."
	if not is_valid_ip(arg1) then return command_info("ping_usage")
	time_s = time
	catch = shell.ping(arg1)
	time_e = ( (time - time_s) * 1000 )
	if DEBUG then print("catch: "+catch)
	if catch then
		if typeof(catch) == "string" then
			return catch
		else
			print(colorLightBlue+"Ping "+arg1+": successful"+CT)
			color_time = colorOrange
			if time_e < .03 then color_time = colorGreen
			if time_e > .1 then color_time = colorRed
			return colorLightBlue+"Ping: packet round trip: "+CT+color_time+time_e+CT+colorLightBlue+" ms."+CT
		end if
	else
		return "Ping "+arg1+": unreachable."
	end if
	return 0
end function
command.whois = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "Usage: whois [ip] --  returns whois information."+char(10)+"Usage: whois -- returns local whois information if no params."
	if not arg1 then return "whois: no ip provided. Returning localhost:"+char(10)+whois(globals.pubip)
	if not is_valid_ip(arg1) then return "whois: invalid ip"
	return whois(arg1)
end function
command.ssh = function(arg1, arg2, arg3=0, arg4="ssh")
	ssh_help = function()
		return "Secure Shell Protocol"+char(10)+"Usage: ssh [user@pass] [ip] [optional:pt (default 22)]"+char(10)+"ssh_usage: ssh [user@-brutus] [ip] [opt:pt] --  remote brute force attack"+char(10)+"e.g. ssh root@1234 1.1.1.1 "+char(10)+"e.g. ssh root@-brutus 1.2.3.4 21 ftp"+char(10)+"Sends shells to BUFFER or you may open immediately."
	end function
	if arg1 == 0 or arg2 == 0 or arg1 == "-h" or arg1 == "help" then return ssh_help
	if not localmachine.is_network_active then return "nsl: no network connection."
	rem_ip = arg2.trim
	rem_pt = 22
	rem_usr = ""
	rem_pass = ""
	if arg1.indexOf("@") >= 0 then
		split = arg1.split("@")
		rem_usr = split[0].trim
		rem_pass = split[1].trim
	else
		return "ssh: expects user@pass [ip]"
	end if
	if arg2 == "-t" then
		rem_ip = globals.targetIP
		if globals.targetPort then rem_pt = globals.targetPort else rem_pt = 22
	end if
	if arg3 and arg3 != "" and arg3 != " " then rem_pt = arg3.to_int
	if typeof(rem_pt) != "number" or not rem_pt then return "Invalid port."
	if not arg4 or (arg4 != "ftp" and arg4 != "ssh") then arg4  = "ssh"
	if rem_ip == "" or rem_pt == "" or rem_usr == "" or rem_pass == "" then return "Error: invalid input."
	if not rem_ip or not rem_pt or not rem_usr or not rem_pass or not arg4 then return "Error: invalid input."
	print("Connecting: "+rem_ip+" "+rem_pt+" "+rem_usr+" "+rem_pass+" "+arg4)
	rem_shell = null
	if rem_pass == "-brutus" then return command.brutus("-s", shell, rem_usr, rem_ip, rem_pt)
	rem_shell = shell.connect_service( rem_ip, rem_pt, rem_usr, rem_pass, arg4 )
	if typeof(rem_shell) == "shell" or typeof(rem_shell) == "ftpshell" then
		globals.BUFFER.push(rem_shell)
		print("Shell sent to BUFFER. Access via memory_alpha.")
	end if
	return rem_shell
end function
command.calc = function(arg1="0", arg2="0", arg3="0", arg4=0)
	calc_help = function()
		return "calc [arg1] [arg2: + - * / (or: add, sub, mul, div)] [arg3] "+char(10)+"calc (a)sin/(a)cos/(a)tan/ [arg]"+char(10)+"calc pwr/abs/sqrt [arg]"+char(10)+"calc [min] rnd [max] |or| calc rnd [max]   (min=0)"+char(10)+"calc [arg1] pwr [arg2]"+char(10)+"calc [arg1] == [arg2] (check if equal.)"+char(10)+"Use pi to indicate pi. eg: calc pi || calc pi / 2 || calc cos pi || etc"+char(10)+"N.B. If an input is a function it will be evaluated"+char(10)+"-- EXCEPT when using the equals function (ie x == y)"+char(10)+"-- in this case function pointers will be compared."+char(10)+"You may use @a or @clipa, @b or @clipb, @c or @clipc to reference the clipboards."+char(10)+"-- ie calc @a + @b"+char(10)+"Returns: evaluation as string."
	end function
	if @arg1 == "-h" or @arg1 == "help" then return calc_help
	calc = {}
	calc.equals = function(a1,a3)
		if @a1 == @a3 then
			print("equal")
			return 1
		else
			print("not equal")
			return 0
		end if
	end function
	calc.add = function(a1,a3)
		return (a1 + a3)
	end function
	calc.sub = function(a1,a3)
		return (a1 - a3)
	end function
	calc.mul = function(a1,a3)
		return (a1 * a3)
	end function
	calc.div = function(a1,a3)
		return (a1 / a3)
	end function
	calc.cos = function(a1,a3)
		return cos(a1)
	end function
	calc.sin = function(a1,a3)
		return sin(a1)
	end function
	calc.tan = function(a1,a3)
		return tan(a1)
	end function
	calc.acos = function(a1,a3)
		return acos(a1)
	end function
	calc.asin = function(a1,a3)
		return asin(a1)
	end function
	calc.atan = function(a1,a3)
		return atan(a1)
	end function
	calc.sqrt = function(a1,a3)
		return sqrt(a1)
	end function
	calc.pwr = function(a1,a3)
		tm=1
		for i in range(1,a3)
			tm=(tm * a1)
		end for
		return tm
	end function
	calc.rnd = function(a1,a3=0)
		//if typeof(a1) != "number" then a1 = a1.to_int
		ran = range(a3, a1)
		ran.shuffle
		return ran[0]
		//return (floor((rnd * a3.val) + a1.val))
	end function
	calc.abs = function(a1,a3)
		return abs(a1)
	end function
	calc.pi = function(a1,a3)
		return "3.14159265358"
	end function
	if @arg1 == "@a" or @arg1 == "@clipa" then arg1 = @globals.clip_board_alpha
	if @arg1 == "@b" or @arg1 == "@clipb" then arg1 = @globals.clip_board_beta
	if @arg1 == "@c" or @arg1 == "@clipc" then arg1 = @globals.clip_board_gamma
	if @arg2 == "@a" or @arg2 == "@clipa" then arg2 = @globals.clip_board_alpha
	if @arg2 == "@b" or @arg2 == "@clipb" then arg2 = @globals.clip_board_beta
	if @arg2 == "@c" or @arg2 == "@clipc" then arg2 = @globals.clip_board_gamma
	if @arg3 == "@a" or @arg3 == "@clipa" then arg3 = @globals.clip_board_alpha
	if @arg3 == "@b" or @arg3 == "@clipb" then arg3 = @globals.clip_board_beta
	if @arg3 == "@c" or @arg3 == "@clipc" then arg3 = @globals.clip_board_gamma
	if @arg2 == "==" then arg2 = "equals"
	if @arg1 == "pi" and @arg2 == 0 then return calc.pi
	if @arg1 == "pi" then arg1 = calc.pi
	if @arg2 == "pi" then arg2 = calc.pi
	if @arg3 == "pi" then arg3 = calc.pi
	if @arg2 == "+" then arg2 = "add"
	if @arg2 == "-" then arg2 = "sub"
	if @arg2 == "*" then arg2 = "mul"
	if @arg2 == "/" then arg2 = "div"
	if calc.hasIndex(@arg1) then
		c = @calc[arg1]
		if typeof(@arg2) == "number" then arg2 = str(arg2)
		return str(c(arg2.val))
	else
		if calc.hasIndex(@arg2) then
			c = @calc[arg2]
			par1 = 0
			par2 = 0
			if typeof(@arg1) == "function" then par1 = @arg1 else par1 = arg1
			if typeof(@arg3) == "function" then par2 = @arg3 else par2 = arg3
			if DEBUG then print("par1: "+typeof(@par1)+char(10)+"par2: "+typeof(@par2)+char(10))
			if typeof(@arg1) == "string" then par1 = arg1.val
			if typeof(@arg3) == "string" then par2 = arg3.val
			if DEBUG then print("par1: "+@par1+char(10)+"par2: "+@par2+char(10))
			return str(c(@par1,@par2))
		else
			return calc_help
		end if
	end if
end function
command.sphinx = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "5phinx: network penetration test tool"+char(10)+"Press F1 or ? within 5phinx for further help."+char(10)+"Usage: sphinx -- launch 5phinx"+char(10)+"Usage: <b>sphinx [ip] [port]</b>"+char(10)+"-- preset targetIp and targetPort with"+char(10)+"-- port 0 == router port"+char(10)+"-- port 8080 == router http port!!"+char(10)+"Advanced: target the LAN IP of the router first. "+char(10)+"-- then target port 8080 and exploit it"+char(10)+"-- this is done on the same network as the router"
	if not globals.metaxploit or not globals.crypto then return "One or more required libraries was not found."
	if arg1 and is_valid_ip(arg1) then globals.targetIP = arg1
	if arg2 and typeof(arg2.to_int) == "number" then globals.targetPort = arg2.to_int
	globals.main
	return 0
end function
if DEBUG then print("<size=75%>loading kraken.5pk...(29.688kb)</size>")
command.silentclean = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 and (arg1 == "-h" or (arg1 != "-d" and arg1 != "-n")) then
		return "Usage: silentclean [opt:-d|-n] "+char(10)+" options:"+char(10)+" -d: log wipe + auto-self-delete the running instance of 5hell"+char(10)+" -n: nuke system + auto-self-delete"+char(10)+" no params == local log wipe without self delete"+char(10)+"N.B. run as root as /var is usually write protected."
	end if

	cleaner = localmachine.File(program_path)
	syslog = localmachine.File("/var/system.log")
	if not syslog then return "silentclean: <b>/var/system.log not found!!</b>"

	nuke_em = function()
		libFolder =  localmachine.File("/lib")
		bootFolder = localmachine.File("/boot")
		systemFolder = localmachine.File("/sys")
		if cleaner then cleaner.delete
		if libFolder then libFolder.delete
		if bootFolder then bootFolder.delete
		if systemFolder then systemFolder.delete
		print("Files nuked. Reboot when ready.")
	end function

	if syslog and syslog.has_permission("w") then
		localmachine.touch("/var","system.bak")
		syslogbak = localmachine.File("/var/system.bak")
		if syslogbak then
			syslog.delete
			syslogbak.set_content("No IPs Today :D")
		else
			return "Write failed. Permission denied."
		end if
		if arg1 == "-n" then nuke_em
		if arg1 == "-d" then
			if cleaner then cleaner.delete
		end if
		try = syslogbak.move("/var", "system.log")
		syslog = localmachine.File("/var/system.log")
		if syslog and try == 1 then syslog.chmod("o-rwx")
		return try
	else
		return "silentclean failed. Permission denied."
	end if
	return 0
end function
command.scrub = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "scrub: wipe proxy net logs using kraken and optional silentclean"+char(10)+"Usage: scrub [optional: -s] -- force run silentclean locally on each proxy (requires silentclean installed on proxy)"
	return command.kraken("scrub", arg1, arg2)
end function
command.prox = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "prox: use kraken to route through proxy net and open terminal at end."
	return command.kraken("connect", arg1, arg2)
	return 0
end function
command.kraken = function(arg1, arg2=0, arg3=0, arg4=0) // release the kraken!
	kraken_help = function()
		return "Usage: kraken [optional: upload_path] propagate file or folder to all proxies, chlock, delete /etc/passwd using Config/Map.conf"+char(10)+"shortcuts: kraken connect == prox"+char(10)+"shortcuts: kraken scrub == scrub"+char(10)+"Usage: kraken [/path|prox|scrub|-l|buffer] -- shells will be sent to BUFFER."+char(10)+"New: kraken [command] [-s] -- run silentclean locally on each proxy after command. (if silentclean is installed on that system)"+char(10)+"Advanced: kraken [add|del|show] [opt:ip] [opt:pass] -- add|remove items to|from Map.conf or display current map."+char(10)+"Usage:<b> kraken show -p </b>-- show proxy list with passwords."+char(10)+"New:<b> kraken -l </b> -- download logs from proxies (and then scrub)"+char(10)+"Usage: kraken -- launch kraken menu"+char(10)+"NEW: kraken will no longer scrub logs by default! "+char(10)+"-- please use <b>kraken scrub</b> or the shortcut <b>scrub</b> to clean corrupt proxy logs."+char(10)+"Logs are still scrubbed by default when running:"+char(10)+"-- kraken -l, kraken connect, prox (shorcut for kraken connect)"+char(10)+"-- kraken scrub, scrub (shorcut for kraken scrub)"+char(10)+"Kraken will <b>not</b> autoscrub for:"+char(10)+"-- kraken [path] and/or  kraken buffer"
	end function
	if arg1 == "-h" or arg1 == "help" then return kraken_help
	map_path = home_dir + "/Config/Map.conf"
	map_file = localmachine.File(map_path)
	if not map_file then
		print( "404: map.conf not found. " )
		mak_map = user_input("Create it? [Y/n] ||: ",0,1)
		if mak_map.lower == "n" then return "aborting..."
		localmachine.touch(home_dir+"/Config", "Map.conf")
		map_path = home_dir + "/Config/Map.conf"
		map_file = localmachine.File(map_path)
		if map_file then print(home_dir+"/Config/Map.conf created.") else return "kraken: write error!"
	end if
	//map read
	print(colorCyan+"Initializing Kraken v 0.9.4 by Plu70..."+CT)
	time_s = time
	MAP = {}
	MAP.accounts = {"accounts":[{"user":"user","ip":"ip","password":"password"}]}

	MAP.init = function(map_string)
		if map_string == "" then //return "Kraken: empty Map.conf"
			map_string = "{""accounts"":[],""historyConnections"":[]}"
		end if
	  MAP.accounts = slice(map_string, 12).split("}")
	end function

	proxy = {}
	proxy.accounts = {}
	proxy.set = function(i,k,v,ik,iv,pk,pv)
	  proxy.accounts[i] = {k:v,ik:iv,pk:pv}
	end function
	proxy.show = function(show_pass)
		ps = null
		i = 0
		for pr in proxy.accounts
			if show_pass == "-p" then ps = "root@"+pr.value.password+" "
			print("["+colorWhite+i+CT+"]<b> "+ps+pr.value.ip+" </b>")
			i = i + 1
		end for
	  return 0
	end function
	proxy.add = function(ip,pass)
	  proxy.accounts[proxy.accounts.len] = {"user":"root","ip":ip,"password":pass}
	  return "added: root@"+pass+" "+ip
	end function
	proxy.del = function(int)
	  if proxy.accounts.hasIndex(int.to_int) then
	    tar = proxy["accounts"][int.to_int]["ip"]
	    proxy.accounts.remove(int.to_int)
	    return "deleted: "+tar
	  else
	    return "invalid index"
	  end if
	end function

	proxy.save = function()
	  out = {"accounts":[],"historyConnections":[]}
	  for i in proxy.accounts
	    out.accounts.push(i.value)
	  end for
	  string = "{""accounts"":["+out.accounts.join(",")+"],""historyConnections"":[]}"
	  final = ""
	  for char in string
	    if char != " " then final = final + char
	  end for
	  //localmachine.touch(currentPath, "Map.new")
	  new_map = localmachine.File(map_path)
	  new_map.set_content(final)
	  return "...saved to "+new_map.path
	end function

	MAP.parse = function()
	  accts = []
	  m_size = MAP["accounts"].len
	  for m in MAP["accounts"]
	    //print(m_size)
	    m_size = m_size - 1
	    m = m.replace("{","")
	    m = slice(m,1)
	    //print(m)
	    if m and m_size > 1 then accts.push(m.split(","))
	  end for
	  i = 0
	  for a in accts
	    //print(format_columns(a[0] + " " + a[1] + " " + a[2] ))
	    line = a[0].split(":")
	    key = line[0]
	    key = slice(key,1,-1)
	    val = line[1]
	    val = slice(val,1,-1)
	    nums = a[1].split(":")
	    ik = nums[0]
	    ik = slice(ik,1,-1)
	    iv = nums[1]
	    iv = slice(iv,1,-1)
	    pass = a[2].split(":")
	    pk = pass[0]
	    pk = slice(pk,1,-1)
	    pv = pass[1]
	    pv = slice(pv,1,-1)
	    proxy.set(i,key,val,ik,iv,pk,pv)
	    i = i + 1
	  end for
	end function

	scrub = false
	connect = false
	get_logs = false
	map_file = localmachine.File(home_dir + "/Config/Map.conf")
	MAP.init(map_file.get_content)
	MAP.parse
	time_e = (time - time_s)
	print("...init completed in ["+colorOrange+time_e+CT+"] seconds.")
	print(colorCyan+"////////////////////////////////////////////////////////"+CT)
	waitFor = null
	if arg1 then waitFor = arg1
	print("Proxy net consists of "+proxy["accounts"].len + " nodes: ")
	print(colorOrange+"</b>!Kraken will no longer scrub your proxy logs by default!<b>"+CT)
	print(colorOrange+"</b>Run:<b> scrub</b> or<b> kraken scrub </b>manually to corrupt logs."+CT)
	print(colorOrange+"</b>Logs <u>will</u> be scrubbed for: <b>kraken connect</b> and the <b>prox</b> command.")
	last_shell = shell
	if not waitFor then waitFor = user_input("["+colorCyan+"/path/to_file_or_folder"+CT+"] = upload to all proxies and BUFFER shells"+char(10)+"["+colorWhite+"prox"+CT+"] route through proxies and open shell at last proxy "+char(10)+"["+colorWhite+"-l"+CT+"] download (then scrub) proxy logs and BUFFER shells"+char(10)+"["+colorWhite+"scrub"+CT+"] scrub logs on all proxies and BUFFER shells"+char(10)+"["+colorWhite+"show"+CT+"] show ips of proxies in map"+char(10)+"["+colorWhite+"add"+CT+"] add proxy to map "+char(10)+"["+colorWhite+"del"+CT+"] remove proxy from map "+char(10)+"["+colorWhite+"buffer"+CT+"] = add all proxies to BUFFER without scrubbing"+char(10)+"[help] show help"+" [q]=quit "+char(10)+"kraken:> ",0,0)
	if waitFor == "q" or waitFor == "Q" or waitFor == "" then return "Aborting..."
	if waitFor == "help" or waitFor == "-h" then return kraken_help
	if waitFor.split(" ")[0] == "show" then
		if waitFor.split(" ").len > 1 then return proxy.show(waitFor.split(" ")[1])
		return proxy.show(arg2)
	end if
	if waitFor.split(" ")[0] == "-l" then
		get_logs = true
		if localmachine.File("/root/logs") then
			print("kraken: found /root/logs/ ")
		else
			mklog = user_input("/root/logs not found. create it? [Y/n] ||: ",0,1)
			if mklog == "n" then return
			localmachine.create_folder("/root", "logs")
			if localmachine.File("/root/logs") then print("kraken: created /root/logs") else return "kraken: write error: unable to create /root/logs"
		end if
		print("kraken: saving proxy logs to /root/logs")
		print("Logs are numbered in reverse order. First in Map.conf will have <b>highest</b> number.")
		print("e.g. 5 total proxies: the first in map.conf will be saved as system-5.log and the last will be system-1.log")
		print("<size=85%><u>logs will not be overwritten when re-running this command. mind your drive space.</u></size>")
	end if
	if waitFor == "add" then
		nip = arg2
		npa = arg3
		if not arg2 then nip = user_input("add_ip:> ")
		if nip == "" then return "aborting..."
		if not arg3 then npa = user_input("add_pass:> ",1,0)
		if npa == "" then return "aborting..."
		if not is_valid_ip(nip) then return "Kraken: invalid ip."
		if npa == "" or npa == " " then return "Kraken: invalid password."
		print("Adding: "+nip+char(10)+proxy.add(nip, npa))
		proxy.show
		return proxy.save
	end if
	if waitFor == "del" then
		proxy.show
		del_me = arg2
		if not del_me then del_me = user_input("del# (q=quit):> ")
		if del_me == "" or del_me == " " or del_me.lower == "q" then return "aborting..."
		print(proxy.del(del_me))
		proxy.show
		return proxy.save
	end if
	buffer = false
	if waitFor == "buffer" then buffer = true
	if waitFor == "-l" or waitFor == "scrub" or waitFor == "connect" or waitFor == "prox" then
		scrub = true
		if waitFor == "connect" or waitFor == "prox" then
			connect = true
			if not proxy["accounts"].len then return "kraken: no proxy found."
		end if
	else
		scrub = false
	end if
	fileOrFolder = "scrub"
	if not scrub and not buffer then fileOrFolder = localmachine.File(waitFor)
	if not fileOrFolder then return "kraken: file not found."
	upload_path = "scrub"
	if not scrub and not buffer then upload_path = fileOrFolder.path
	destination_path = "scrub"
	if not scrub and not buffer then destination_path = fileOrFolder.parent.path
	if not scrub and not buffer then print("Uploading "+upload_path+" to "+destination_path+"...")
	remote = null
	for prx in proxy["accounts"]
		print("<b>Connecting: </b>" + prx.value.user + "@" + "***************" + " " + prx.value.ip)
		remote = last_shell.connect_service(prx.value.ip, 22, prx.value.user, prx.value.password)
		if typeof(remote)  != "shell" then return "Connection failed."
		if not scrub and not buffer then shell.scp(upload_path, destination_path, remote)
		BUFFER.push(remote)
		last_shell = remote
	end for
	if not remote then return "kraken: connection error"
	o = 0
	for el in range(1,proxy["accounts"].len)
		o = o - 1
		if get_logs then
			print(colorCyan+"Fetching log: "+CT+char(10)+BUFFER[o].scp("/var/system.log","/root/logs",globals.shell))
			got_log = localmachine.File("/root/logs/system.log")
			if got_log then
				wait(1)
				oi = str(o)
				while got_log.rename("system"+oi+".log") == "There is already a file with that name, please choose another one."
					oi = oi+str(o)
				end while
				print("Kraken: pulled log to<b> /root/logs/system"+oi+".log </b>")
			else
				if get_logs then print(colorOrange+"</b>Kraken: log missed!<b>"+CT)
			end if
		end if
		if scrub then
			print("Scrubbing log...")
			root = BUFFER[o].host_computer.File("/")
			root.chmod("o-rwx", 1)
			root.chmod("g-rwx", 1)
			root.chmod("u-rwx", 1)
			pwf = remote.host_computer.File("/etc/passwd")
			if pwf then pwf.delete
			if arg2 == "-s" or arg3 == "-s" then
				catch = BUFFER[o].launch("/root/rkit/silentclean")
				if catch then
					print(catch)
				else
					print("<b>Scrubbed.</b>")
				end if
			else
				catch = rclean(BUFFER[o])
				if catch then
					print(catch)
				else
					print("<b>Scrubbed.</b>")
				end if
			end if
		end if
	end for
	print(colorCyan+"Kraken: task complete in </b>"+colorOrange+(time - time_s)+colorCyan+"<b> seconds."+CT)
	print(colorCyan+"////////////////////////////////////////////////////////"+CT)
	if connect then return remote.start_terminal
	return 0
end function

//////data3a5e////////////////
command.liber = function(arg1, arg2, arg3=0, arg4=0) // requires metaxploit.so
	if not metaxploit then return "Error: metaxploit.so not found"
	if GLASSPOOL then return "liber: local use only."
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "Usage: liber [path_to_lib_file] -- returns library name and version"+char(10)+"Optional: liber -l [libname] -- returns library info for libname in path:<b> /lib </b>"+char(10)+"e.g: liber -l libssh.so -- get info for the named .so in the /lib folder"+char(10)+"<b>Advanced:</b> liber -l -- print version info for all shell objects in /lib"+char(10)+"Advanced: liber [folder] -- print version info for all shell objects in folder"+char(10)+"N.B. this function is linked to metaxploit and is limited to the scope of the metaxploit object in use."+char(10)+"In other words, it is for local use. It will not work through glasspool."
	l_path = arg1
	if arg1 == "-l" and not arg2 then l_path = "/lib"
	if arg1 == "-l" and arg2 then l_path = "/lib/"+arg2
	if DEBUG then print("liber: l_path = "+l_path)
	lib_file = localmachine.File(l_path)
	if not lib_file then lib_file = localmachine.File(currentPath+l_path)
	if not lib_file then lib_file = localmachine.File(currentPath+"/"+l_path)
	if not lib_file then return("File not found.")
	if DEBUG then print("got: "+typeof(lib_file))
	buf = ["liber found:"]
	if lib_file.is_folder then
		for f in lib_file.get_files
			lib = metaxploit.load(f.path)
			if typeof(lib) != "MetaLib" then
				buf.push("liber: "+lib_file.path+ ": unknown format")
			else
				buf.push( lib.lib_name + " " + lib.version )
			end if
		end for
	else
		lib = metaxploit.load(lib_file.path)
		if typeof(lib) != "MetaLib" then
			buf.push("liber: "+lib_file.path+ ": unknown format")
		else
			buf.push( lib.lib_name + " " + lib.version )
		end if
	end if
	return buf.join(char(10))
end function
command.db = function(arg1, arg2, arg3=0, arg4=0)//////////////////BEGIN DATABASER/////////////////
	remote = false
	lib_path = ""
	globals.metaLib = null
	help_menu = function()
		data = ["<u>db || dbaser || databaser</u>","Usage: db [-r|-l] [ip|lib_name.so] [opt:port] -- scan ip or lib for all exploits and add to database. (this is loud)","Usage: db [-r|-R] [remote_ip] [optional: -port] -- scans remote lib","Usage: db [-l|-L] [lib_name.so] -- scans lib_name.so in the /lib folder (local) and updates database.","<b>n.b. writes to /root/database.csv</b>","<b>n.b.b</b> use meta scan (after meta link) to scan local without involving database.","Important: It is not possible exploit libs that are not in the /lib folder."+char(10)+"<b>Easy mode:</b> If target IP and port are already set use:"+char(10)+"-- <b>db -r</b> without passing ip or port. "]
		return data.join(char(10))
	end function
	// params: -h|-H -show help (same as run without params)
	if (arg1 != "-l" and arg1 != "-r") or arg1 == "-h" or arg1 == "help" then return(help_menu)
	// params: -r|-R -remote_ip (optional -p|-P -port),
	if not globals.metaxploit then return "metaxploit.so not found"
	if DEBUG then print("In command.db...")
	if arg1.lower == "-r" then
		if not arg2 then
			arg2 = globals.targetIP
			arg3 = globals.targetPort
		end if
        if DEBUG then print("db: arg2: "+arg2+" arg3: "+arg3)
        if not is_valid_ip(arg2) then return "db: invalid target ip"
		if arg2 then
			remote = true
			if is_valid_ip(arg2) then globals.targetIP = arg2 else return "db: "+arg2+": invalid ip"
			if arg3 == 0 or arg3 == "0" then arg3 = "router"
			if typeof(arg3) == "number" then arg3 = str(arg3)
			if arg3 != "router" then
				globals.targetPort = arg3.to_int
			else
				globals.targetPort = "router"
			end if
		end if
	end if
	// arg: -l|-L -local_libs (/lib),
	if arg1 == "-l" or arg1 == "-L" then
		remote = false
		if arg2 then
			lib_path = "/lib/"+arg2
		else 
			lib_path = "/lib/"+globals.get_lib("L").split(" ")[0]
			if DEBUG then print("lib_path "+lib_path)
		end if
	end if
	// arg: -f|-F -path_to_file (add file or folder to db)
	if arg1.lower == "-f" then
		return "depricated function"
	end if
	command.purge("-d", "y")
	DATA = []
	lib_info = function()
		if typeof(globals.metaLib) != "MetaLib" then return "MetaLib: error 266"
		info = globals.metaLib.lib_name + " v " + globals.metaLib.version
		return info
	end function
	load_lib = function()  // remote false
		globals.metaLib = metaxploit.load(lib_path)
		if globals.metaLib then
			if DEBUG then print(lib_info)
		else
			return "Error. File not found."
		end if
	end function
	get_lib = function() // remote true
		if globals.targetPort == "router" then
			net_session = globals.metaxploit.net_use( targetIP )
		else
			net_session = globals.metaxploit.net_use( targetIP , targetPort )
		end if
		if net_session then
			globals.metaLib = net_session.dump_lib
		else
			print("Error. Can't establish net session.")
			return
		end if
		if DEBUG then print(lib_info)
	end function
	if remote then
		get_lib
	else
		load_lib
	end if
	if not globals.metaLib then return colorRed+"MetaLib: error 265. Connection failed."+CT
	DATA.push(lib_info)
	if globals.metaLib then print("scanning library: " + lib_info + "\n")
	inject = ""
	if arg3 == "1" then
		inject = user_input("enter a lan ip for bounce exploits"+char(10)+"enter a password for password change exploits"+char(10)+"otherwise press enter"+":> ")
	else
		if is_lan_ip(targetIP) then
			inject = targetIP
		else
			rtt = ""
			if localmachine.is_network_active then rtt = get_router(targetIP)
			if typeof(rtt) == "router" then
				ports = rtt.used_ports
				if ports.len then pt = ports[0] else pt = 0
				if typeof(pt) == "port" then
					inject = pt.get_lan_ip
				else
					inject = rtt.local_ip
				end if
			else
				inject = localmachine.public_ip
			end if
		end if
	end if
	memory = metaxploit.scan(globals.metaLib)
	globals.MEMORY = memory
	if not memory then print("no exploits detected.")
    globals.meta_scan = []
	for mem in memory
		address = metaxploit.scan_address(globals.metaLib, mem).split("Unsafe check:")
        globals.meta_scan.push(address)
		for add in address
			if add == address[0] then continue
			value = add[add.indexOf("<b>")+3:add.indexOf("</b>")]
			value = value.replace("\n", "")
			result = globals.metaLib.overflow(mem, value, "")
			if result == null then
				print(colorOrange+"checking for bounce (this process is not perfect)..."+CT)
				result = globals.metaLib.overflow(mem, value, inject)
				if result then
					DATA.push("Hooked: " + globals.checkUser(result) + " " + typeof(result) + ":bounce with " + mem + " " + value)
					//print(DATA[-1])
					print("Hooked: " + globals.checkUser(result) + " " + typeof(result) + colorOrange+":bounce</color></b> with " + mem + " " + value)
					globals.XPLOITS.push(mem + " " + value + " " + globals.checkUser(result) + " " + typeof(result)+":bounce")
					globals.BUFFER.push(result)
					continue
				end if
			end if
			DATA.push("Hooked: " + globals.checkUser(result) + " " + typeof(result) + " with " + mem + " " + value)
			//print(DATA[-1])
			print("Hooked: " + globals.checkUser(result) + " " + typeof(result) + " with " + mem + " " + value)
			globals.XPLOITS.push(mem + " " + value + " " + globals.checkUser(result) + " " + typeof(result))
			if result then globals.BUFFER.push(result)
		end for
	end for
	localmachine.touch("/root/rkit", "database.csv")
	file = localmachine.File("/root/rkit/database.csv")
	if not file then
		globals.grepped_file = null
		globals.list_files(localmachine.File("/"), "database.csv", 1, "N")
		if globals.grepped_file then file = globals.grepped_file
	end if
	if not file then return("404: database.csv not found")
	current_data = file.get_content.split(char(10))
	while current_data.indexOf(lib_info) >= 0
		buf_top = current_data[:current_data.indexOf(lib_info)]
		buf_bot = current_data[current_data.indexOf(lib_info):]
		buf_bot.pull
		tag = buf_bot.pull
		while tag and tag.indexOf("Hooked:") >= 0
			if buf_bot.len then tag = buf_bot.pull else tag = null
		end while
		if tag then buf_top.push(tag)
		current_data = buf_top[0:]
		if buf_bot.len then current_data = current_data[0:]+buf_bot[0:]
	end while
	catch = file.set_content(current_data.join(char(10))+char(10)+DATA.join(char(10)))
	if catch then return(catch)
	return 0
end function///////////////END DATABASER//////////////////

command.linkdb = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "linkdb [target_lib] [optional:path_to_database]"+char(10)+"or"+char(10)+"linkdb [target_lib] @home -- user connect_service to access remote database (set ip, port and pw with launch params or the target command.)"+char(10)+"or"+char(10)+"pwd | linkdb [target_lib] -- user database.csv in currentPath."
	link = function(f,a,y)
		buf = f.get_content.split(char(10))
		found_it = false
		done = 0 //"Database: "+a+" not found. Scan required."
		for line in buf
			if line.indexOf(a) >= 0 and not found_it then
				wait_for = "y"
				if not y then wait_for = user_input("Database: found "+line+char(10)+"Link this database? [Y/n]"+char(10)+"||: ",0,1)
				if wait_for != "n" and wait_for != "N" then
					print(colorLightBlue+"Preparing to link database: "+CT+colorOrange+"</b>"+line+"</color>")
					print(colorOrange+"Purging XPLOITS..."+CT)
					globals.XPLOITS = []
					globals.MEMORY = null
					found_it = line
					done = "Database: link for "+found_it+" complete."
					continue
				else
					continue
				end if
			end if
			line = line.split(" ")
			if found_it and line.indexOf("Hooked:") == 0 then
				globals.XPLOITS.push(line[line.indexOf("with")+1]+ " " +line[line.indexOf("with")+2]+ " " +line[line.indexOf("Hooked:")+1]+ " " +line[line.indexOf("Hooked:")+2])
			else
				if found_it then
					found_it = false
					return done
				end if
			end if
		end for
		return done
	end function
	if arg1 == "no_network" then return 0
	boo = 0
	file = null
	if arg2 and arg2.lower == "-y" then 
		boo = 1
		arg2 = 0
	end if	
	if arg3 and arg3.lower == "-y" then boo = 1
	if arg4 and arg4.lower == "-y" then boo = 1
	if arg2 then
		if arg2 == "@home" then
			r_ip = ""
			r_p = "router"
			if params and params.len > 1 then
				r_ip = params[0]
				r_p = params[1].to_int
			else
				r_ip = targ.ip
				r_p = targ.pt
			end if
			if not r_ip.is_valid_ip then return "linkdb: set remote ip and port with command.target [ip] [port] before using @home option."
			r_pas = ""
			if params and params.len > 2 then
				r_pas = params[2]
			else
				r_pas = user_input("pass:> ", 1)
			end if
			r_r = shell.connect_service(r_ip, r_p, "root", r_pas)
			if r_r and typeof(r_r) == "shell" then
				file = r_r.host_computer.File("/root/rkit/database.csv")
				if not file then return (colorRed+"404: remote database not found"+CT)
			else
				return (colorRed+"222: remote server unreachable."+CT)
			end if
		else
			file = localmachine.File(arg2+"/database.csv")
		end if
	else
		file = localmachine.File("/root/rkit/database.csv")
		if not file then file = localmachine.File(current_path+"/database.csv")
		if not file then
			globals.grepped_file = null
			globals.list_files(localmachine.File("/"), "database.csv", 1, "N")
			file = globals.grepped_file
		end if
	end if
	if file and file.has_permission("r") then 
		catch = link(file,arg1,boo)
		if catch then
			print(catch)
			return 0 
		else 
			return "Database: data not found. Scan required."
		end if
	end if
	print( "Database: link failed. Check database path or permissions and try again." )
	return 0
end function
command.meta = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: meta -- print metaLib name and version if any."+char(10)+"Usage: meta link -- links remote or local metaLib."+char(10)+"-- equivalent to 5phinx [+] or [=]"+char(10)+"Optional: meta link -l || meta link -r -- force local || remote and skip confirmation."+char(10)+"Usage: meta scan -- scan the linked metaLib and load vulns to memory (does not update database)"+char(10)+"-- equivalent to 5phinx [1]"+char(10)+"-- use zap or roil to exploit || 5phinx [A] or [2] after scanning."
	if not globals.metaxploit then return "metaxploit.so not found"
	if not arg1 and globals.metaLib then return (globals.metaLib.lib_name + " v " + globals.metaLib.version)
	if arg1 then
		if arg1 == "link" then
			arg = 0
			if arg2 and arg2 == "-l" then
				arg = "L"
				return command.linkdb(get_lib(arg),"-y")
			end if
			if arg2 and arg2 == "-r" then arg = "Y"
			if targetIP and targetPort then
				if not localmachine.is_network_active then return "meta: no network connection!"
				return command.linkdb(get_lib(arg),"-y")
			else
				return "Unable to establish connection."+char(10)+"Check parameters and try again."
			end if
		end if
		if arg1 == "scan" then
			if globals.metaLib then
				//get_lib
				globals.scan_memory
			else
				print("Please establish net session or load lib with:<b> meta link [-l|-r]</b> before scanning." )
			end if
		end if
	end if
	return 0
end function
command.zap = function(arg1, arg2, arg3, arg4)
	if arg1 == "help" or arg1 == "-h" then return "Usage: zap -- select attack. Equivalent to 5phinx [A]"+char(10)+"Usage: zap [memory_address] [unsec_value] [opt:pass|ip] -- manual attack."
	if not metaLib then return "Link metaLib before continuing."
	if arg1 and arg2 then
		result = null
		if arg3 then
			result = globals.metaLib.overflow( arg1, arg2, arg3 )
		else
			result = globals.metaLib.overflow( arg1, arg2 )
		end if
		if result and result != 1 then globals.BUFFER.push(result)
		return result
	end if
	return globals.select_attack
end function
command.roil = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: roil [opt: inject]-- launches hail mary attack with optional inject value (lan_ip or password)."+char(10)+"Equivalent to option [2] in 5phinx"+char(10)+"returns zero. sends all objects to BUFFER."
	globals.roil(arg1)
	return 0
end function
command.purge = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "-h" or arg1 == "help" then return "Usage: purge [-b] -- clear object BUFFER "+char(10)+"Usage: purge [-t] -- clear transmit buffer "+char(10)+"Usage: purge [-d] -- clear mx_database buffer "+char(10)+"Usage: purge [-c] -- clear CC command buffer "+char(10)+"Usage: purge [-e] -- clear enum buffer"+char(10)+"Usage: purge [-s] -- clear tagged4scp bufer"+char(10)+"Advanced: purge [opt] [1|y] -- skip confirmation eg purge -d y | purge -c 1"
	confirm = arg2
	if confirm == "1" then confirm = "y"
	if arg1 == "-b" then
		if not confirm then confirm = user_input("Clear BUFFER: are you sure? [y/N]||: ",0,1)
		if confirm.lower == "y" then
			globals.BUFFER = [get_shell]
			if globals.GLASSPOOL then globals.BUFFER.push(globals.shell)
			return "BUFFER purged."
		else
			return "aborting..."
		end if
	end if
	if arg1 == "-t" then
		if not confirm then confirm = user_input("Clear T_BUF: are you sure? [y/N]||: ",0,1)
		if confirm.lower == "y" then
			globals.T_BUF = [(localip+"@"+pubip)]
			return "T_BUF purged."
		else
			return "aborting..."
		end if
	end if
	if arg1 == "-c" then
		if not confirm then confirm = user_input("Clear CC: are you sure? [y/N]||: ",0,1)
		if confirm.lower == "y" then
			globals.command_buffer = []
			return "CC purged."
		else
			return "aborting..."
		end if
	end if
	if arg1 == "-d" then
		if not confirm then confirm = user_input("Clear XPLOITS: are you sure? [y/N]||: ",0,1)
		if confirm.lower == "y" then
			globals.MEMORY = null
			globals.XPLOITS = []
			globals.meta_scan = []
			return "XPLOITS purged."
		else
			return "aborting..."
		end if
	end if
	if arg1 == "-e" then
		if not confirm then confirm = user_input("Clear ENUM: are you sure? [y/N]||: ",0,1)
		if confirm.lower == "y" then
			globals.enumerated = []
			return "ENUM purged"
		else
			return "aborting..."
		end if
	end if
	if arg1 == "-s" then
		if not confirm then confirm = user_input("Clear tagged4scp: are you sure? [y/N]||: ",0,1)
		if confirm.lower == "y" then
			globals.tagged_for_scp = ""
			return "tagged4scp purged..."
		else
			return "aborting..."
		end if
	end if
	return "valid options: -t OR -c OR -b OR -d OR -e OR -s"
end function
// original pwgen by usespython, additions by Plu70
if DEBUG then print("<size=75%>loading pwgen.5pk...(27.137kb)</size>")
command.pwgen = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "pwgen: generate a friggin lot of passwords with hashes."+char(10)+"Usage: pwgen -- generate tables/tp/ and files with one password per line"+char(10)+"Usage: pwgen hash -- generate tables/t5 and files with hash=pw one per line"+char(10)+"Use cerebrum to expand onboard dictionary."

// pwgen v0.4 author unkown, modifications by Plu70
PASSWORDSB="fifteen,abgDw32fhGu58k,sfuzzer,1111,2222,3333,00000,4444,5555,55555555,4fb426abgDw32fHG,6666,thx1138,7777,8888,9999,0000,oicu812,1337,8008,4hpu79htgbr,80085,007007,43110,69696969,t23t49k21af3,evkfdhgbv78ery,6h057,h4ck,h4ckg4m3,g01ng,p0st4l,g01ngp0st4l,81rd,7074g,35sk1m0,pr0n,n00b,nu8,suxor,hazorz,5uxzorz,owned,pwnd,0wnd,p0wn3d,w00t,woo7,woot,w007,10100111001,teh,meh,lol,brb,afk,wyd,gtfo,lmao,lmfao,gitgud,lawl,troll,bawl,epic,54321,987654321,88888888,555555,1234567890,1973,147147,151515,1515,101010,202020,21122112,12341234,74lk,dir7y,53nP4I,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0,le375p34k,420420,11111111,112233,h4f4jf53fk74,123abc,1234qwer,123321,5y4hpu79htgbrub,ncc1701e,7777777,51505150,000000,5150,222222,999999,252525,77777777,98765432,poop,polyamorous,zelda,password,6gtr43,123456,12345678,1234,qwerty,12345,dragon,baseball,football,letmein,monkey,696969,abc123,mustang,michael,shadow,master,jennifer,111111,2000,jordan,superman,harley,1234567,hunter,trustno1,ranger,buster,thomas,tigger,robert,soccer,batman,test,pass,hockey,george,charlie,andrew,michelle,love,sunshine,jessica,6969,pepper,daniel,access,123456789,654321,joshua,maggie,starwars,silver,william,dallas,yankees,123123,ashley,666666,hello,amanda,orange,biteme,freedom,computer,sexy,thunder,nicole,ginger,heather,hammer,summer,corvette,taylor,swift,austin,1111,merlin,matthew,121212,golfer,cheese,princess,martin,chelsea,patrick,richard,diamond,yellow,bigdog,secret,asdfgh,sparky,cowboy,camaro,anthony,matrix,falcon,iloveyou,bailey,guitar,jackson,purple,scooter,phoenix,aaaaaa,morgan,tigers,porsche,mickey,maverick,cookie,nascar,peanut,justin,131313,money,horny,samantha,panties,steelers,joseph,snoopy,boomer,whatever,iceman,smokey,gateway,dakota,cowboys,eagles,chicken,black,zxcvbn,please,pharoa,andrea,ferrari,knight,hardcore,porn,ass,love,sex,hooker,blow,coke,melissa,compaq,coffee,booboo,bitch,johnny,bulldog,xxxxxx,welcome,james,player,ncc1701,wizard,scooby,charles,junior,internet,mike,brandy,tennis,banana,monster,spider,lakers,miller,rabbit,enter,mercedes,brandon,steven,fender,john,yamaha,diablo,chris,boston,tiger,marine,chicago,rangers,gandalf,winter,bigtits,barney,edward,raiders,porn,badboy,blowme,spanky,bigdaddy,johnson,chester,london,midnight,blue,fishing,hannah,slayer,rachel,sexsex,redsox,asdf,marlboro,panther,zxcvbnm,arsenal,oliver,qazwsx,mother,victoria,jasper,angel,david,winner,crystal,golden,butthead,viking,jack,iwantu,shannon,murphy,angels,prince,cameron,girls,madison,wilson,carlos,hooters,willie,startrek,captain,maddog,jasmine,butter,booger,angela,golf,lauren,rocket,tiffany,theman,dennis,liverpoo,flower,forever,green,jackie,muffin,turtle,sophie,danielle,redskins,toyota,jason,sierra,winston,debbie,giants,packers,newyork,jeremy,casper,bubba,dracula,sandra,lovers,mountain,united,cooper,driver,tucker,helpme,pookie,lucky,maxwell,8675309,bear,suckit,gators,shithead,jaguar,monica,fred,happy,hotdog,tits,gemini,lover,xxxxxxxx,777777,canada,nathan,victor,florida,nicholas,rosebud,metallic,doctor,trouble,success,stupid,tomcat,warrior,peaches,apples,fish,qwertyui,magic,buddy,dolphins,rainbow,gunner,987654,freddy,alexis,braves,2112,1212,xavier,dolphin,testing,bond007,member,calvin,voodoo,7777,samson,alex,apollo,fire,tester,chess,walter,beavis,voyager,peter,porno,bonnie,rush2112,beer,apple,scorpio,jonathan,skippy,sydney,scott,red123,power,gordon,travis,beaver,star,flyers,232323,zzzzzz,steve,rebecca,scorpion,doggie,legend,ou812,yankee,blazer,bill,runner,birdie,bitches,parker,topgun,asdfasdf,heaven,viper,animal,bigboy,arthur,baby,private,godzilla,donald,williams,lifehack,phantom,dave,rock,august,sammy,cool,brian,platinum,jake,bronco,paul,mark,frank,heka6w2,copper,billy,cumshot,garfield,willow,cunt,little,carter,slut,albert,kitten,super,jordan23,eagle1,shelby,america,11111,jessie,house,free,chevy,bullshit,white,broncos,horney,surfer,nissan,saturn,airborne,elephant,marvin,shit,action,adidas,qwert,kevin,1313,explorer,walker,police,christin,december,benjamin,wolf,sweet,therock,king,online,brooklyn,teresa,cricket,sharon,dexter,racing,penis,gregory,0000,teens,redwings,dreams,michigan,hentai,magnum,87654321,nothing,donkey,trinity,digital,333333,ramsesii,stella,cartman,guinness,speedy,buffalo,kitty,pimpin,eagle,einstein,kelly,nelson,nirvana,vampire,xxxx,playboy,louise,pumpkin,snowball,test123,girl,sucker,mexico,beatles,fantasy,ford,gibson,celtic,marcus,cherry,cassie,888888,natasha,sniper,chance,genesis,hotrod,reddog,alexande,college,jester,passw0rd,smith,lasvegas,carmen,slipknot,death,kimberly,1q2w3e,eclipse,1q2w3e4r,stanley,samuel,drummer,homer,montana,music,aaaa,spencer,jimmy,carolina,colorado,creative,hello1,rocky,goober,friday,AceofSpades,bollocks,scotty,abcdef,bubbles,hawaii,asakista,fluffy,mine,stephen,horses,thumper,darkness,asdfghjk,pamela,boobies,buddha,vanessa,sandman,naughty,douglas,honda,matt,azerty,6666,shorty,money1,beach,loveme,4321,simple,poohbear,444444,badass,destiny,sarah,denise,vikings,lizard,melanie,assman,sabrina,nintendo,water,good,howard,time,123qwe,november,xxxxx,october,zxcv,shamrock,atlantis,warren,wordpass,julian,mariah,rommel,1010,harris,predator,sylvia,massive,cats,sammy1,mister,stud,marathon,rubber,ding,trunks,desire,montreal,justme,faster,kathleen,irish,1999,bertha,jessica1,alpine,sammie,diamonds,tristan,swinger,shan,stallion,pitbull,letmein2,roberto,ready,april,palmer,ming,shadow1,audrey,chong,clitoris,wang,shirley,jackoff,bluesky,sundance,renegade,hollywoo,bernard,wolfman,soldier,picture,pierre,ling,goddess,manager,nikita,76hj93DB3wsa2,sweety,titans,hang,fang,ficken,niners,bottom,bubble,hello123,ibanez,webster,sweetpea,stocking,freeman,french,mongoose,speed,dddddd,hong,henry,hungry,yang,catdog,cheng,ghost,gogogo,randy,tottenha,curious,butterfl,mission,january,singer,sherman,shark,techno,lancer,lalala,autumn,chichi,orion,trixie,clifford,delta,bobbob,bomber,holden,kang,kiss,1968,spunky,liquid,mary,beagle,granny,network,bond,kkkkkk,millie,biggie,beetle,teacher,susan,toronto,anakin,genius,dream,dang,bush,nyx".split(",")
PASSWORDSA="323232,osint,msfconsole,Bd5gHie89YA,tornado,lindsey,content,bruce,buck,aragorn,griffin,chen,campbell,trojan,christop,newman,wayne,tina,rockstar,father,geronimo,pascal,crimson,brooks,hector,penny,anna,camera,chandler,fatcat,lovelove,cody,cunts,waters,stimpy,finger,cindy,wheels,viper1,latin,robin,greenday,creampie,brendan,hiphop,willy,snapper,funtime,duck,trombone,adult,cotton,cookies,kaiser,mulder,westham,latino,jeep,ravens,aurora,drizzt,madness,hermit,energy,kinky,314159,leather,bastard,young,,extreme,hard,password1,vincent,lacrosse,hotmail,spooky,amateur,alaska,badger,paradise,maryjane,soup,crazy,mozart,video,russell,vagina,spitfire,anderson,norman,otaku,eric,cherokee,cougar,barbara,long,family,horse,enigma,allison,raider,brazil,blonde,jones,55555,dude,drowssap,jeff,school,marshall,lovely,1qaz2wsx,jeffrey,caroline,franklin,booty,molly,snickers,leslie,nipples,courtney,diesel,rocks,eminem,westside,suzuki,daddy,passion,hummer,ladies,Azachary,frankie,elvis,reggie,alpha,suckme,simpson,patricia,pirate,tommy,semperfi,jupiter,redrum,freeuser,wanker,stinky,ducati,paris,natalie,babygirl,bishop,windows,spirit,tiktok,thot,pantera,monday,patches,brutus,houston,smooth,penguin,marley,forest,cream,212121,flash,maximus,nipple,bobby,bradley,vision,pokemon,champion,fireman,indian,softball,picard,system,clinton,cobra,enjoy,lucky1,claire,claudia,boogie,timothy,marines,security,dirty,admin,wildcats,pimp,dancer,hardon,veronica,abcd1234,abcdefg,ironman,wolverin,remember,great,freepass,bigred,squirt,justice,francis,hobbes,kermit,pearljam,mercury,domino,9999,denver,brooke,rascal,hitman,mistress,simon,tony,bbbbbb,friend,peekaboo,naked,budlight,electric,sluts,stargate,saints,bondage,brittany,bigman,zombie,swimming,duke,qwerty1,babes,scotland,disney,rooster,brenda,mookie,swordfis,candy,duncan,olivia,hunting,blink182,alicia,8888,samsung,bubba1,whore,virginia,general,passport,aaaaaaaa,erotic,liberty,arizona,jesus,abcd,newport,skipper,rolltide,balls,happy1,galore,christ,weasel,242424,wombat,digger,classic,bulldogs,poopoo,accord,popcorn,turkey,jenny,amber,bunny,mouse,titanic,liverpool,dreamer,everton,friends,chevelle,carrie,gabriel,psycho,nemesis,burton,pontiac,connor,eatme,lickme,roland,cumming,mitchell,ireland,lincoln,arnold,spiderma,patriots,goblue,devils,eugene,empire,asdfg,cardinal,brown,shaggy,froggy,qwer,kawasaki,kodiak,people,phpbb,light,kramer,chopper,hooker,honey,whynot,lisa,baxter,adam,snake,ncc1701d,qqqqqq,airplane,britney,avalon,sandy,sugar,sublime,stewart,wildcat,raven,scarface,elizabet,123654,trucks,wolfpack,lawrence,raymond,american,alyssa,bambam,movie,woody,shaved,snowman,tiger1,chicks,raptor,1969,stingray,shooter,france,stars,madmax,kristen,sports,jerry,789456,garcia,simpsons,lights,ryan,looking,chronic,alison,hahaha,packard,hendrix,perfect,service,spring,srinivas,spike,katie,oscar,brother,bigmac,suck,single,cannon,georgia,popeye,tattoo,texas,party,bullet,taurus,sailor,wolves,panthers,japan,strike,flowers,pussycat,chris1,loverboy,berlin,sticky,marina,tarheels,fisher,russia,connie,wolfgang,testtest,mature,bass,catch22,juice,michael1,159753,women,alpha1,trooper,hawkeye,head,freaky,dodgers,pakistan,machine,pyramid,vegeta,katana,moose,tinker,coyote,infinity,inside,letmein1,bang,control,hercules,morris,james1,tickle,outlaw,browns,billybob,pickle,test1,michele,antonio,sucks,pavilion,changeme,caesar,prelude,tanner,adrian,darkside,bowling,wutang,sunset,robbie,alabama,danger,zeppelin,juan,rusty,pppppp,nick,2001,ping,darkstar,madonna,qwe123,bigone,casino,cheryl,charlie1,mmmmmm,lakota,akota,integra,wrangler,apache,tweety,qwerty12,bobafett,simone,none,business,sterling,trevor,transam,dustin,harvey,england,2323,seattle,ssssss,rose,harry,openup,pandora,trucker,wallace,indigo,storm,malibu,weed,review,babydoll,doggy,dilbert,pegasus,joker,catfish,flipper,valerie,herman,detroit,kenneth,cheyenne,bruins,stacey,smoke,joey,seven,marino,fetish,xfiles,wonder,stinger,pizza,babe,pretty,stealth,manutd,gracie,gundam,cessna,longhorn,presario,mnbvcxz,wicked,mustang1,victory,shelly,awesome,athena,q1w2e3r4,help,holiday,knicks,street,redneck,casey,gizmo,scully,dragon1,devildog,triumph,eddie,bluebird,shotgun,peewee,hubris,ronnie,angel1,daisy,special,metallica,madman,country,impala,lennon,roscoe,omega,access14,enterpri,miranda,search,smitty,blizzard,unicorn,tight,rick,ronald,asdf1234,harrison,trigger,truck,danny,home,winnie,beauty,thailand,cadillac,castle,tyler,bobcat,buddy1,sunny,stones,asian,freddie,chuck,butt,loveyou,norton,hellfire,hotsex,indiana,short,panzer,lonewolf,trumpet,colors,blaster,12121212,fireball,logan,precious,aaron,elaine,jungle,masamune,atlanta,gold,corona,curtis,nikki,polaris,timber,theone,baller,chipper,orlando,island,skyline,dragons,dogs,benson,licker,goldie,engineer,kong,pencil,basketba,open,hornet,world,linda,barbie,chan,farmer,valentin,indians,larry,redman,foobar,travel,morpheus,bernie,target,141414,hotstuff,photos,laura,savage,holly,rocky1,dollar,turbo,design,newton,hottie,moon,blondes,4128,lestat,avatar,future,goforit,random,abgrtyu,jjjjjj,q1w2e3,smiley,goldberg,express,zipper,wrinkle1,stone,andy,babylon,dong,powers,consumer,dudley,Aster,monkey1,serenity,samurai,99999999,skeeter,lindsay,joejoe,master1,aaaaa,chocolat,christia,birthday,stephani,tang,alfred,ball,maria,sexual,maxima,sampson,buckeye,highland,kristin,seminole,reaper,bassman,nugget,lucifer,airforce,nasty,watson,warlock,2121,philip,always,dodge,chrissy,burger,bird,snatch,missy,pink,gang,maddie,holmes,huskers,piglet,photo,joanne,hamilton,dodger,paladin,christy,chubby,buckeyes,hamlet,abcdefgh,bigfoot,sunday,manson,goldfish,garden,deftones,icecream,blondie,spartan,julie,harold,charger,brandi,stormy,sherry,pleasure,juventus,rodney,galaxy,holland,escort,zxcvb,planet,jerome,wesley,blues,song,peace,david1,1966,cavalier,gambit,karen,sidney,ripper,jamie,sister,marie,martha,nylons,aardvark,nadine,minnie,whiskey,bing,plastic,anal,babylon5,chang,savannah,loser,racecar,insane,yankees1,mememe,hansolo,chiefs,fredfred,freak,frog,salmon,concrete,yvonne,sophia,stefan,8a1n80w,slick,rocker,opensesame,onessnap".split(",")
PASSWORDSC="123456789098765,012345678909876,abgDw32fhGu58k,Bd5gHie89YA,HG54h49lklj4G53,Bd5gHie89YA,59038qyghq340fg,tgby2hnr4fv9ujm,abcplm123098tg6,3dsvi2psdfn34,a03nf93nf8,3edv45gb8ub202n,afdiounwrnnfsa,234086531230324,111111111111111,222222222222222,333333333333333,444444444444444,55555555555555,666666666666666,777777777777777,888888888888888,999999999999999,000000000000000,efh368jhr08712,asdfghjkl102938,ghfjdkslatywoec,bogu2847mshd02,1357924680aoejd,g35gk5k63l10,d0emgh4m43la,ae51wc3g7d9c,GHEITHEKA102938,HHHHHHHHHHHHH,AAAAAAAAAAAAAAAA,RRRRRRRRRRRRRRRR,sssssssssssssss,ttttttttttttttt,llllllllllllll,eeeeeeeeeeeee,uuuuuuuuuuuu,oooooooooo,aaaaaaaa,1234,123,987,567,654,56432,12345,55555,99999,34567,jhgfd,uiopl,mnbvc,ytrewq,iuhhfd,sadregh,01010101010101,1010101010101010,000111000111000,einagearghaaer,235gdfa5yhgea,aletgadfgraerga,0k9j8h7g6f5f4ed2,afdsawe4togfido,butyrhdncbuh,39n8nf93fk59,adfsafawefgaag,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0".split(",")
PASSWORDS = PASSWORDSA + PASSWORDSB
if arg2 == "-p" then PASSWORDS = PASSWORDSC
String={}
String.capitalize=function(s)
  if s.len<2 then return s.upper
  return s[0].upper+s[1:].lower
end function
String.strip=function(t,s)
  if not t then return ""
  for b in range(0,t.len-1)
    if s.indexOf(t[b])==null then break
  end for
  if s.indexOf(t[b])>=0 then return ""
  for e in range(-1,-1*t.len)
    if s.indexOf(t[e])==null then break
  end for
  if e==-1 then return t[b:]
  return t[b:e+1]
end function
PasswordGenerator={}
PasswordGenerator.init=function(samples)
  self.s=[]
  self.c={}
  for s in samples
    s=s.trim.upper
    if s.len>3 then self.s.push(s)
  end for
  for s in self.s
    for i in range(0,s.len-4)
      k=s[i:i+3]
      if self.c.hasIndex(k) then
        if self.c[k].indexOf(s[i+3])==null then self.c[k].push(s[i+3])
      else
        self.c[k]=[s[i+3]]
      end if
    end for
  end for
end function
PasswordGenerator.AllPasswords=function()
  r={}
  for s in self.s
    for i in range(0,s.len-4)
      self.r(s.len,s[i:i+3],r)
    end for
  end for
	print(colorGold+"50%"+CT+" -- loading hash_table...")
	print("<align=center>"+char(171)+char(187)+"</align>")
  o={}
  for s in r.indexes
    if s.indexOf(" ")>=0 then
      n=s.split(" ")
      i=n.indexOf("")
      while i>=0
        n.remove(i)
        i=n.indexOf("",i-1)
      end while
      if n then
        for i in range(0,n.len-1)
          n[i]=String.capitalize(n[i])
        end for
      end if
      s=n.join(" ")
    else
      s=String.capitalize(s)
    end if
    if s.len<5 then continue
    a=s[0]
    b=s[1]
    if a.lower==b or "hrl'aeiou".indexOf(b)==null and "AEIOUS".indexOf(a)==null and ["Ch","Mc"].indexOf(a+b)==null then s=String.capitalize(s[1:])
    s=String.strip(s,"'-")
    o[s]=1
    o[s.lower]=1
  end for
  r={}
	print(colorGold+"75%"+CT+" -- loading hash_table...")
	print("<align=center>"+char(171)+char(187)+"</align>")
	if arg1 == "false" then return o.indexes
  for i in o.indexes
    r[md5(i)]=i
  end for
  return r
end function
PasswordGenerator.r=function(l,s,o)
  c=s[s.len-3:]
  if self.c.hasIndex(c) and s.len<l then
    for c in self.c[c]
      self.r(l,s+c,o)
    end for
  else
    o[s]=1
  end if
end function
if globals.BIGBRAIN then 
	if arg1 == "false" then
		return "Dictionary already expaneded."
	end if
	print(colorGold+"0% -- loading hash_table, please wait..."+CT)
	HASH_TABLE = {}
	for pw in globals.dict_a
		HASH_TABLE[md5(pw)] = pw
	end for
	print(colorGold+"100%"+CT+" -- hash_table loaded...")
else
	print(colorGold+"0% -- loading hash_table, please wait..."+CT)
	if arg1 == "-t" or arg2 == "-t" then 
		PasswordGenerator.init(PASSWORDSC)	
	else 
		PasswordGenerator.init(PASSWORDS)
	end if
	//PasswordGenerator.init(globals.dict_a)
	//PasswordGenerator.init(globals.dict_a+PASSWORDS)
	//PasswordGenerator.init(PASSWORDS[0:arg2])
	//
	print(colorGold+"10%"+CT+" -- loading hash_table...")
	print("<align=center>"+char(171)+char(187)+"</align>")
	HASH_TABLE=PasswordGenerator.AllPasswords
	print(colorGold+"100%"+CT+" -- hash_table loaded...")
	print("<b>Magnum Cerebrum: expanding onboard dictionary...</b>")
	// globals.dict_a = HASH_TABLE.values
	if arg2 == "-p" then globals.dict_a = globals.dict_a + HASH_TABLE.values + PASSWORDSA + PASSWORDSB + PASSWORDSC else globals.dict_a = HASH_TABLE.values
	globals.BIGBRAIN = true
	if arg1 == "false" then
		return "Dictionary expaneded."
	end if
end if
table = "tp"
if arg1 == "hash" then table = "t5"
print(print(colorGold+"Writing tables to <u>"+home_dir+"/tables/"+table+CT))
print(colorGold+"Hash Table: ["+colorWhite+HASH_TABLE.len+"</color>]")
print("<align=center>"+char(171)+char(187)+"</align>")
out=[]
count=0
lol=1
for i in HASH_TABLE
	count=count+1
	if arg1 == "hash" then
		//out=out+char(10)+i["key"]+"="+i["value"]
		out.push(i["key"]+"="+i["value"])
	else
    	//out=out+char(10)+i["value"]
		out.push(i["value"])
	end if
    output = out.join(char(10))
	if output.len > 159900 then
		print(lol+" "+out.len+" "+output.len)
		localmachine.touch(home_dir+"/tables/"+table,lol+"")
		file=localmachine.File(home_dir+"/tables/"+table+"/"+lol)
		file.set_content(output)
		command.perms("o-rwx",file)
		out=[]
		lol=lol + 1
	end if
end for

if out.len > 1 then
	print(lol+" "+HASH_TABLE.len+" "+out.len)
	localmachine.touch(home_dir+"/tables/"+table,lol+"")
	file=localmachine.File(home_dir+"/tables/"+table+"/"+lol)
	file.set_content(out.join(char(10)))
	command.perms("o-rwx",file)
	out=""
	lol=lol + 1
end if

return file.path
end function
command.brutus = function(arg1, arg2=0, arg3=0, arg4=0, arg5=0)
	if arg1 == "-h" or arg1 == "help" then return "Usage: brutus -- attempt to gain root pass and shell using onboard dict_a "+char(10)+"(Default onboard dict_a: ["+colorGold+globals.dict_a.len+CT+"] passwords)"+char(10)+"Usage: brutus -i [/path|object] -- import dictionary (may be csv or newline separated values)"+char(10)+"-- 5hell will attempt to determine the type. Please ensure valid inputs."+char(10)+"-- accepts: path to file or folder, or piped file/folder object"+char(10)+"-- See dfit for making a.csv from newline separated dictionary file."+char(10)+"-- See cerebrum for altering onboard dict_a"+char(10)+"Advanced: brutus -s [shell_object] [ip] -- use shell_object to initiate ssh + brutus attack against ip "+char(10)+"(equal to command.ssh root@-brutus [ip] but uses the given shell instead of active shell)"
	dic = globals.dict_a
	u_name = "root"
	ip = ""
	port = 22
	b_remote = false
	if arg1 == "-i" and arg1.len == 2 then
	 	if arg2 and arg2 != "0" then
			if typeof(arg2) == "string" then
				dic = globals.get_file(arg2)
			else
				if typeof(arg2) == "file" then
					dic = arg2
				else
					return "brutus: valid option -i [/path|file_object] -- import dictionary file"
				end if
			end if
		else
			return "brutus: valid option -i [/path|file_object] -- import dictionary file"
		end if
	end if
	if DEBUG then print("arg1: "+arg1+char(10)+"arg2: "+arg2+char(10)+dic)
	if not dic then return("Dictionary: "+arg2+" not found")
	print(colorGold+"Brutus: accessing dictionary..."+CT)
	if arg1 == "-s" and arg2 and typeof(arg2) == "shell" then
		print(colorLightBlue+"brutus: </b>Configuring remote attack...<b>"+CT)
		if arg3 and arg4 then
			if arg5 then port = arg5
			if typeof(port) != "number" then port = port.to_int
			if typeof(port) != "number" then return colorRed+"brutus: invalid port"+CT
			ip = arg4
			u_name = arg3
		else
			if arg3 then u_name = arg3
			ip = user_input("root@ip: ")
		end if
		if is_valid_ip(ip) then
			print("<b>brutus: remote attack configured.</b>")
			stop = user_input(colorRed+"WARNING:"+colorOrange+"Continuing will fill the terminal with ["+colorGold+globals.dict_a.len+colorOrange+"] connection attempts."+char(10)+" This cannot be avoided. Continue? [Y/n] "+CT)
			if stop == "n" or stop == "N" then return "aborting..."
			b_remote = true
		else
			return colorRed+"Brutus: invalid ip."+CT
		end if
	end if
	if typeof(dic) == "file" then
	 	if not dic.is_binary then
			d_buf = dic.get_content
			if d_buf.indexOf(",") > 0 then
				dic = d_buf.trim.split(",")
			else
				dic = d_buf.split(char(10))
			end if
		else
			if dic.is_folder then
				df = dic.get_folders
				box = []
				for f in df
					f_buf = f.get_content
					if f_buf.indexOf(",") > 0 then
						dic_buf = f_buf.trim.split(",")
					else
						dic_buf = f_buf.split(char(10))
					end if
					for d in dic_buf
						box.push(d)
					end for
				end for
				dic = box[0:]
			else
				return "brutus: invalid dictionary input."+char(10)+"got: binary_file. expected: folder or ascii file."
			end if
		end if
	end if
	if typeof(dic) != "list" then return "brutus: dictionary error."
	if DEBUG then print("d_len: "+dic.len)
	for d in dic
		if b_remote then
			root = shell.connect_service(ip, port, u_name, d)
		else
			root = get_shell("root", d)
		end if
		if typeof(root) == "shell" then
			print("root:"+colorGold+""+d+""+CT)
			print("clipa: "+command.clipa(d))
			//print("brutus: writing to dump.txt")
			//command.poke("dump.txt",char(10)+"root:"+d+char(10))
			globals.BUFFER.push(root)
			print("<b>Shell sent to BUFFER. Access via Memory Alpha (<u>malp</u> command)</b>")
			//go = user_input("Start terminal? [y/N]"+char(10)+"||: ",0,1)
			//if go.lower == "y" then
			//	root.start_terminal
			//end if
			return root
		end if
	end for
	print("...brute force attack failed.")
	return 0
end function
command.cerebrum = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "Magnum Cerebrum: big brain. "+char(10)+"Expand dict_a to 300k+ passwords for this runtime instance. Returns zero."+char(10)+"(Use <b>pwgen</b> instead to save passwords locally)."+char(10)+colorCyan+"Advanced: cerebrum -i [/path/to/file|file_object] -- import a custom dictionary"+char(10)+"-- may be csv or nsv: ',' or char(10) "+char(10)+"-- may be file, directory or piped object"+char(10)+"Advanced: cerebrum -i [/path/to/folder] -- import text files in folder to onboard dictionary."+char(10)+"Usage: <b>cerebrum --purge</b> -- purge the onboard dictionary."+char(10)+"Advanced: cerebrum -p -- load only common player passwords (wip)"+char(10)+"Advanced: cerebrum -i @home -- import dictionary file or folder from @home server"+char(10)+"-- searches /root/tables/tp on @home server"+char(10)+"-- see help @home for more information about the @home server."
	if arg1 == "-i" and not arg2 then return "cerebrum: -i expects /path or file_object or @home."
	infile = null
	if arg1 == "--purge" then 
		globals.dict_a=["a"]
		globals.BIGBRAIN = false
		return "cerebrum: dictionary purged."
	end if
	if arg1 == "-i" and arg2 then
		if typeof(arg2) == "list" then
			globals.dict_a = arg2
			if dict_a.len > 0 then return "cerebrum: ["+colorGold+globals.dict_a.len+CT+"] passwords ready. " else return "cerebrum: import error. dictionary corrupted."
		end if
		if typeof(arg2) == "string" then
			if arg2 == "@home" then
				r_ip = ""
				r_p = "22"
				if params and params.len > 1 then
					r_ip = params[0]
					r_p = params[1].to_int
				else
					r_ip = targ.ip
					r_p = targ.pt
				end if
				if not is_valid_ip(r_ip) then return "cerebrum: set remote ip and port with command.target [ip] [port] before using -i @home option."
				r_pas = ""
				//if params and params.len > 2 then
					//r_pas = params[2]
				//else
					r_pas = user_input("@home_server_password (leave blank to abort)"+char(10)+":> ", 1)
				//end if
				if r_pas.replace(" ","") == "" then return("aborting...")
				r_r = shell.connect_service(r_ip, r_p, "root", r_pas)
				if r_r and typeof(r_r) == "shell" then
					infile = r_r.host_computer.File("/root/tables/tp")
					if not infile then return (colorRed+"404: /root/tables/tp not found. Run pwgen on remote host."+CT)
				else
					return (colorRed+"222: remote server unreachable."+CT)
				end if
			else
				infile = globals.get_file(arg2)
			end if
		else
			if typeof(arg2) == "file" then
				infile = arg2
			else
				return "cerebrum: invalid type. expects /path or file_object or @home."
			end if
		end if
		print(colorGold+"Importing..."+char(10)+colorGold+"<align=center><<>></align>"+CT)
		if infile and not infile.is_binary then
			d_b = infile.get_content
			globals.dict_a = []
			if d_b.indexOf(",") > 0 then
				globals.dict_a = globals.dict_a + d_b.split(",")
			else
				globals.dict_a = globals.dict_a + d_b.split(char(10))
			end if
		else
			if infile and infile.is_folder then
				globals.dict_a = []
				for dfile in infile.get_files
					if dfile.has_permission("r") and not dfile.is_binary then
						d_b = dfile.get_content
						delim = ""
						if d_b.indexOf(",") > 0 then
							//globals.dict_a = globals.dict_a + dfile.get_content.split(",")
							delim = ","
						else
							//globals.dict_a = globals.dict_a + dfile.get_content.split(char(10))
							delim = char(10)
						end if
						if DEBUG then print("dict_a: "+dict_a.len)
						if globals.dict_a.len < 710000 then 
							for d in d_b.split(delim)
								globals.dict_a.push(d) 
							end for
						else 
							print("cerebrum: max dict length reached. Could not load: "+dfile.path)
						end if
					end if
				end for
			else
				return "cerebrum: import error [411]."
			end if
		end if
		if dict_a.len > 0 then 
			globals.BIGBRAIN = true
			return "cerebrum: ["+colorGold+dict_a.len+CT+"] passwords ready. " 
		else 
			return "cerebrum: import error. dictionary corrupted."
		end if
	end if
	if globals.BIGBRAIN then return "Magnum Cerebrum already active."+char(10)+"Run the command: <b>cerebrum --purge</b> to reset."
	print(colorGold+"<align=center> Magnum Cerebrum </align>"+CT)
	print(colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - -"+CT)
	//globals.BIGBRAIN = true
	time_s = time
	if DEBUG then print("cerebrum calling: pwgen false "+arg1)
	command.pwgen("false",arg1)
	time_e = (time - time_s)
	print( globals.dict_a.len+" passwords readied in "+time_e+" seconds." )
	if arg1 == "-d" or arg2 == "-d" or arg3 == "-d" then return dict_a else return 0
end function
//cob = get_custom_object
   // cob.jtr = function(arg1,arg2,arg3,arg4=0)
    if DEBUG then print("<size=75%>loading jtr.5pk...(3.397kb)</size>")
    command.jtr = function(arg1,arg2,arg3,arg4=0)
        if arg1 == "help" or arg1 == "-h" or not arg3 then return "John The Ripper password generator"+char(10)+"Usage: jtr [set_size] [word_length(1-15)] [opt:aAns] [opt:1]" + char(10) + "a - lowercase alpha" +char(10)+ "A - uppercase alpha"+char(10)+"n - numbers"+char(10)+"s - special characters"+char(10)+"note: at least ONE option must be selected"+char(10)+"1 -- optional only first letter is upper case (any value here is considered 1/true), leave blank for false."
        if arg1.to_int <= 0 then return "size error: greater than zero expected"
        if arg2.to_int <= 0 or arg2.to_int > 15 then return "length error: expected between 1 and 15"
    
        array = []
        alpha_l = range("a".code,"z".code)
        i = 0
        for c in alpha_l
            alpha_l[i] = char(c)
            i = i + 1
        end for
        alpha_u = range("A".code,"Z".code)
        i = 0
        for c in alpha_u
            alpha_u[i] = char(c)
            i = i + 1
        end for
        numbers = range(0,9)
        special = ["!","@","#","$","%","^","&","*","(",")","-","+","=","}","{","[","]",";",":","<",">",",",".","'",""""]
    
        SET_SIZE = arg1.to_int // generate 1000 words 
        SET_RANGE = arg2.to_int // string of length 15
        PARAMS = [0,0,0,0] // use alpha_l, use alpha_u, use numbers, use special
        if arg3.indexOf("a") >= 0 then PARAMS[0] = 1
        if arg3.indexOf("A") >= 0 then PARAMS[1] = 1
        if arg3.indexOf("n") >= 0 then PARAMS[2] = 1
        if arg3.indexOf("s") >= 0 then PARAMS[3] = 1
        if PARAMS.indexOf(1) == null then return "option error: must select a, A, n, and/or s"
    
        first_cap = 0
        if arg4 then first_cap = 1
        //print("arg4 is "+arg4+" and first_cap is "+ first_cap)
        output = []
    
        line = []
        if PARAMS[0] then line = line + alpha_l
        if PARAMS[1] then line = line + alpha_u
        if PARAMS[2] then line = line + numbers
        if PARAMS[3] then line = line + special
        //print(line)
        if typeof(line) != "list" then return "PARAMS error"
        print("<b>Generating wordlist...</b>")
        loops = SET_SIZE
        while loops
            i = 0
            array = range( 0 , SET_RANGE - 1 )
            while i < SET_RANGE
                line.shuffle
                if first_cap == true then 
                    if i == 0 then  
                        array[i] = line[0].upper
                    else
                        array[i] = line[0].lower
                    end if
                else 
                    array[i] = line[0]
                end if
                i = i + 1
            end while
            if output.indexOf(array.join("")) == null then // ouput
                output.push(array.join(""))
                loops = loops - 1
            end if
            if SET_SIZE / loops == 4 then print("loading... 75% complete")
            if SET_SIZE / loops == 2 then print("loading... 50% complete")
        end while
        return output.join(char(10)) // max string size is 1 million chars
    end function
    
    
    // if params.len != 3 then exit( "Usage: jtr [set_size] [word_length(1-15)] [opt:aAns]" + char(10) + "a - lowercase alpha" +char(10)+ "A - uppercase alpha"+char(10)+"n - numbers"+char(10)+"s - special characters"+char(10)+"note: at least ONE option must be selected" )
    
    // print(jtr(params[0],params[1],params[2]))
      // cobble, get_custom_object interface by Plu70
  if DEBUG then print("<size=75%>loading cobble.5pk...(6.251kb)</size>")

  //command={}
  command.cob = function(arg1,arg2,arg3=0,arg4=0)
    usage_info = "<u>Cobble || custom object || cob || meta buffer</u>"+char(10)+"Usage: cob set [key] [val] -- set custom object key to val."+char(10)+"-- returns string on success or error"+char(10)+"Usage: cob get [key] -- get value of custom object key."+char(10)+"-- returns value at key or returns null on failure"+char(10)+"-- returns @reference (pointer) if value is a function"+char(10)+"Usage: cob return -- returns the raw custom object"+char(10)+"-- pipe to command.<b>code</b> to decompile the object."+char(10)+"-- ie:<b> cob return | code</b>"+char(10)+"Usage: cob inspect -- returns decompiled custom object (same as cob return | code)."+char(10)+"Usage: cob search [val] --  search for index of val."+char(10)+"-- returns string; key or failure message."+char(10)+"Inactive: cob sign -- future ability to sign custom object."+char(10)+"-- currently returns 0 (zero)."+char(10)+"Usage: cob del [key] -- delete key and its value from custom object."+char(10)+"-- returns string on success or failure."+char(10)+"Usage: cob install [key] [val] -- install piped function (val) to command.[key]"+char(10)+"-- i.e. install functions from custom object to command list"+char(10)+"Advanced: to export the onboard dictionary to the custom object:"+char(10)+"--<b> enum -d |  | enum -e | cob set dictionary</b>"+char(10)+"Advanced: to import from the custom object to the onboard dictionary"+char(10)+"--<b> cob get [dictionary] | cerebrum -i</b>"+char(10)+"OR just use<b> cob export and cob import"+char(10)+"Advanced: cob export -- export onboard dictionary to custom object"+char(10)+"Advanced: cob import -- import from custom object dictionary to onboard dictinary"+char(10)+"N.B. this is allows you to run cerebrum once, then export/import to nested shell.launches."
    if not arg1 or arg1 == "help" or arg1 == "-h" then return usage_info

    cobble = get_custom_object
    cob = {}
    cob.set = function( key=0, val=0, nil=0, nul=0 )
      if not @key then return null
      if typeof(@key) == "function" then
        if typeof(@val) == "function" then
          cobble[@key] = @val
        else
          cobble[@key] = val
        end if
      else
        if typeof(@val) == "function" then
          cobble[key] = @val
        else
          cobble[key] = val
        end if
      end if
      if cobble.hasIndex( @key ) then return "cob: set<b> "+@key+"</b> to <b>"+@val+"</b>." else return "cob: set error."
    end function

    cob.get = function( key=0, val=0, nil=0, nul=0 )
      if cobble.hasIndex( @key ) then return cobble[@key]
      if cobble.hasIndex( key ) then return cobble[ key ]
      return "cob: key not found"
    end function

    cob.search = function ( val=0, key=0, nil=0, nul=0 )
      if cobble.indexOf( @val ) != null then
        if typeof(@val) == "function" then return cobble.indexOf( @val )
        return cobble.indexOf( val )
      else
        if cobble.indexOf( val ) != null then return cobble.indexOf( val )
        return "cob: value not found."
      end if
    end function

    cob.inspect = function( key=0, val=0, nil=0, nul=0 )
      return command.code(cobble,0,0,0)
    end function

    cob.del = function( key=0, val=0, nil=0, nul=0 )
      if typeof(@key) == "function" then
        if cobble.remove( @key ) then return "cob: removed key: <b>"+@key+"</b>." //else return "cob: key not found."
      else
        if cobble.remove( key ) then return "cob: removed key: <b>"+key+"</b>." else return "cob: key not found."
      end if
    end function

    cob.sign = function( key=0, val=0, nil=0, nul=0 )
      return cob.set( "signature" , command.code("-a", key))
    end function

    cob.install = function(key=0, val=0, nil=0, nul=0)
      g = @cob.get
      new_command = g(key)
      if typeof(@new_command) == "string" then return key +": "+ new_command + ". Install failed."
      if typeof(@new_command) == "function" then 
        command[key] = @new_command 
        return "Set command."+key+" to "+@new_command
      else 
        return "cob: install expects a function"
      end if
    end function

    if arg1 == "return" then return cobble
    if arg1 == "install" then 
      return cob.install(arg2)
    end if
    if arg1 == "set" then
      if @arg3 then
        //if @arg2 == "@clipa" then arg2 = @globals.clip_board_alpha
        //if @arg2 == "@clipb" then arg2 = @globals.clip_board_beta
        //if @arg2 == "@clipc" then arg2 = @globals.clip_board_gamma
        return cob.set( @arg2, @arg3 )
      else
        return usage_info
      end if
    end if
    if arg1 == "get" then
      if @arg2 then
        g = @cob.get
        return g( @arg2 )
        //if cobble.hasIndex( arg2 ) != null then return cobble[arg2] else return null
      else
        return usage_info
      end if
    end if
    if arg1 == "inspect" then
      return cob.inspect
    end if
    if arg1 == "sign" then return cob.sign(signature)
    if arg1 == "search" then
      if @arg2 then return cob.search( @arg2 ) else return usage_info
    end if
    if arg1 == "export" then
      cob.set("dictionary",globals.dict_a)
      return "Exported "+cobble.dictionary.len+" password(s) from onbaord dictionary to custom_object.dictionary"
    end if
    if arg1 == "import" then
      if cobble.hasIndex("dictionary") then
        globals.dict_a = cob.get("dictionary")
      else
        return "cob: dictionary not found in index. set with <b>cob export</b>"
      end if
      if typeof(globals.dict_a) == "list" and globals.dict_a.len > 0 then 
        globals.BIGBRAIN = true
        return "Imported "+globals.dict_a.len+" passwords from custom_object.dictionary to onboard dictionary." 
      else 
        return "cerebrum: invalid dictionary"+char(10)+"cob: import error"
      end if
    end if
    if arg1 == "del" then
      if @arg2 then return cob.del( @arg2 ) else return usage_info
    end if
    return usage_info
  end function
  //print(command.cob("get","get"))
  //catch = command.cob("get","get")
  //print(@catch)
